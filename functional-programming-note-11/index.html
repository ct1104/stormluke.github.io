<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 函数式编程笔记 11 · Preferences</title><meta name="description" content="函数式编程笔记 11 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">函数式编程笔记 11</h1><div class="post-info">Jul 14, 2013</div><div class="post-content"><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><p><code>Set</code>是另一种集合，和序列写法相似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fruit = <span class="type">Set</span>(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</div><div class="line"><span class="keyword">val</span> s = (<span class="number">1</span> to <span class="number">6</span>).toSet</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>大部分序列上的操作在<code>Set</code>上也能用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s map (_ + <span class="number">2</span>)</div><div class="line">fruit filter (_.startWith == <span class="string">"app"</span>)</div><div class="line">s.nonEmpty</div></pre></td></tr></table></figure>
<p><code>Set</code>和序列的区别是<code>Set</code>中不包含相同元素。</p>
<h3 id="例子：n皇后问题"><a href="#例子：n皇后问题" class="headerlink" title="例子：n皇后问题"></a>例子：n皇后问题</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">nqueens</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(queens: <span class="type">List</span>[<span class="type">Int</span>]) = &#123;</div><div class="line">    <span class="keyword">val</span> lines =</div><div class="line">      <span class="keyword">for</span> (col &lt;- queens.reverse)</div><div class="line">      <span class="keyword">yield</span> <span class="type">Vector</span>.fill(queens.length)(<span class="string">"* "</span>).updated(col, <span class="string">"X "</span>).mkString</div><div class="line">    <span class="string">"\n"</span> + (lines mkString <span class="string">"\n"</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSafe</span></span>(col: <span class="type">Int</span>, queens: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = &#123;</div><div class="line">    <span class="keyword">val</span> row = queens.length</div><div class="line">    <span class="keyword">val</span> queensWithRow = (row - <span class="number">1</span> to <span class="number">0</span> by <span class="number">-1</span>) zip queens</div><div class="line">    queensWithRow forall &#123;</div><div class="line">      <span class="keyword">case</span> (r, c) =&gt; col != c &amp;&amp; math.abs(col - c) != row - r</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">queens</span></span>(n: <span class="type">Int</span>) = &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeQueens</span></span>(k: <span class="type">Int</span>): <span class="type">Set</span>[<span class="type">List</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">      <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="type">Set</span>(<span class="type">List</span>())</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="keyword">for</span> &#123;</div><div class="line">          queens &lt;- placeQueens(k - <span class="number">1</span>)</div><div class="line">          col &lt;- <span class="number">0</span> until n</div><div class="line">          <span class="keyword">if</span> isSafe(col, queens)</div><div class="line">        &#125; <span class="keyword">yield</span> col :: queens</div><div class="line">    &#125;</div><div class="line">    placeQueens(n)</div><div class="line">  &#125;</div><div class="line">  (queens(<span class="number">8</span>) take <span class="number">3</span> map show) mkString <span class="string">"\n"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// &gt; res0: String =</span></div><div class="line">  <span class="string">"</span></div><div class="line"><span class="string">  * * * * * X * *</span></div><div class="line"><span class="string">  * * * X * * * *</span></div><div class="line"><span class="string">  * X * * * * * *</span></div><div class="line"><span class="string">  * * * * * * * X</span></div><div class="line"><span class="string">  * * * * X * * *</span></div><div class="line"><span class="string">  * * * * * * X *</span></div><div class="line"><span class="string">  X * * * * * * *</span></div><div class="line"><span class="string">  * * X * * * * *</span></div><div class="line"><span class="string">  * * * * X * * *</span></div><div class="line"><span class="string">  * * * * * * X *</span></div><div class="line"><span class="string">  * X * * * * * *</span></div><div class="line"><span class="string">  * * * X * * * *</span></div><div class="line"><span class="string">  * * * * * * * X</span></div><div class="line"><span class="string">  X * * * * * * *</span></div><div class="line"><span class="string">  * * X * * * * *</span></div><div class="line"><span class="string">  * * * * * X * *</span></div><div class="line"><span class="string">  * * * * * X * *</span></div><div class="line"><span class="string">  * * X * * * * *</span></div><div class="line"><span class="string">  * * * * * * X *</span></div><div class="line"><span class="string">  * * * X * * * *</span></div><div class="line"><span class="string">  X * * * * * * *</span></div><div class="line"><span class="string">  * * * * * * * X</span></div><div class="line"><span class="string">  * X * * * * * *</span></div><div class="line"><span class="string">  * * * * X * * * "</span></div></pre></td></tr></table></figure>
<h3 id="for的翻译"><a href="#for的翻译" class="headerlink" title="for的翻译"></a><code>for</code>的翻译</h3><p><code>for</code>表达式和<code>map</code>、<code>flatMap</code>、<code>filter</code>这三个高阶函数紧密相关。这三个函数可以写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapFun</span></span>[<span class="type">T</span>, <span class="type">U</span>](xs: <span class="type">List</span>[<span class="type">T</span>], f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>] =</div><div class="line">    <span class="keyword">for</span> (x &lt;- xs) <span class="keyword">yield</span> f(x)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">T</span>, <span class="type">U</span>](xs: <span class="type">List</span>[<span class="type">T</span>], f: <span class="type">T</span> =&gt; <span class="type">Iterable</span>[<span class="type">U</span>]): <span class="type">List</span>[<span class="type">U</span>] =</div><div class="line">    <span class="keyword">for</span> (x &lt;- xs; y &lt;- f(x)) <span class="keyword">yield</span> y</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>], p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">T</span>] =</div><div class="line">    <span class="keyword">for</span>(x &lt;- xs <span class="keyword">if</span> p(x)) <span class="keyword">yield</span> x</div></pre></td></tr></table></figure>
<p>事实上，Scala编译器将<code>for</code>表达式翻译成<code>map</code>、<code>flatMap</code>和懒求值的<code>filter</code>变体。</p>
<p>Scala编译器用下面的方式翻译：</p>
<h4 id="1-简单的for表达式"><a href="#1-简单的for表达式" class="headerlink" title="1. 简单的for表达式"></a>1. 简单的<code>for</code>表达式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1) <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>被翻译成</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.map(x =&gt; e2)</div></pre></td></tr></table></figure>
<h4 id="2-带过滤器的for表达式"><a href="#2-带过滤器的for表达式" class="headerlink" title="2. 带过滤器的for表达式"></a>2. 带过滤器的<code>for</code>表达式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1 <span class="keyword">if</span> f; s) <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>其中<code>f</code>是过滤器，<code>s</code>是剩下的生成器过滤器序列。这会被翻译成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1.withFilter(x =&gt; f); s) <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>可以认为<code>withFilter</code>是不生成临时中间列表的<code>filter</code>。</p>
<h4 id="3-多个生成器的for表达式"><a href="#3-多个生成器的for表达式" class="headerlink" title="3. 多个生成器的for表达式"></a>3. 多个生成器的<code>for</code>表达式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1; y &lt;- e2; s) <span class="keyword">yield</span> e3</div></pre></td></tr></table></figure>
<p>其中<code>s</code>是剩下的生成器过滤器序列，这会被翻译成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.flatMap(x =&gt; <span class="keyword">for</span> (y &lt;- e2; s) <span class="keyword">yield</span> e3)</div></pre></td></tr></table></figure>
<p>可以看到上面三种情况概括了所有的<code>for</code>表达式形式。</p>
<p>例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    i &lt;- <span class="number">1</span> until n</div><div class="line">    j &lt;- <span class="number">1</span> until i</div><div class="line">    <span class="keyword">if</span> isPrime(i + j)</div><div class="line">&#125; <span class="keyword">yield</span> (i, j)</div></pre></td></tr></table></figure>
<p>用上面的方法会被翻译为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> until n).flatMap =&gt;</div><div class="line">    (<span class="number">1</span> until i).withFilter(j =&gt; isPrime(i + j)).map(j =&gt; (i, j))</div></pre></td></tr></table></figure>
<h3 id="for的推广"><a href="#for的推广" class="headerlink" title="for的推广"></a><code>for</code>的推广</h3><p>有趣的是，<code>for</code>不仅仅只能应用在列表或序列上，它只要求<code>map</code>、<code>flatMap</code>、<code>withFilter</code>这三个方法存在即可。</p>
<p>所以可以将其应用在数组、遍历器、数据库、XML数据、可选值、分析器等等中。</p>
<p><code>for</code>是Scala数据库框架ScalaQuery、Slick的基础。微软的LINQ也有同样的思想。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h3><p><code>Map[Key, Value]</code>是一种将键<code>Key</code>和值<code>Value</code>结合起来的数据结构。</p>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> romanNumbers = <span class="type">Map</span>(<span class="string">"I"</span> -&gt; <span class="number">1</span>, <span class="string">"V"</span> -&gt; <span class="number">5</span>, <span class="string">"X"</span> -&gt; <span class="number">10</span>)</div><div class="line"><span class="keyword">val</span> capitalOfCountry = <span class="type">Map</span>(<span class="string">"US"</span> -&gt; <span class="string">"Washington"</span>, <span class="string">"Switzerland"</span> -&gt; <span class="string">"Bern"</span>)</div></pre></td></tr></table></figure>
<p>类<code>Map[Key, Value]</code>继承自<code>Iterable[(Key, Value)]</code>，因此大部分<code>Iterable</code>的方法能在<code>Map</code>上用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> countryOfCapital = capitalOfCounty map &#123;</div><div class="line">    <span class="keyword">case</span>(x, y) =&gt; (y, x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>事实上，<code>-&gt;</code>语法就相当于写二元组<code>(key, value)</code>。</p>
<p>类<code>Map[Key, Value]</code>也继承了函数类型<code>Key =&gt; Value</code>，所以<code>Map</code>可以像函数一样使用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">capitalOfCountry(<span class="string">"Andorra"</span>)    <span class="comment">// java.util.NoSuchElementException: key not found: Andorra</span></div><div class="line">``` scala</div><div class="line"></div><div class="line">想要在不知道是否包含键的情况下访问`<span class="type">Map</span>`，可以使用`get`操作：</div><div class="line"></div><div class="line">``` scala</div><div class="line">capitalOfCountry get <span class="string">"US"</span>         <span class="comment">// Some("Washington")</span></div><div class="line">capitalOfCountry get <span class="string">"Andorra"</span>    <span class="comment">// None</span></div></pre></td></tr></table></figure>
<p><code>get</code>的返回值是一个<code>Option</code>值。</p>
<h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a><code>Option</code></h3><p><code>Option</code>是这样定义的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Option</span>[+<span class="type">A</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Some</span>[+<span class="type">A</span>](<span class="params">value <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">A</span>]</span></div><div class="line"><span class="class"><span class="title">object</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">Nothing</span>]</span></div></pre></td></tr></table></figure>
<p><code>map get key</code>表达式返回：</p>
<ul>
<li><code>None</code>：如果<code>map</code>不包含键<code>key</code></li>
<li><code>Some(x)</code>：如果<code>map</code>包含键<code>key</code></li>
</ul>
<p>因为<code>Option</code>被定义为case类，所以用模式匹配分解它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCapital</span></span>(country: <span class="type">String</span>) = capitalOfCountry.get(country) <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(capital) =&gt; capital</div><div class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="string">"missing data"</span></div><div class="line">&#125;</div><div class="line">showCapital(<span class="string">"US"</span>)         <span class="comment">// "Washington"</span></div><div class="line">showCapital(<span class="string">"Andorra"</span>)    <span class="comment">// "missing data"</span></div></pre></td></tr></table></figure>
<h3 id="sorted和groupBy"><a href="#sorted和groupBy" class="headerlink" title="sorted和groupBy"></a><code>sorted</code>和<code>groupBy</code></h3><p>除了<code>for</code>表达式外另两个有用的SQL查询是<code>groupBy</code>和<code>orderBy</code>。</p>
<p><code>orderBy</code>在集合上可以用<code>sortWith</code>和<code>sorted</code>来表达：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fruit = <span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>, <span class="string">"pineapple"</span>)</div><div class="line">fruit sortWith (_.length <span class="comment">// List("pear", "apple", "orange", "pineapple")</span></div><div class="line">fruit.sorted                            <span class="comment">// List("apple", "orange", "pear", "pineapple")</span></div></pre></td></tr></table></figure>
<p><code>groupBy</code>在Scala集合上也能用，它通过<em>鉴别器函数</em><code>f</code>将一个集合分解成一个包含多个集合的map。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fruit groupBy (_.head)    <span class="comment">// &gt; Map(p -&gt; List(pear, pineapple),</span></div><div class="line">                          <span class="comment">// |     a -&gt; List(apple),</span></div><div class="line">                          <span class="comment">// |     o -&gt; List(orange))</span></div></pre></td></tr></table></figure>
<h3 id="例子：多项式"><a href="#例子：多项式" class="headerlink" title="例子：多项式"></a>例子：多项式</h3><p>假设<code>x^3 - 2x + 5</code>表示成<code>Map(0 -&gt; 5, 1 -&gt; -2, 3 -&gt; 1)</code>，则可以设计一个类<code>Poly</code>来表示多项式。</p>
<p>到目前为止，map还只是<em>部分函数</em>，如果键不存在，<code>map(key)</code>就会抛出异常。可以用<code>withDefaultValue</code>操作将map转变为完全函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> cap1 = capitalOfCountry withDefaultValue <span class="string">""</span></div><div class="line">cap1(<span class="string">"Andorra"</span>)    <span class="comment">// ""</span></div></pre></td></tr></table></figure>
<p>多项式可以先写成这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">polynomials</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Poly</span>(<span class="params">terms0: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Double</span>]</span>) </span>&#123;</div><div class="line">    <span class="keyword">val</span> terms = terms0 withDefaultValue <span class="number">0.0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(other: <span class="type">Poly</span>) = <span class="keyword">new</span> <span class="type">Poly</span>(terms ++ (other.terms map adjust))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust</span></span>(term: (<span class="type">Int</span>, <span class="type">Double</span>)): (<span class="type">Int</span>, <span class="type">Double</span>) = &#123;</div><div class="line">      <span class="keyword">val</span> (exp, coeff) = term</div><div class="line">      terms get exp <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Some</span>(coeff1) =&gt; exp -&gt; (coeff + coeff1)</div><div class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; exp -&gt; coeff</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>=</div><div class="line">      (<span class="keyword">for</span> ((exp, coeff) &lt;- terms.toList.sorted.reverse) <span class="keyword">yield</span> coeff + <span class="string">"x^"</span> + exp) mkString <span class="string">" + "</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Poly</span>(<span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">2.0</span>, <span class="number">3</span> -&gt; <span class="number">4.0</span>, <span class="number">5</span> -&gt; <span class="number">6.2</span>))    <span class="comment">// &gt; p1: Poly = 6.2x^5 + 4.0x^3 + 2.0x^1</span></div><div class="line">  <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Poly</span>(<span class="type">Map</span>(<span class="number">0</span> -&gt; <span class="number">3.0</span>, <span class="number">3</span> -&gt; <span class="number">7.0</span>))              <span class="comment">// &gt; p2: Poly = 7.0x^3 + 3.0x^0</span></div><div class="line">  p1 + p2                                                 <span class="comment">// &gt; res0: Poly = 6.2x^5 + 11.0x^3 + 2.0x^1 + 3.0x^0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是每次都要用<code>Map</code>来包裹参数很不方便。可以用<em>多重参数</em>来改进它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(bindings: (<span class="type">Int</span>, <span class="type">Double</span>)*) = <span class="keyword">this</span>(bindings.toMap)</div></pre></td></tr></table></figure>
<p>其中<code>bindings</code>的类型为<code>Seq[(Int, Double)]</code>。</p>
<p>加法操作也可以用<code>foldLeft</code>来改写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poly</span>(<span class="params">terms0: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Double</span>]</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(bindings: (<span class="type">Int</span>, <span class="type">Double</span>)*) = <span class="keyword">this</span>(bindings.toMap)</div><div class="line">    <span class="keyword">val</span> terms = terms0 withDefaultValue <span class="number">0.0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(other: <span class="type">Poly</span>) = <span class="keyword">new</span> <span class="type">Poly</span>((other.terms foldLeft terms)(addTerm))</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTerm</span></span>(terms: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Double</span>], term: (<span class="type">Int</span>, <span class="type">Double</span>)): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Double</span>] = &#123;</div><div class="line">        <span class="keyword">val</span> (exp, coeff) = term</div><div class="line">        terms + (exp -&gt; (coeff + terms(exp)))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>=</div><div class="line">        (<span class="keyword">for</span> ((exp, coeff) &lt;- terms.toList.sorted.reverse) <span class="keyword">yield</span> coeff + <span class="string">"x^"</span> + exp) mkString <span class="string">" + "</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上<code>foldLeft</code>版本比<code>++</code>版本的更有效率，原因是<code>foldLeft</code>直接将系数加到<code>terms</code>中得到了新的map，而<code>++</code>版本中创建了一个临时map后再将他们连接起来。</p>
</div></article></div></main><footer><div class="paginator"><a href="/functional-programming-note-12/" class="prev">PREV</a><a href="/functional-programming-note-10/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'functional-programming-note-11/';
var disqus_title = '函数式编程笔记 11';
var disqus_url = 'http://stormluke.me/functional-programming-note-11/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>