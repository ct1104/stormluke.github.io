<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 函数式编程笔记 10 · Preferences</title><meta name="description" content="函数式编程笔记 10 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">函数式编程笔记 10</h1><div class="post-info">Jul 13, 2013</div><div class="post-content"><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><code>Vector</code></h3><p>列表是<em>线性</em>的，而向量是树形的，所以向量比列表有更平衡的访问时间(log32(n))。</p>
<p>向量和列表的定义方法类似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nums = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-88</span>)</div><div class="line"><span class="keyword">val</span> people = <span class="type">Vector</span>(<span class="string">"Bob"</span>, <span class="string">"James"</span>, <span class="string">"Peter"</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>基本的运算符：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x +: xs    <span class="comment">// 创建一个首元素是x，后跟xs所有元素的向量</span></div><div class="line">xs :+ x    <span class="comment">// 相反</span></div></pre></td></tr></table></figure>
<h3 id="集合的继承层次"><a href="#集合的继承层次" class="headerlink" title="集合的继承层次"></a>集合的继承层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Iterable &lt;-| Map</div><div class="line">           | Set</div><div class="line">           | Seq &lt;-| List</div><div class="line">                   | Vector</div><div class="line">                   | Range</div><div class="line">                   | String</div><div class="line">                   | Array</div></pre></td></tr></table></figure>
<p>其中<code>Array</code>和<code>String</code>支持和<code>Seq</code>相同的操作，并且可以隐式转换成<code>Seq</code>，但它们并不是<code>Seq</code>的子类，原因是它们来自于Java。</p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a><code>Range</code></h3><p><code>Range</code>是整数的序列，三个运算符：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> r: <span class="type">Range</span> = <span class="number">1</span> until <span class="number">5</span>    <span class="comment">// 1, 2, 3, 4</span></div><div class="line"><span class="keyword">val</span> s: <span class="type">Range</span> = <span class="number">1</span> to <span class="number">5</span>       <span class="comment">// 1, 2, 3, 4, 5</span></div><div class="line"><span class="number">1</span> to <span class="number">10</span> by <span class="number">3</span>                <span class="comment">// 1, 4, 7, 10</span></div><div class="line"><span class="number">6</span> to <span class="number">1</span> by <span class="number">-2</span>                <span class="comment">// 6, 4, 2</span></div></pre></td></tr></table></figure>
<h3 id="更多的Seq操作符"><a href="#更多的Seq操作符" class="headerlink" title="更多的Seq操作符"></a>更多的<code>Seq</code>操作符</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">xs exists p     <span class="comment">// 是否包含满足p条件的元素</span></div><div class="line">xs forall p     <span class="comment">// 是否所有元素都满足p条件</span></div><div class="line">xs zip ys       <span class="comment">// 返回包含二元组的列表，其中元素是xs和ys</span></div><div class="line">xs unzip        <span class="comment">// zip的逆操作，返回包含列表的二元组</span></div><div class="line">xs.flatMap f    <span class="comment">// map后将各结果连接起来成一个集合</span></div><div class="line">xs.sum          <span class="comment">// 数集求和</span></div><div class="line">xs.product      <span class="comment">// 数集求积</span></div><div class="line">xs.max          <span class="comment">// 最大值</span></div><div class="line">xs.min          <span class="comment">// 最小值</span></div></pre></td></tr></table></figure>
<p>例子：列出1..M和1..N之间所有数组成的数对</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> to <span class="type">M</span>) flatMap (x =&gt; (<span class="number">1</span> to <span class="type">N</span>) map (y =&gt; (x, y)))</div></pre></td></tr></table></figure>
<p>例子：求数量积</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">scalarProduct</span></span>(xs: <span class="type">Vector</span>[<span class="type">Double</span>], ys: <span class="type">Vector</span>[<span class="type">Double</span>]): <span class="type">Double</span> =</div><div class="line">    (xs zip ys).map(xy =&gt; xy._1 * xy._2).sum</div></pre></td></tr></table></figure>
<p>也可以用<em>模式匹配函数值</em>写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">scalarProduct</span></span>(xs: <span class="type">Vector</span>[<span class="type">Double</span>], ys: <span class="type">Vector</span>[<span class="type">Double</span>]): <span class="type">Double</span> =</div><div class="line">    (xs zip ys).map&#123; <span class="keyword">case</span> (x, y) =&gt; x * y &#125;.sum</div></pre></td></tr></table></figure>
<p>其中，函数值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">case</span> p1 =&gt; e1 … <span class="keyword">case</span> pn =&gt; en &#125;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x =&gt; x <span class="keyword">match</span> &#123; <span class="keyword">case</span> p1 =&gt; e1 … <span class="keyword">case</span> pn =&gt; en &#125;</div></pre></td></tr></table></figure>
<p>练习：判断素数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> = (<span class="number">2</span> until n) forall (d =&gt; n % d != <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>练习：给出一个正整数n，找出满足1 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> n = <span class="number">10</span>                            <span class="comment">// &gt; n: Int = 10</span></div><div class="line">(<span class="number">1</span> until n) map (i =&gt;</div><div class="line">    (<span class="number">1</span> until i) map (j =&gt; (i, j)))    <span class="comment">// &gt; res0: scala.collection.immutable.IndexedSeq[scala.collection.immutable.IndexedSeq[(Int, Int)]] = Vector(Vector(), Vector((2,1)), Vector((3,1), (3,2)), Vector((4,1), (4,2), (4,3)), Vector((5,1), (5,2), (5,3), (5,4)), Vector((6,1), (6,2),(6,3), (6,4), (6,5)), Vector((7,1), (7,2), (7,3), (7,4), (7,5), (7,6)), Vector((8,1), (8,2), (8,3), (8,4), (8,5), (8,6), (8,7)), Vector((9,1), (9,2), (9,3), (9,4), (9,5), (9,6), (9,7), (9,8)))</span></div></pre></td></tr></table></figure>
<p>会发现返回值类型为<code>IndexedSeq</code>，实际类型为<code>Vector</code>。这是因为<code>Vector</code>和<code>Range</code>均继承于<code>IndexedSeq</code>，而<code>Range</code>不能包含二元组，所以Scala将其换成兄弟类<code>Vector</code>。</p>
<p>但是期待的返回值类型为二元组的序列，上面的结果并不满足，可以这样解决（设之前结果为<code>xss</code>）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(xss foldRight <span class="type">Seq</span>[<span class="type">Int</span>]())(_ ++ _)</div></pre></td></tr></table></figure>
<p>或者用内置方法<code>flatten</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xss.flatten</div></pre></td></tr></table></figure>
<p>一个实用的等式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xs flatMap f = (xs map f).flatten</div></pre></td></tr></table></figure>
<p>所以可以这样简化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> until n) flatMap (i =&gt;</div><div class="line">    (i until i) map (j =&gt; (i, j)))</div></pre></td></tr></table></figure>
<p>最终解为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> until n) flatMap (i =&gt;</div><div class="line">    (i until i) map (j =&gt; (i, j))) filter ( pair =&gt;</div><div class="line">        isPrime(pair._1 + pair._2))</div></pre></td></tr></table></figure>
<p>这解决了问题，但十分麻烦。</p>
<h3 id="for表达式"><a href="#for表达式" class="headerlink" title="for表达式"></a><code>for</code>表达式</h3><p>假设<code>persons</code>是包含类<code>Person</code>的列表，其中<code>Person</code>为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></div></pre></td></tr></table></figure>
<p>想取出年龄大于20岁的人，可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( p &lt;- persons <span class="keyword">if</span> p.age &gt; <span class="number">20</span> ) <span class="keyword">yield</span> p.name</div></pre></td></tr></table></figure>
<p>这和下面的相等：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">persons filter (p =&gt; p.age &gt; <span class="number">20</span>) map (p =&gt; p.name)</div></pre></td></tr></table></figure>
<p><code>for</code>表达式和命令式语言中的循环类似，不同之处在于它将遍历结果生成了列表。</p>
<p><code>for</code>表达式的形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( s ) <span class="keyword">yield</span> e</div></pre></td></tr></table></figure>
<p>其中<code>s</code>是一系列<em>生成器(generator)</em>和<em>过滤器(filter)</em>，<code>e</code>是一个表达式，它的值会在每个遍历中返回。</p>
<ul>
<li>生成器的形式为<code>p &lt;- e</code>，其中<code>p</code>是一个模式，<code>e</code>是一个值为集合的表达式</li>
<li>过滤器的形式为<code>if f</code>，其中<code>f</code>是一个布尔表达式</li>
<li>序列必须由生成器开头</li>
<li>如果有多个生成器，后面的生成器得比前面的先改变</li>
</ul>
<p>也可以用大括号<code>{}</code>代替小括号<code>()</code>，这时生成器和过滤器序列可以写成多行且不用带分号。</p>
<p>例子：用<code>for</code>表达式改写之前的练习</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    i &lt;- <span class="number">1</span> until n</div><div class="line">    j &lt;- <span class="number">1</span> until i</div><div class="line">    <span class="keyword">if</span> isPrime(i + j)</div><div class="line">&#125; <span class="keyword">yield</span> (i, j)</div></pre></td></tr></table></figure>
<p>练习：用<code>for</code>表达式重写<code>scalarProduct</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">scalarProduct</span></span>(xs: <span class="type">List</span>[<span class="type">Double</span>], ys: <span class="type">List</span>[<span class="type">Double</span>]): <span class="type">Double</span> =</div><div class="line">    (<span class="keyword">for</span> ((x, y) &lt;- xs zip ys) <span class="keyword">yield</span> x * y).sum</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/functional-programming-note-11/" class="prev">PREV</a><a href="/2013-07-10/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'functional-programming-note-10/';
var disqus_title = '函数式编程笔记 10';
var disqus_url = 'http://stormluke.me/functional-programming-note-10/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>