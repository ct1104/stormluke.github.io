<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Preferences</title>
  
  <subtitle>Luke&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://stormluke.me/"/>
  <updated>2018-04-24T01:10:12.311Z</updated>
  <id>http://stormluke.me/</id>
  
  <author>
    <name>stormluke</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何调试前端：优化网络资源</title>
    <link href="http://stormluke.me/how-to-debug-front-end-optimising-network-assets/"/>
    <id>http://stormluke.me/how-to-debug-front-end-optimising-network-assets/</id>
    <published>2018-04-24T02:00:00.000Z</published>
    <updated>2018-04-24T01:10:12.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://blog.pragmatists.com/how-to-debug-front-end-optimising-network-assets-c0bfcad29b40" target="_blank" rel="external">How to debug front-end: optimising network assets</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dcf8a1ac50?w=800&amp;h=533&amp;f=jpeg&amp;s=67696" alt=""></p><p>网络性能可以决定 web app 的成败。最初 app 很新很小时，很少有开发者会持续关注 app 到底用了多长时间发送了多少兆字节给用户。</p><a id="more"></a><p>如果你从未测量过自己 app 的性能，那很可能会有一些改进余地。问题是，你需要改善多少才能让用户注意到。</p><p>在下面的研究中，你可以找到有关多长的加载时间差异可以被人们明显地感受到的信息。如果你想让用户注意到你的努力，那就要超过 20% 这个门槛。<a href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule" target="_blank" rel="external">阅读更多</a></p><p>这篇文章中，我会介绍（TL;DR）：</p><ul><li>通过 Chrome Devtool Audit 来测量性能</li><li>图像优化</li><li>Web 字体优化</li><li>JavaScript 优化</li><li>渲染阻塞资源时的优化</li><li>其他性能测量应用/扩展</li></ul><p>如果你正在努力解决这之外的一些问题，请在评论告诉所我们 —— 我们的团队和读者们很乐意提供帮助。</p><p><strong>这篇文章是《如何调试前端》系列的一部分：</strong></p><ul><li><a href="https://blog.pragmatists.com/how-to-debug-front-end-elements-d97da4cbc3ea" target="_blank" rel="external">如何调试前端：HTML/CSS</a></li><li><a href="https://blog.pragmatists.com/how-to-debug-front-end-console-3456e4ee5504" target="_blank" rel="external">如何调试前端：控制台</a></li></ul><h3 id="衡量-app-的性能"><a href="#衡量-app-的性能" class="headerlink" title="衡量 app 的性能"></a>衡量 app 的性能</h3><h4 id="Chrome-Devtools-Audits"><a href="#Chrome-Devtools-Audits" class="headerlink" title="Chrome Devtools Audits"></a>Chrome Devtools Audits</h4><p>由于整篇文章都是关于 Chrome Devtools 的，我们就先从 Audit 标签页开始（其本身使用了 Lighthouse）</p><p>打开 Chrome Devtools &gt; Audits &gt; Perform an audit… &gt; Run audit</p><p>我决定检查性能（Performance）和最佳实践（Best practices），但我们这次暂不涉及渐进式 Web 应用（Progressive Web App）或无障碍性（Accessibility）主题。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dce7f69c18?w=609&amp;h=367&amp;f=png&amp;s=38700" alt=""></p><p>不错。一段时间后，我们完成了性能评估，并知道了一些改进这些性能指标的可行方法。如果 Audit 把屏幕分辨率调成了「移动设备」，请不必担心，因为对于 Chrome 来说这是正常的。我强烈建议你用 Chrome 金丝雀版（Canary）来执行评估。金丝雀版有个可以评估桌面版网页的选项，并且增加了网络限速功能 —— 看看下面的图片。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dcdd8c9b18?w=800&amp;h=102&amp;f=png&amp;s=10356" alt=""></p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dcd7c1253e?w=694&amp;h=241&amp;f=png&amp;s=29733" alt=""></p><p>指标（Metrics）选项卡收集了基本的测量结果，并且提供了页面加载时间的总体概况。</p><p><strong><code>首次有意义绘图（First meaningful paint）</code></strong> —— audit 确定用户首次看到主要内容所需的时间。请尽可能保持在 1 秒以下。<a href="https://developers.google.com/web/fundamentals/performance/rail" target="_blank" rel="external">阅读更多</a></p><p><strong><code>首次可交互（First interactive）</code></strong> —— 指首次用户看到可交互 UI 元素并且页面可以响应所需的时间。</p><p><strong><code>感知速度指数（Perceptual Speed Index）</code></strong> —— 指显示页面可见部分的平均时间。它以毫秒表示并取决于视口的大小。请尽量保持在 1250 毫秒以下。<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank" rel="external">阅读更多</a></p><p><strong><code>预估输入延迟（Estimated Input Latency）</code></strong> —— 应用响应用户输入的时间，以毫秒为单位。</p><h4 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h4><p><strong><code>改进点（Opportunities）</code></strong> —— 是一个更详细的部分，收集了有关图片、CSS 和响应时间的信息。我会介绍每个项目，并加上一些如何加速的小提示。</p><h4 id="减少阻塞渲染（render-blocking）的样式表"><a href="#减少阻塞渲染（render-blocking）的样式表" class="headerlink" title="减少阻塞渲染（render-blocking）的样式表"></a>减少阻塞渲染（render-blocking）的样式表</h4><p>CSS 文件被视为渲染阻塞资源。意味着浏览器会等待它们完全加载完毕，之后才开始渲染。最简单的方法就是不加载不必要的 CSS 文件。如果你使用 bootstrap，也许你不需要整个库来样式化你的页面 —— 尤其是在项目刚开始时。</p><p>其次，你可以考虑针对不同屏幕尺寸进行优化。要降低加载 CSS 的数量级，可以使用条件加载，它只加载特定屏幕分辨率所需的 CSS 文件。下面有个例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></div></pre></td></tr></table></figure><p>如果对你来说还不够，Keith Clark 提出了一个不阻塞页面渲染的加载 CSS 的好主意。诀窍是对媒体查询（media query）使用带有无效值的链接元素。当媒体查询结果为 false 时，浏览器仍然会下载样式表，但不会延迟渲染页面。您可以将剩余的不必要的 CSS 分离出来并稍后下载。<a href="https://keithclark.co.uk/articles/loading-css-without-blocking-render/" target="_blank" rel="external">阅读更多</a></p><h4 id="保持较低的服务响应时间"><a href="#保持较低的服务响应时间" class="headerlink" title="保持较低的服务响应时间"></a>保持较低的服务响应时间</h4><p>虽然这部分可能是不言自明的，但仍值得我们提醒自己它的作用。为了减少服务器响应时间，你可以考虑为某些资源使用 CDN。也可以采用 HTTP2，或简单地删除不必要的请求，并在渲染页面后延迟加载它们。</p><h4 id="合适尺寸的图片（Properly-size-Images）、离屏图片（Offscreen-images）和下一代格式（next-gen-formats）"><a href="#合适尺寸的图片（Properly-size-Images）、离屏图片（Offscreen-images）和下一代格式（next-gen-formats）" class="headerlink" title="合适尺寸的图片（Properly size Images）、离屏图片（Offscreen images）和下一代格式（next-gen formats）"></a>合适尺寸的图片（Properly size Images）、离屏图片（Offscreen images）和下一代格式（next-gen formats）</h4><p>这三部分都与一个主题紧密相关 —— 图片。要准确了解你正在加载哪些图片以及它们所占的时间比重，请进入 Chrome Devtools 的网络选项卡并通过 IMG 选项进行过滤。通过查看大小和时间这两行，看看你是否满意这些结果。关于每个图片的大小比重并没有一般性的规则。这很大程度上取决于你的客户端设备、客户端群以及更多只有你自己才了解的情况。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dcdca31df3?w=800&amp;h=445&amp;f=png&amp;s=207890" alt=""></p><p>我想在这里更多地谈谈图片优化。在 Audit 结果中这个主题多次出现。</p><h4 id="图像优化"><a href="#图像优化" class="headerlink" title="图像优化"></a>图像优化</h4><p>图片光栅图和矢量图。光栅图由像素组成。我们通常将它们用于照片和复杂的动画。扩展名：jpg、jpeg、gif。</p><p>矢量图由几何图像组成。我们将它们用于徽标和图标，因为它们可以随意缩放不失真。扩展名：svg。</p><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>SVG 从一开始就相对较小，但用这些优化器可以使它更小。</p><ul><li><a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="external">SvgOmg</a></li><li><a href="http://petercollingridge.appspot.com/svg-optimiser" target="_blank" rel="external">Svg-optimiser</a></li></ul><h4 id="光栅图"><a href="#光栅图" class="headerlink" title="光栅图"></a>光栅图</h4><p>这里有点棘手，因为光栅图像可能非常大。有几种技术可以使它们保持较大的分辨率但仍有较小的文件大小。</p><h4 id="多张图片"><a href="#多张图片" class="headerlink" title="多张图片"></a>多张图片</h4><p>首先准备多个版本的图像。你并不想在手机上加载视网膜级大小的图像，对吗？尝试制作 3 到 4 个版本的图片。手机版、平板版、桌面版和视网膜版。它们的大小取决于你的目标设备。如果你有任何疑问，请查看<a href="https://css-tricks.com/snippets/css/media-queries-for-standard-devices/" target="_blank" rel="external">链接</a>中的标准查询。</p><h4 id="Srcset-属性"><a href="#Srcset-属性" class="headerlink" title="Srcset 属性"></a>Srcset 属性</h4><p>当你的图像准备好后，src 属性有助于定义何时加载哪些图像。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"ing.jpg"</span> <span class="attr">srcset</span>=<span class="string">"img.jpg, img2x.jpg 2x"</span> <span class="attr">alt</span>=<span class="string">"img"</span>&gt;</span></div></pre></td></tr></table></figure><p><code>src</code> 给不支持 <code>srcset</code> 的浏览器用<br><code>srcset</code> 给支持的浏览器用<br><code>img2x.jpg</code> 给像素缩放比为 2.0 的设备用（视网膜）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img.jpg"</span> <span class="attr">srcset</span>=<span class="string">"img1024.jpg 1024w, img2048.jpg 2048w"</span> <span class="attr">alt</span>=<span class="string">"img"</span>&gt;</span></div></pre></td></tr></table></figure><p><code>src</code> 给不支持 <code>srcset</code> 的浏览器用<br><code>srcset</code> 给支持的浏览器用<br><code>img1024</code> 给宽度为 1024 时使用，等等.</p><p>上面的例子来自于 <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images" target="_blank" rel="external">Developer Mozilla</a></p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>你还可以创建上面提到过的媒体查询和样式，例如平板或手机。这种方法与 CSS 预处理器同时使用时特别有效。</p><p>srcset 属性的替代品是媒体查询，它的规则不在 HTML 中，而是在 CSS 文件里。对于纯 CSS，这种方法非常耗时，不值得花时间去做。但在这里，预处理器可以通过混入（mixins）和变量来解决问题。有了预处理器后，媒体查询与 srcset 不相上下。决定权在你。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@desktop:</span>   <span class="string">~"only screen and (min-width: 960px) and (max-width: 1199px)"</span>;</div><div class="line"><span class="variable">@tablet:</span>    <span class="string">~"only screen and (min-width: 720px) and (max-width: 959px)"</span>;</div><div class="line"></div><div class="line"><span class="keyword">@media</span> <span class="variable">@desktop</span> &#123;</div><div class="line">  <span class="selector-tag">footer</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">940px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@media</span> <span class="variable">@tablet</span> &#123;</div><div class="line">  <span class="selector-tag">footer</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">768px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="图片-CDNs"><a href="#图片-CDNs" class="headerlink" title="图片 CDNs"></a>图片 CDNs</h4><p>当照片准备好并优化后，你还可以优化分发的过程。像 Cloudinary 这样的工具可以显着减少响应延迟。他们的服务器遍布全球，因此分发速度会更快。使用 HTTP 时，对于一个服务器你只能开启 6 个并行请求。使用 CDN 后，并行请求数量会随着服务器数量成倍增长。</p><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>有时候，图片必须很花哨且很大。如果你为长时间的延迟而困扰，可以试试图片模糊化或延迟加载。</p><p>延迟加载是一种在需要时才开始加载图片或其他任何内容的方法。当图库中有 1000 个图片时，并非所有图片都需要加载。只需加载前 10 个，其余的等用户需要时再加载。</p><p>有大量的库可以做到这点。<a href="https://www.sitepoint.com/five-techniques-lazy-load-images-website-performance/" target="_blank" rel="external">阅读更多</a></p><p>Facebook 目前正在使用图片模糊化。当你在网络不好的情况下打开某人的资料页时，刚开始图片是模糊的；后来它才变得清晰。<a href="https://css-tricks.com/the-blur-up-technique-for-loading-background-images/" target="_blank" rel="external">阅读更多</a></p><h3 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h3><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dcdb4c9e46?w=712&amp;h=469&amp;f=png&amp;s=52459" alt=""></p><p>诊断页（Diagnostics）结束了这一系列测试。我不会详细介绍列表里的每一个标题，因为其中一些主题已经介绍过了。我只会提及其中的一些，并试图在整体上涵盖这些主题。</p><h4 id="对静态资源使用了低效的缓存策略"><a href="#对静态资源使用了低效的缓存策略" class="headerlink" title="对静态资源使用了低效的缓存策略"></a>对静态资源使用了低效的缓存策略</h4><p>Goole 很注重缓存和无服务器应用。缓存完全取决于你，我不是缓存的忠实拥护者。如果你想了解更多缓存的东西，Google 准备了一些不错的课程。<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#cache-control" target="_blank" rel="external">阅读更多</a></p><h4 id="关键请求链-阻塞渲染的脚本"><a href="#关键请求链-阻塞渲染的脚本" class="headerlink" title="关键请求链 / 阻塞渲染的脚本"></a>关键请求链 / 阻塞渲染的脚本</h4><p>关键请求链（Critical request chains）包含了需要在页面渲染前就完成的请求。保持它尽可能小至关重要。</p><p>我们之前提到了 CSS 加载，现在我们来讨论一下 Web 字体。</p><h4 id="优化-Web-字体"><a href="#优化-Web-字体" class="headerlink" title="优化 Web 字体"></a>优化 Web 字体</h4><p>在创建 web 应用/网站时，目前我们使用四种字体格式：EOT、TTF、WOFF、WOFF2。</p><p>没有一种格式是最合适的，因此我们需要再次针对不同的浏览器使用不同的格式。这个主题的入门教程和更多解释在这里。<a href="https://css-tricks.com/snippets/css/using-font-face/" target="_blank" rel="external">阅读更多</a><br>不过在刚开始时，最好问问自己是否真的需要使用一个 web 字体。<a href="https://hackernoon.com/web-fonts-when-you-need-them-when-you-dont-a3b4b39fe0ae" target="_blank" rel="external">这里</a>有一篇关于它的非常好的文章。</p><h4 id="字体压缩"><a href="#字体压缩" class="headerlink" title="字体压缩"></a>字体压缩</h4><p>字体是形状和路径描述的集合，用于创建字母。每个字母都是不同的，但幸运的是他们有很多共同点，所以我们可以稍微压缩一下。</p><p>由于 EOT 和 TTF 格式默认未压缩，请确保你的服务器配置了使用 GZIP。</p><p>WOFF 内置了压缩功能。请在你的服务器上使用最佳压缩设置。</p><p>WOFF2具有自定义预处理。<a href="http://www.w3.org/TR/WOFF20ER/" target="_blank" rel="external">阅读更多</a></p><h4 id="限制字符"><a href="#限制字符" class="headerlink" title="限制字符"></a>限制字符</h4><p>你是否只使用英文？请记住：不需要在字体中添加阿拉伯文或希腊文字母。你也可以使用 unicode 代码点。这使得浏览器可以将较大的 Unicode 字体拆分成较小的子集。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range" target="_blank" rel="external">阅读更多</a></p><h4 id="字体加载策略"><a href="#字体加载策略" class="headerlink" title="字体加载策略"></a>字体加载策略</h4><p>加载字体会阻塞页面渲染，因为浏览器需要使用其中的所有字体来构建 DOM。字体加载策略可以防止加载延迟。字体显示（fonts-display）是策略之一，在 CSS 属性中。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display" target="_blank" rel="external">阅读更多</a></p><h3 id="优化-JavaScript"><a href="#优化-JavaScript" class="headerlink" title="优化 JavaScript"></a>优化 JavaScript</h3><h4 id="不必要的依赖"><a href="#不必要的依赖" class="headerlink" title="不必要的依赖"></a>不必要的依赖</h4><p>现在，随着 ES6 越来越重要，我们广泛使用 webpack 和 gulp。在使用库，务必记住，你并不总是需要整个库。如果你不需要引入整个 lodash，只需引入一个函数。</p><p><code>import _ from &#39;lodash &#39;</code> —— 会把整个 lodash 库加到包中</p><p><code>import {map} from &#39;lodash&#39;</code> —— 也会把整个 lodash 库加到包中，你可以使用 <a href="https://github.com/lodash/lodash-webpack-plugin" target="_blank" rel="external">lodash-webpack-plugin</a>、<a href="https://github.com/lodash/babel-plugin-lodash" target="_blank" rel="external">babel-plugin-lodash</a> 这些插件</p><p><code>import map from &#39;lodash/map&#39;</code> —— 只会把 map 模块加入包中</p><p>仔细查看框架中的 ES6 函数和你自己的函数。你不需要为每个功能都引入一个新库。要检查你的包是如何构建的，请使用下面链接中的工具。</p><ul><li><a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="external">Webpack bundle analyzer</a></li><li><a href="https://github.com/samccone/bundle-buddy" target="_blank" rel="external">Bundle buddy</a></li></ul><h4 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h4><p>当然有更多的工具来衡量你网站的性能。</p><p>其中一个是 tools.pingdom.com，它或多或少地为你提供与 Audits + Network 选项卡相似的信息。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f52dd8831a13c?w=800&amp;h=519&amp;f=png&amp;s=102715" alt=""></p><p>我同时也推荐安装 PageSpeed Insights 这个 Chrome 扩展。它直接向你显示哪个图片需要更小点。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文试图向你展示如何通过减少资源的大小来使你的网站更轻盈。这只是提高网站性能的第一步。毕竟，这个领域十分广泛，并随着现代前端的发展而变化。请关注这个话题和你的竞争对手。尽量提前一步。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自：&lt;a href=&quot;https://blog.pragmatists.com/how-to-debug-front-end-optimising-network-assets-c0bfcad29b40&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to debug front-end: optimising network assets&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/24/162f52dcf8a1ac50?w=800&amp;amp;h=533&amp;amp;f=jpeg&amp;amp;s=67696&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;网络性能可以决定 web app 的成败。最初 app 很新很小时，很少有开发者会持续关注 app 到底用了多长时间发送了多少兆字节给用户。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Deploy != Release（第一部分）：部署与发布的区别，以及为什么这很重要</title>
    <link href="http://stormluke.me/deploy-not-equal-release-part-one/"/>
    <id>http://stormluke.me/deploy-not-equal-release-part-one/</id>
    <published>2018-04-19T02:00:00.000Z</published>
    <updated>2018-04-21T07:31:31.985Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://blog.turbinelabs.io/deploy-not-equal-release-part-one-4724bc1e726b" target="_blank" rel="external">Deploy != Release (Part 1): The difference between deploy and release and why it matters.</a></p></blockquote><p>问：「最新版本部署了吗？」</p><p>答：「我在生产环境里部署了 gif 动图支持。」</p><p>问：「就是说 gif 动图支持已经发布啦？」</p><p>答：「Gif 动图的发布版本已经部署了。」</p><p>问：「……」</p><a id="more"></a><p>我曾在很多公司工作过，在这些公司中「部署（deploy，动词）」、「部署物（deployment，名词）」、「上线（ship）」和「发布（release）」都是随意地使用，甚至可以互换使用。作为一个行业，我们在规范使用这些术语方面做得还不够，尽管我们在过去的十多年里已经从根本上改进了运维实践和工具。在 <a href="https://turbinelabs.io" target="_blank" rel="external">Turbine Labs</a> 中，我们使用了「上线」、「部署」、「发布」和「回滚（rollback）」的精确定义，并花了大量的时间来思考当你把「发布」作为上线过程的一个独立阶段时，世界是什么样子的。在这篇文章的第一部分，我会分享这些术语的定义，描述一些常见的「部署 == 发布」的实践，并且解释为什么这样做的抗风险性很差。在第二部分，我会描述当「部署」和「发布」被视为软件上线周期的不同阶段时的一些非常强大的风险缓释技术。</p><h3 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h3><p><strong>上线</strong>指你的团队从源码管理库中获取服务代码某个<strong>版本</strong>的快照，并用它处理线上流量的过程。我认为整个上线过程由四个不同的专门的小流程组成：构建（build）、测试、部署和发布。得益于云基础架构、容器、编配框架的技术进步以及流程改进，如 <a href="https://12factor.net/" target="_blank" rel="external">twelve-factor</a>、<a href="https://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="external">持续集成</a>和<a href="https://martinfowler.com/bliki/ContinuousDelivery.html" target="_blank" rel="external">持续交付</a>，执行前三个流程（构建，测试和部署）从未如此简单。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><strong>部署</strong>指你的团队在生产环境的基础设置中安装新版本服务代码的过程。当我们说新版软件被<strong>部署</strong>时，我们的意思是它正在生产环境的基础设施的某个地方运行。基础设置可以是 AWS 上的一个新启动的 EC2 实例，也可以是在数据中心的 Kubernetes 集群中的某个容器中运行的一个 Docker 容器。你软件已成功启动，通过了健康检查，并且已准备好（像你希望的那样！）来处理线上流量，但实际上可能没有收到任何流量。这是一个重要的观点，所以我会用 Medium 超棒的大引用格式来重复一遍：</p><blockquote><p><strong>部署不需要向用户提供新版本的服务。</strong></p></blockquote><p>根据这个定义，<strong>部署可以是几乎零风险的活动</strong>。诚然，在部署过程中可能会出现很多问题，但是如果一个容器静默应对崩溃，并且没有用户获得 500 状态响应，那问题是否真的算是<strong>发生</strong>了？</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dbe521d8ebc26?w=800&amp;h=661&amp;f=png&amp;s=119314" alt=""></p><p>部署了新的版本（紫色），但未发布。已知良好的版本（绿色）仍对线上请求做出响应。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>当我们说服务版本<strong>发布</strong>时，我们的意思是它负责服务线上流量。在动词形式中，<strong>发布</strong>是将线上流量转移到新版本的过程。鉴于这个定义，与上线新的二进制文件有关的所有风险 —— 服务中断、愤怒的用户、<a href="https://www.theregister.co.uk/2017/02/28/aws_is_awol_as_s3_goes_haywire" target="_blank" rel="external">The Register</a> 中的刻薄内容 —— 与新软件的发布而不是部署有关。在一些公司，我听说这个上线阶段被称为<strong>首次发布（rollout）</strong>。这篇文章中我们将依旧使用<strong>发布</strong>来表述。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dbe524a6f1d88?w=800&amp;h=661&amp;f=png&amp;s=111509" alt=""></p><p>新版本发布，响应线上请求。</p><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>迟早，很可能不久之后，你的团队就会上线一些功能有问题的服务。回滚（和它危险的、不可预测的、压力山大的兄弟 —— 前滚 roll-forward）指将线上服务退回到某个已知状态的过程，通常是重新发布最近的版本。将回滚视为另一个部署和发布流程有助于理解，唯一的区别是：</p><ul><li>你正在上线的版本的特征在生产环境中已知</li><li>你正在时间压力下执行部署和发布过程</li><li>你可能正向一个不同的环境中发布 —— 在上次失败的发布之后某些东西可能改变了（或被改变了）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dbe52388179a9?w=800&amp;h=239&amp;f=png&amp;s=87669" alt=""></p><p>一个发布后回滚的例子。</p><p>现在我们已经就上线、部署、发布和回滚的定义达成了共识，让我们来看看一些常见的部署和发布实践。</p><h3 id="原地发布（即部署-发布）"><a href="#原地发布（即部署-发布）" class="headerlink" title="原地发布（即部署 == 发布）"></a>原地发布（即部署 == 发布）</h3><p>当你的团队的上线流程涉及将新版本的软件推送到运行旧版本的服务器上并重启服务的流程时，你就是在原地发布。根据我们上面的定义，部署和发布是同时发生的：一旦新软件开始运行（部署），它就会负载旧版本的所有线上流量（发布）。此时，成功的部署就是成功的发布，失败的部署则会带来部分或整体的服务中断，一群愤怒的用户，可能还有一个气急败坏的经理。</p><p>在我们所讨论的部署/发布过程中，原地发布是唯一的将<strong>部署风险</strong>暴露给用户的方式。如果你刚刚部署的新版本无法启动 —— 可能是因为无法找到新增的环境变量而抛出异常，也可能是有一个库依赖不满足，或者只是你今天出门时没看黄历 —— 此时并没有老版本的服务实例来负载用户请求。你的服务此时至少是部分不可用的。</p><p>此外，如果有用户相关的问题或更微妙的运维问题 —— 我把它叫做<strong>发布风险</strong> —— 原地发布会将线上请求暴露给你已发布的所有实例。</p><p>在集群环境中，您可能会首先原地发布一个实例。这种做法通常称为<strong>金丝雀</strong>发布，它可以减轻一些风险 —— 面临部署风险和发布风险的流量的百分比为：新服务实例的个数除以集群中的实例总数。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dbe523a120545?w=800&amp;h=661&amp;f=png&amp;s=109442" alt=""></p><p>一个金丝雀发布：集群中的一个主机运行新版本</p><p>最后，回滚错误的原地部署可能会有问题。即使你回滚（重新发布）到旧版本，也无法保证可以恢复到以前的系统状态。与当前错误的部署一样，你的回滚部署在启动时也可能会失败。</p><p>尽管其风险管理相对较差 —— 即便使用金丝雀，一些用户请求也会面临部署风险 —— 原地部署仍旧是业务中常见的方式。我认为这类的经验会导致不幸地混用「部署」和「发布」这两个术语。</p><h3 id="别绝望"><a href="#别绝望" class="headerlink" title="别绝望"></a>别绝望</h3><p>我们可以做得更好！在<a href="https://medium.com/turbine-labs/deploy-not-equal-release-part-two-acbfe402a91c" target="_blank" rel="external">这篇文章的第二部分</a>，我们会讨论分离部署和发布的策略，以及可以在复杂的发布系统上构建的一些强大工作流。</p><p><strong>我是 <a href="https://turbinelabs.io" target="_blank" rel="external"><em>Turbine Labs</em></a> 的一名工程师，我们正在构建 <a href="https://docs.turbinelabs.io/reference/#introduction" target="_blank" rel="external"><em>Houston</em></a>，这个服务可以轻松构建和监控复杂的实时发布工作流程。如果你想轻松地上线更多服务，你绝对应该<a href="https://turbinelabs.io/contact" target="_blank" rel="external">联系我们</a>。我们很乐意与你交谈。</strong></p><p><strong>感谢 Glen Sanford、Mark McBride、Emily Pinkerton、Brook Shelley、Sara 和 Jenn Gillespie 阅读此文的草稿。</strong></p><p>感谢 <a href="https://medium.com/@9len?source=post_page" target="_blank" rel="external">Glen D Sanford</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自：&lt;a href=&quot;https://blog.turbinelabs.io/deploy-not-equal-release-part-one-4724bc1e726b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deploy != Release (Part 1): The difference between deploy and release and why it matters.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问：「最新版本部署了吗？」&lt;/p&gt;
&lt;p&gt;答：「我在生产环境里部署了 gif 动图支持。」&lt;/p&gt;
&lt;p&gt;问：「就是说 gif 动图支持已经发布啦？」&lt;/p&gt;
&lt;p&gt;答：「Gif 动图的发布版本已经部署了。」&lt;/p&gt;
&lt;p&gt;问：「……」&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 如何工作：渲染引擎和性能优化技巧</title>
    <link href="http://stormluke.me/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance/"/>
    <id>http://stormluke.me/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance/</id>
    <published>2018-04-17T02:00:00.000Z</published>
    <updated>2018-04-21T07:31:45.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://blog.sessionstack.com/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance-7b95553baeda" target="_blank" rel="external">How JavaScript works: the rendering engine and tips to optimize its performance</a></p></blockquote><p>这是探索 JavaScript 及其构建组件专题系列的第 11 篇。在识别和描述核心元素的过程中，我们分享了在构建 <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-rendering-engine-intro" target="_blank" rel="external">SessionStack</a> 时使用的一些经验法则。SessionStack 是一个需要鲁棒且高性能的 JavaScript 应用程序，它帮助用户实时查看和重现它们 Web 应用程序的缺陷。</p><p>当构建 Web 应用程序时，你不只是编写独立运行的 JavaScript 代码片段。你编写的 JavaScript 需要与环境进行交互。理解环境是如何工作的以及它是由什么组成的，你就能够构建更好的应用程序，并且能更好地处理应用程序发布后才会显现的潜在问题。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c7da5b19bd249?w=800&amp;h=410&amp;f=png&amp;s=37877" alt=""></p><p>那么，让我们看看浏览器的主要组件有哪些：</p><ul><li><strong>用户界面</strong>：包括地址栏、后退和前进按钮、书签菜单等。实际上，它包括了浏览器中显示的绝大部分，除了你看到的网页本身的那个窗口。</li><li><strong>浏览器引擎</strong>：它处理用户界面和渲染引擎之间的交互。</li><li><strong>渲染引擎</strong>：它负责显示网页。渲染引擎解析 HTML 和 CSS，并在屏幕上显示解析的内容。</li><li><strong>网络层</strong>：诸如 XHR 请求之类的网络调用，通过对不同平台的不同的实现来完成，这些实现位于一个平台无关的接口之后。我们在本系列的<a href="https://blog.sessionstack.com/how-modern-web-browsers-accelerate-performance-the-networking-layer-f6efaf7bfcf4" target="_blank" rel="external">上一篇文章</a>中更详细地讨论了网络层。</li><li><strong>UI 后端</strong>：它用于绘制核心组件（widget），例如复选框和窗口。这个后端暴露了一个平台无关的通用接口。它使用下层的操作系统提供的 UI 方法。</li><li><strong>JavaScript 引擎</strong>：我们在<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="external">上一篇文章</a>中详细介绍了这一主题。基本上，这是 JavaScript 执行的地方。</li><li><strong>数据持久化层</strong>：你的应用可能需要在本地存储所有数据。其支持的存储机制包括 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="external">localStorage</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="external">indexDB</a>、<a href="https://en.wikipedia.org/wiki/Web_SQL_Database" target="_blank" rel="external">WebSQL</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystem" target="_blank" rel="external">FileSystem</a>。</li></ul><p>在这篇文章中，我们将关注渲染引擎，因为它负责处理 HTML 和 CSS 的解析和可视化，这是大多数 JavaScript 应用程序不断与之交互的地方。</p><h4 id="渲染引擎概述"><a href="#渲染引擎概述" class="headerlink" title="渲染引擎概述"></a>渲染引擎概述</h4><p>渲染引擎的主要职责是在浏览器屏幕上显示所请求的页面。</p><p>渲染引擎可以显示 HTML / XML 文档和图像。如果你使用其他插件，它还可以显示不同类型的文档，例如 PDF。</p><h4 id="不同的渲染引擎"><a href="#不同的渲染引擎" class="headerlink" title="不同的渲染引擎"></a>不同的渲染引擎</h4><p>与 JavaScript 引擎类似，不同的浏览器也使用不同的渲染引擎。常见的有这些：</p><ul><li><strong>Gecko</strong> — Firefox</li><li><strong>WebKit</strong> — Safari</li><li><strong>Blink</strong> — Chrome，Opera (版本 15 之后)</li></ul><h4 id="渲染的过程"><a href="#渲染的过程" class="headerlink" title="渲染的过程"></a>渲染的过程</h4><p>渲染引擎从网络层接收所请求文档的内容。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c7fccbca93904?w=800&amp;h=203&amp;f=png&amp;s=31359" alt=""></p><h4 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h4><p>渲染引擎的第一步是解析 HTML 文档并将解析出的元素转换为 <strong>DOM 树</strong> 中实际的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="external">DOM</a> 节点。</p><p>假设你有以下文字输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"theme.css"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> Hello, <span class="tag">&lt;<span class="name">span</span>&gt;</span> friend! <span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"smiley.gif"</span> <span class="attr">alt</span>=<span class="string">"Smiley face"</span> <span class="attr">height</span>=<span class="string">"42"</span> <span class="attr">width</span>=<span class="string">"42"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>这个 HTML 的 DOM 树如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c802ddf2b8a56?w=732&amp;h=665&amp;f=png&amp;s=45298" alt=""></p><p>基本上，每个元素都作为它所包含元素的父节点，这个结构是递归的。</p><h4 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a>构建 CSSOM 树</h4><p>CSSOM 指 <strong>CSS 对象模型</strong>。当浏览器构建页面的 DOM 时，它在 <code>head</code> 中遇到了一个引用外部 <code>theme.css</code> CSS 样式表的 <code>link</code> 标签。浏览器预计到它可能需要该资源来呈现页面，所以它立即发出请求。让我们假设 <code>theme.css</code> 文件包含以下内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123; </div><div class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123; </div><div class="line">  <span class="attribute">font-weight</span>: bold; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">span</span> &#123; </div><div class="line">  <span class="attribute">color</span>: red; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; </div><div class="line">  <span class="attribute">display</span>: none; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> &#123; </div><div class="line">  <span class="attribute">float</span>: right; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与 HTML 一样，引擎需要将 CSS 转换为浏览器可以使用的东西 —— CSSOM。以下是 CSSOM 树的样子：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c8111e16c31a2?w=800&amp;h=419&amp;f=png&amp;s=64132" alt=""></p><p>你知道为什么 CSSOM 是树型结构吗？当计算页面上对象的最终样式集时，浏览器以适用于该节点的最一般规则开始（例如，如果它是 body 元素的子元素，则应用 body 的所有样式），然后递归地细化，通过应用更具体的规则来计算样式。</p><p>让我们来看看具体的例子。包含在 <code>body</code> 元素内的 <code>span</code> 标签中的任何文本的字体大小均为 16 像素，并且为红色。这些样式是从 <code>body</code> 元素继承而来的。 如果一个 <code>span</code> 元素是一个 <code>p</code> 元素的子元素，那么它的内容就不会被显示，因为它被应用了更具体的样式（<code>display: none</code>）。</p><p>另外请注意，上面的树不是完整的 CSSOM 树，只显示了我们决定在样式表中重写的样式。每个浏览器都提供了一组默认的样式，也称为 <strong>「用户代理样式」</strong>——这是我们在未明确指定任何样式时看到的样式。我们的样式会覆盖这些默认值。</p><h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>HTML 中的视图指令与 CSSOM 树中的样式数据结合在一起用来创建<strong>渲染树</strong>。</p><p>你可能会问什么是渲染树。渲染树是一颗由可视化元素以它们在屏幕上显示的顺序而构成的树型结构。它是 HTML 和相应的 CSS 的可视化表示。此树的目的是为了以正确的顺序绘制内容。</p><p>渲染树中的节点被称为 Webkit 中的渲染器或渲染对象。</p><p>这就是上述 DOM 和 CSSOM 树的渲染器树的样子：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/15/162c83c63ff4bd29?w=800&amp;h=455&amp;f=png&amp;s=49373" alt=""></p><p>为了构建渲染树，浏览器大致做了如下工作：</p><ul><li>从 DOM 树的根开始，浏览器遍历每个可见节点。某些节点是不可见的（例如 script、meta 等），并且由于它们不需要渲染而被忽略。一些通过 CSS 隐藏的节点也从渲染树中省略。例如 span 节点 —— 在上面的例子中，它并不存在于渲染树中，因为我们明确地其上设置了 <code>display: none</code> 属性。</li><li>对于每个可见节点，浏览器找到适当的 CSSOM 规则并应用它们。</li><li>浏览器输出带有内容及其计算出的样式的可见节点</li></ul><p>你可以在这里查看 RenderObject 的源代码（在 WebKit 中）：<a href="https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h" target="_blank" rel="external">https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h</a></p><p>我们来看看这个类的一些核心内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> :</span> <span class="keyword">public</span> CachedImageClient &#123;</div><div class="line">  <span class="comment">// Repaint the entire object.  Called when, e.g., the color of a border changes, or when a border</span></div><div class="line">  <span class="comment">// style changes.</span></div><div class="line">  </div><div class="line">  <span class="function">Node* <span class="title">node</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; ... &#125;</div><div class="line">  </div><div class="line">  RenderStyle* style;  <span class="comment">// the computed style</span></div><div class="line">  <span class="function"><span class="keyword">const</span> RenderStyle&amp; <span class="title">style</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  </div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每个渲染器代表一个矩形区域，通常对应于一个节点的 CSS 盒模型。它包含几何信息，例如宽度、高度和位置。</p><h4 id="渲染树的布局"><a href="#渲染树的布局" class="headerlink" title="渲染树的布局"></a>渲染树的布局</h4><p>当渲染器被创建并添加到树中时，它并没有位置和大小。计算这些值的过程称为布局。</p><p>HTML 使用基于流的布局模型，这意味着大部分时间内它可以在一次遍历中（single pass）计算出布局。坐标系是相对于根渲染器的，使用左上原点坐标。</p><p>布局是一个递归过程 —— 它从根渲染器开始，对应于 HTML 文档的 <code>&lt;html&gt;</code> 元素，通过部分或整个渲染器的层次结构递归地为每个需要布局的渲染器计算布局信息。</p><p>根渲染器的位置是 <code>0,0</code>，并且其尺寸为浏览器窗口（也称为视口）的可见部分的尺寸。</p><p>开始布局过程意味着给出每个节点它应该出现在屏幕上的确切坐标。</p><h4 id="绘制渲染树"><a href="#绘制渲染树" class="headerlink" title="绘制渲染树"></a>绘制渲染树</h4><p>在这个阶段，浏览器遍历渲染器树，调用渲染器的 <code>paint()</code> 方法在屏幕上显示内容。</p><p>绘图可以是全局的或增量式的（与布局类似）：</p><ul><li><strong>全局</strong> —— 整棵树被重画</li><li><strong>增量式</strong> —— 只有一些渲染器以不影响整个树的方式进行变更。渲染器在屏幕上标记其矩形区域无效，这会导致操作系统将其视为需要重绘并生成 <code>paint</code> 事件的区域。操作系统通过将几个区域合并为一个区域的智能方式来完成绘图。</li></ul><p>一般来说，了解绘图是一个渐进的过程是很重要的。为了更好的用户体验，渲染引擎会尝试尽快在屏幕上显示内容。它不会等到所有的 HTML 被分析完毕才开始构建和布置渲染树。一小部分内容先被解析并显示，同时一边从网络获取剩下的内容一边渐进地渲染。</p><h4 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h4><p>当解析器到达 <code>&lt;script&gt;</code> 标签时，脚本将被立即解析并执行。文档解析将会被暂停，直到脚本执行完毕。这意味着该过程是<strong>同步</strong>的。</p><p>如果脚本是外部的，那么它首先必须从网络获取（也是同步的）。所有解析都会停止，直到网络请求完成。</p><p>HTML5 添加了一个选项，可以将脚本标记为异步，此时脚本被其他线程解析和执行。</p><h4 id="优化渲染性能"><a href="#优化渲染性能" class="headerlink" title="优化渲染性能"></a>优化渲染性能</h4><p>如果你想优化你的应用，那么你需要关注五个主要方面。这些是您可以控制的地方：</p><ol><li><strong>JavaScript</strong> —— 在之前的文章中，我们介绍了关于编写高性能代码的主题，这些代码不会阻塞 UI，并且内存效率高等等。当涉及渲染时，我们需要考虑 JavaScript 代码与页面上 DOM 元素交互的方式。JavaScript 可以在 UI 中产生大量的更新，尤其是在 SPA 中。</li><li><strong>样式计算</strong> —— 这是基于匹配选择器确定哪个 CSS 规则适用于哪个元素的过程。一旦定义了规则，就会应用这些规则，并计算出每个元素的最终样式。</li><li><strong>布局</strong> —— 一旦浏览器知道哪些规则适用于元素，就可以开始计算后者占用的空间以及它在浏览器屏幕上的位置。Web 的布局模型定义了一个元素可以影响其他元素。例如，<code>&lt;body&gt;</code> 的宽度会影响子元素的宽度等等。这一切都意味着布局过程是计算密集型的。该绘图是在多个图层完成的。</li><li><strong>绘图</strong> —— 这里开始填充实际的像素。该过程包括绘制文本、颜色、图像、边框、阴影等 —— 每个元素的每个视觉部分。</li><li><strong>合成</strong> —— 由于页面部件被划分为多层，因此需要按照正确的顺序将其绘制到屏幕上，以便正确地渲染页面。这非常重要，特别是对于重叠元素来说。</li></ol><h4 id="优化你的-JavaScript"><a href="#优化你的-JavaScript" class="headerlink" title="优化你的 JavaScript"></a>优化你的 JavaScript</h4><p>JavaScript 经常触发浏览器中的视觉变化，构建 SPA 时更是如此。</p><p>以下是关于可以优化 JavaScript 哪些部分来改善渲染性能的一些小提示：</p><ul><li>避免使用 <code>setTimeout</code> 或 <code>setInterval</code> 进行视图更新。这些将在帧中某个不确定的时间点上调用 <code>callback</code>，可能在最后。我们想要做的是在帧开始时触发视觉变化而不是错过它。</li><li>将长时间运行的 JavaScript 计算任务移到 Web Workers 上，像我们之前<a href="https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a?source=---------3----------------" target="_blank" rel="external">讨论过的</a>那样</li><li>使用微任务在多个帧中变更 DOM。这是为了处理在 Web Worker 中的任务需要访问 DOM，而 Web Worker 又不允许访问 DOM 的情况。就是说你可以将一个大任务分解为小任务，并根据任务的性质在 <code>requestAnimationFrame</code>、<code>setTimeout</code> 或 <code>setInterval</code> 中运行它们。</li></ul><h4 id="优化你的-CSS"><a href="#优化你的-CSS" class="headerlink" title="优化你的 CSS"></a>优化你的 CSS</h4><p>通过添加和删除元素、更改属性等来修改 DOM 会导致浏览器重新计算元素样式，并且在很多情况下还会重新布局整个页面或至少其中的一部分。</p><p>要优化渲染性能，请考虑以下方法：</p><ul><li>减少选择器的复杂性。相对于构建样式本身的工作，复杂的选择器可能会让计算元素样式所需的时间增加 50％。</li><li>减少必须计算样式的元素的数量。本质上，直接对几个元素进行样式更改，而不是使整个页面无效。</li></ul><h4 id="优化布局"><a href="#优化布局" class="headerlink" title="优化布局"></a>优化布局</h4><p>布局的重新计算会对浏览器造成很大压力。请考虑下面的优化:</p><ul><li>尽可能减少布局的数量。当你更改样式时，浏览器将检查是否需要重新计算布局。对属性的更改，如宽度、高度、左、上和其他与几何有关的属性，都需要重新布局。所以，尽量避免改变它们。</li><li>尽量使用 <code>flexbox</code> 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li><li>避免强制同步布局。需要注意的是，在 JavaScript 运行时，前一帧中的所有旧布局值都是已知的并且可以查询。如果你查询 <code>box.offsetHeight</code> 是没问题的。 但是，如果你在查询元素之前更改了元素的样式（例如，动态向元素添加一些 CSS 类），浏览器必须先应用样式更改并执行布局过程。这可能非常耗时且耗费资源，因此请尽可能避免。</li></ul><p><strong>优化绘图</strong></p><p>这通常是所有任务中运行时间最长的，因此尽可能避免这种情况非常重要。 以下是我们可以做的事情：</p><ul><li>除了变换（transform）和透明度之外，改变其他任何属性都会触发重新绘图，请谨慎使用。</li><li>如果触发了布局，那也会触发绘图，因为更改布局会导致元素的视觉效果也改变。</li><li>通过图层提升和动画编排来减少重绘区域。</li></ul><p>渲染是 <a href="https://www.sessionstack.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_content=js-series-rendering-engine-outro" target="_blank" rel="external">SessionStack</a> 运行的重点之一。当用户浏览你的 web 应用遇到问题时，SessionStack 必须将这些遇到的问题重建成一个视频。为了做到这点，SessionStack 仅利用我们的库收集到数据：用户事件、DOM 更改、网络请求、异常和调试消息等。我们的播放器经过高度优化，能够按顺序正确呈现和使用所有收集到的数据，从视觉和技术两方面为你提供用户在浏览器中发生的一切的像素级完美模拟。</p><p>如果你想试试看，这里可以免费<a href="https://www.sessionstack.com/signup/" target="_blank" rel="external">尝试 SessionStack</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d25b57ddc5b96?w=800&amp;h=416&amp;f=png&amp;s=96734" alt=""></p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ul><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model" target="_blank" rel="external">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations" target="_blank" rel="external">https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations</a></li><li><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_parsing_algorithm" target="_blank" rel="external">https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_parsing_algorithm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自：&lt;a href=&quot;https://blog.sessionstack.com/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance-7b95553baeda&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How JavaScript works: the rendering engine and tips to optimize its performance&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是探索 JavaScript 及其构建组件专题系列的第 11 篇。在识别和描述核心元素的过程中，我们分享了在构建 &lt;a href=&quot;https://www.sessionstack.com/?utm_source=medium&amp;amp;utm_medium=blog&amp;amp;utm_content=js-series-rendering-engine-intro&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SessionStack&lt;/a&gt; 时使用的一些经验法则。SessionStack 是一个需要鲁棒且高性能的 JavaScript 应用程序，它帮助用户实时查看和重现它们 Web 应用程序的缺陷。&lt;/p&gt;
&lt;p&gt;当构建 Web 应用程序时，你不只是编写独立运行的 JavaScript 代码片段。你编写的 JavaScript 需要与环境进行交互。理解环境是如何工作的以及它是由什么组成的，你就能够构建更好的应用程序，并且能更好地处理应用程序发布后才会显现的潜在问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas 数据类型概览</title>
    <link href="http://stormluke.me/pandas-dtypes/"/>
    <id>http://stormluke.me/pandas-dtypes/</id>
    <published>2018-04-10T02:00:00.000Z</published>
    <updated>2018-04-21T07:34:21.154Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="http://pbpython.com/pandas_dtypes.html" target="_blank" rel="external">Overview of Pandas Data Types</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/10/162adb65a757dd0a?w=700&amp;h=526&amp;f=png&amp;s=152073" alt="article header image"></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在进行数据分析时，确保使用正确的数据类型非常重要，否则可能会得到意想不到的结果或错误。对 Pandas 而言，它会在很多情况下正确地作出数据类型推断，你可以继续进行分析工作，而无需深入思考该主题。</p><p>尽管 Pandas 工作得很好，但在数据分析过程中的某个时刻，你可能需要将数据从一种类型显式转换为另一种类型。本文将讨论 Pandas 的基本数据类型（即 <code>dtypes</code>），它们如何映射到 python 和 numpy 数据类型，以及从一种 Pandas 类型转换为另一种类型的几个方式。</p><h2 id="Pandas-的数据类型"><a href="#Pandas-的数据类型" class="headerlink" title="Pandas 的数据类型"></a>Pandas 的数据类型</h2><p>数据类型本质上是编程语言用来理解如何存储和操作数据的内部结构。例如，一个程序需要理解你可以将两个数字加起来，比如 5 + 10 得到 15。或者，如果是两个字符串，比如「cat」和「hat」，你可以将它们连接（加）起来得到「cathat」。</p><p>有关 Pandas 数据类型的一个可能令人困惑的地方是，Pandas、Python 和 numpy 的数据类型之间有一些重叠。下表总结了关键点：</p><p>Pandas <code>dtype</code> 映射：</p><table><thead><tr><th>Pandas dtype</th><th>Python 类型</th><th>NumPy 类型</th><th>用途</th></tr></thead><tbody><tr><td>object</td><td>str</td><td>string<em>, unicode</em></td><td>文本</td></tr><tr><td>int64</td><td>int</td><td>int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64</td><td>整数</td></tr><tr><td>float64</td><td>float</td><td>float_, float16, float32, float64</td><td>浮点数</td></tr><tr><td>bool</td><td>bool</td><td>bool_</td><td>布尔值</td></tr><tr><td>datetime64</td><td>NA</td><td>NA</td><td>日期时间</td></tr><tr><td>timedelta[ns]</td><td>NA</td><td>NA</td><td>时间差</td></tr><tr><td>category</td><td>NA</td><td>NA</td><td>有限长度的文本值列表</td></tr></tbody></table><p>大多数情况下，你不必担心是否应该明确地将熊猫类型强制转换为对应的 NumPy 类型。一般来说使用 Pandas 的默认 <code>int64</code> 和 <code>float64</code> 就可以。我列出此表的唯一原因是，有时你可能会在代码行间或自己的分析过程中看到 Numpy 的类型。</p><p>对于本文，我将重点关注以下 Pandas 类型：</p><ul><li><code>object</code></li><li><code>int64</code></li><li><code>float64</code></li><li><code>datetime64</code></li><li><code>bool</code></li></ul><p>如果你有兴趣，我会再写一篇文章来专门介绍 <code>category</code> 和 <code>timedelta</code> 类型。不过本文中概述的基本方法也适用于这些类型。</p><h2 id="我们为什么关心类型？"><a href="#我们为什么关心类型？" class="headerlink" title="我们为什么关心类型？"></a>我们为什么关心类型？</h2><p>数据类型是在你遇到错误或意外结果之前并不会关心的事情之一。不过当你将新数据加载到 Pandas 进行进一步分析时，这也是你应该检查的第一件事情。</p><p>我将使用一个非常简单的 <a href="https://github.com/chris1610/pbpython/blob/master/data/sales_data_types.csv" target="_blank" rel="external">CSV文件</a> 来说明在 Pandas 中可能会遇到的一些常见的由数据类型导致的错误。另外，在 github 上也一个示例 <a href="https://github.com/chris1610/pbpython/blob/master/notebooks/Pandas_Data_Types.ipynb" target="_blank" rel="external">notbook</a>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">"sales_data_types.csv"</span>)</div></pre></td></tr></table></figure><table><thead><tr><th></th><th>Customer Number</th><th>Customer Name</th><th>2016</th><th>2017</th><th>Percent Growth</th><th>Jan Units</th><th>Month</th><th>Day</th><th>Year</th><th>Active</th></tr></thead><tbody><tr><td>0</td><td>10002.0</td><td>Quest Industries</td><td>$125,000.00</td><td>$162500.00</td><td>30.00%</td><td>500</td><td>1</td><td>10</td><td>2015</td><td>Y</td></tr><tr><td>1</td><td>552278.0</td><td>Smith Plumbing</td><td>$920,000.00</td><td>$101,2000.00</td><td>10.00%</td><td>700</td><td>6</td><td>15</td><td>2014</td><td>Y</td></tr><tr><td>2</td><td>23477.0</td><td><span class="caps">ACME</span> Industrial</td><td>$50,000.00</td><td>$62500.00</td><td>25.00%</td><td>125</td><td>3</td><td>29</td><td>2016</td><td>Y</td></tr><tr><td>3</td><td>24900.0</td><td>Brekke <span class="caps">LTD</span></td><td>$350,000.00</td><td>$490000.00</td><td>4.00%</td><td>75</td><td>10</td><td>27</td><td>2015</td><td>Y</td></tr><tr><td>4</td><td>651029.0</td><td>Harbor Co</td><td>$15,000.00</td><td>$12750.00</td><td>-15.00%</td><td>Closed</td><td>2</td><td>2</td><td>2014</td><td>N</td></tr></tbody></table><p>乍一看，数据没什么问题，所以我们可以尝试做一些操作来分析数据。我们来试一下把 2016 和 2017 年的销售额加起来：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>] + df[<span class="string">'2017'</span>]</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>      $<span class="number">125</span>,<span class="number">000.00</span>$<span class="number">162500.00</span></div><div class="line"><span class="number">1</span>    $<span class="number">920</span>,<span class="number">000.00</span>$<span class="number">101</span>,<span class="number">2000.00</span></div><div class="line"><span class="number">2</span>        $<span class="number">50</span>,<span class="number">000.00</span>$<span class="number">62500.00</span></div><div class="line"><span class="number">3</span>      $<span class="number">350</span>,<span class="number">000.00</span>$<span class="number">490000.00</span></div><div class="line"><span class="number">4</span>        $<span class="number">15</span>,<span class="number">000.00</span>$<span class="number">12750.00</span></div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>这看起来就不对了。我们希望将总计加在一起，但 Pandas 只是将这两个值连接在一起创建了一个长字符串。这个问题的一个线索是 <code>dtype：object</code>。<code>object</code> 在 Pandas 代表字符串，所以它执行的是字符串操作而不是数学操作。</p><p>如果我们想查看 dataframe 中的所有数据类型，使用 <code>df.dtypes</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number    float64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>                object</div><div class="line"><span class="number">2017</span>                object</div><div class="line">Percent Growth      object</div><div class="line">Jan Units           object</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active              object</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>此外，<code>df.info（）</code> 函数可以显示更有用的信息。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.info()</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></div><div class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">5</span> entries, <span class="number">0</span> to <span class="number">4</span></div><div class="line">Data columns (total <span class="number">10</span> columns):</div><div class="line">Customer Number    <span class="number">5</span> non-null float64</div><div class="line">Customer Name      <span class="number">5</span> non-null object</div><div class="line"><span class="number">2016</span>               <span class="number">5</span> non-null object</div><div class="line"><span class="number">2017</span>               <span class="number">5</span> non-null object</div><div class="line">Percent Growth     <span class="number">5</span> non-null object</div><div class="line">Jan Units          <span class="number">5</span> non-null object</div><div class="line">Month              <span class="number">5</span> non-null int64</div><div class="line">Day                <span class="number">5</span> non-null int64</div><div class="line">Year               <span class="number">5</span> non-null int64</div><div class="line">Active             <span class="number">5</span> non-null object</div><div class="line">dtypes: float64(<span class="number">1</span>), int64(<span class="number">3</span>), object(<span class="number">6</span>)</div><div class="line">memory usage: <span class="number">480.0</span>+ bytes</div></pre></td></tr></table></figure><p>查看自动分配的数据类型后，有几个问题：</p><ul><li><code>Customer Number</code> 被归为 <code>float64</code> 但它应该是 <code>int64</code></li><li><code>2016</code> 和 <code>2017</code> 这两列被存储为 <code>object</code>，但应该是 <code>float64</code> 或 <code>int64</code> 这样的数值类型</li><li><code>Percent Growth</code> 和 <code>Jan Units</code> 也被存储为 <code>object</code> 而不是数值类型</li><li><code>Month</code>、<code>Day</code> 和 <code>Year</code> 这三列应该被转换为 <code>datetime64</code></li><li><code>Active</code> 列应该是布尔型</li></ul><p>在我们清洗这些数据类型之前，要对这些数据做更多的附加分析是非常困难的。</p><p>为了在 Pandas 中转换数据类型，有三个基本选项：</p><ul><li>使用 <code>astype()</code> 来强制转换到合适的 <code>dtype</code></li><li>创建一个自定义函数来转换数据</li><li>使用 Pandas 的函数，例如 <code>to_numeric()</code> 或 <code>to_datetime()</code></li></ul><h2 id="使用-astype-函数"><a href="#使用-astype-函数" class="headerlink" title="使用 astype() 函数"></a>使用 <code>astype()</code> 函数</h2><p>将 Pandas 数据列转换为不同类型的最简单方法就是用 <code>astype()</code>。例如，要将 <code>Customer Number</code> 转换为整数，我们可以这样调用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Customer Number'</span>].astype(<span class="string">'int'</span>)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>     <span class="number">10002</span></div><div class="line"><span class="number">1</span>    <span class="number">552278</span></div><div class="line"><span class="number">2</span>     <span class="number">23477</span></div><div class="line"><span class="number">3</span>     <span class="number">24900</span></div><div class="line"><span class="number">4</span>    <span class="number">651029</span></div><div class="line">Name: Customer Number, dtype: int64</div></pre></td></tr></table></figure><p>为了真正修改原始 dataframe 中的客户编号（Customer Number），记得把 <code>astype()</code> 函数的返回值重新赋值给 dataframe，因为 <code>astype()</code> 仅返回数据的副本而不原地修改。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">"Customer Number"</span>] = df[<span class="string">'Customer Number'</span>].astype(<span class="string">'int'</span>)</div><div class="line">df.dtypes</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number     int64</div><div class="line">Customer Name      object</div><div class="line"><span class="number">2016</span>               object</div><div class="line"><span class="number">2017</span>               object</div><div class="line">Percent Growth     object</div><div class="line">Jan Units          object</div><div class="line">Month               int64</div><div class="line">Day                 int64</div><div class="line">Year                int64</div><div class="line">Active             object</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>以下是客户编号（Customer Number）为整数的新 dataframe：</p><table><thead><tr><th></th><th>Customer Number</th><th>Customer Name</th><th>2016</th><th>2017</th><th>Percent Growth</th><th>Jan Units</th><th>Month</th><th>Day</th><th>Year</th><th>Active</th></tr></thead><tbody><tr><td>0</td><td>10002</td><td>Quest Industries</td><td>$125,000.00</td><td>$162500.00</td><td>30.00%</td><td>500</td><td>1</td><td>10</td><td>2015</td><td>Y</td></tr><tr><td>1</td><td>552278</td><td>Smith Plumbing</td><td>$920,000.00</td><td>$101,2000.00</td><td>10.00%</td><td>700</td><td>6</td><td>15</td><td>2014</td><td>Y</td></tr><tr><td>2</td><td>23477</td><td>ACME Industrial</td><td>$50,000.00</td><td>$62500.00</td><td>25.00%</td><td>125</td><td>3</td><td>29</td><td>2016</td><td>Y</td></tr><tr><td>3</td><td>24900</td><td>Brekke LTD</td><td>$350,000.00</td><td>$490000.00</td><td>4.00%</td><td>75</td><td>10</td><td>27</td><td>2015</td><td>Y</td></tr><tr><td>4</td><td>651029</td><td>Harbor Co</td><td>$15,000.00</td><td>$12750.00</td><td>-15.00%</td><td>Closed</td><td>2</td><td>2</td><td>2014</td><td>N</td></tr></tbody></table><p>这一切看起来不错，并且似乎很简单。让我们尝试对 <code>2016</code> 列做同样的事情并将其转换为浮点数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>].astype(<span class="string">'float'</span>)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ValueError       Traceback (most recent call last)</div><div class="line">&lt;ipython-input<span class="number">-45</span><span class="number">-999869</span>d577b0&gt; <span class="keyword">in</span> &lt;module&gt;()</div><div class="line">----&gt; 1 df['2016'].astype('float')</div><div class="line"></div><div class="line">[一些错误信息]</div><div class="line"></div><div class="line">ValueError: could <span class="keyword">not</span> convert string to float: <span class="string">'$15,000.00'</span></div></pre></td></tr></table></figure><p>以类似的方式，我们可以尝试将 <code>Jan Units</code> 列转换为整数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Jan Units'</span>].astype(<span class="string">'int'</span>)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ValueError         Traceback (most recent call last)</div><div class="line"></div><div class="line">&lt;ipython-input<span class="number">-44</span><span class="number">-31333711e4</span>a4&gt; <span class="keyword">in</span> &lt;module&gt;()</div><div class="line">----&gt; 1 df['Jan Units'].astype('int')</div><div class="line"></div><div class="line">[一些错误信息]</div><div class="line"></div><div class="line"></div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'Closed'</span></div></pre></td></tr></table></figure><p>这两个都返回 <code>ValueError</code> 异常，这意味着转换不起作用。</p><p>在这两个例子中，数据都包含不能被解释为数字的值。在销售额（2016）列中，数据包括货币符号以及每个值中的逗号。在 <code>Jan Units</code> 列中，最后一个值是 “Closed”，它不是一个数字；所以我们得到了异常。</p><p>到目前为止，<code>astype()</code> 作为工具看起来并不怎么好。我们在 <code>Active</code> 列中再试一次。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Active'</span>].astype(<span class="string">'bool'</span>)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="keyword">True</span></div><div class="line"><span class="number">1</span>    <span class="keyword">True</span></div><div class="line"><span class="number">2</span>    <span class="keyword">True</span></div><div class="line"><span class="number">3</span>    <span class="keyword">True</span></div><div class="line"><span class="number">4</span>    <span class="keyword">True</span></div><div class="line">Name: Active, dtype: bool</div></pre></td></tr></table></figure><p>第一眼，这看起来不错，但经过仔细检查，存在一个大问题。所有的值都被解释为 <code>True</code>，但最后一个客户有一个 <code>N</code> 的活动（Active）标志，所以这并不正确。</p><p>这一节的重点是 <code>astype()</code> 只有在下列情况下才能工作：</p><ul><li>数据是干净的，可以简单地解释为一个数字</li><li>你想要将一个数值转换为一个字符串对象</li></ul><p>如果数据具有非数字字符或它们间不同质（homogeneous），那么 <code>astype()</code> 并不是类型转换的好选择。你需要进行额外的变换才能完成正确的类型转换。</p><h2 id="自定义转换函数"><a href="#自定义转换函数" class="headerlink" title="自定义转换函数"></a>自定义转换函数</h2><p>由于该数据转换稍微复杂一些，因此我们可以构建一个自定义函数，将其应用于每个值并转换为适当的数据类型。</p><p>对于货币转换（这个特定的数据集），下面是一个我们可以使用的简单函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_currency</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Convert the string number value to a float</span></div><div class="line"><span class="string">     - Remove $</span></div><div class="line"><span class="string">     - Remove commas</span></div><div class="line"><span class="string">     - Convert to float type</span></div><div class="line"><span class="string">    """</span></div><div class="line">    new_val = val.replace(<span class="string">','</span>,<span class="string">''</span>).replace(<span class="string">'$'</span>, <span class="string">''</span>)</div><div class="line">    <span class="keyword">return</span> float(new_val)</div></pre></td></tr></table></figure><p>该代码使用python的字符串函数去掉 <code>$</code> 和 <code>,</code>，然后将该值转换为浮点数。在这个特定情况下，我们可以将值转换为整数，但我选择在这种情况下使用浮点数。</p><p>我也怀疑有人会建议我们对货币使用 <code>Decimal</code> 类型。这不是 Pandas 的本地数据类型，所以我故意坚持使用 float 方式。</p><p>另外值得注意的是，该函数将数字转换为 python 的 <code>float</code>，但 Pandas 内部将其转换为 <code>float64</code>。正如前面提到的，我建议你允许 Pandas 在确定合适的时候将其转换为特定的大小 <code>float</code> 或 <code>int</code>。你不需要尝试将其转换为更小或更大的字节大小，除非你真的知道为什么需要那样做。</p><p>现在，我们可以使用 Pandas 的 <code>apply</code> 函数将其应用于 2016 列中的所有值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>].apply(convert_currency)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">125000.0</span></div><div class="line"><span class="number">1</span>    <span class="number">920000.0</span></div><div class="line"><span class="number">2</span>     <span class="number">50000.0</span></div><div class="line"><span class="number">3</span>    <span class="number">350000.0</span></div><div class="line"><span class="number">4</span>     <span class="number">15000.0</span></div><div class="line">Name: <span class="number">2016</span>, dtype: float64</div></pre></td></tr></table></figure><p>成功！所有的值都显示为 <code>float64</code>，我们可以完成所需要的所有数学计算了。</p><p>我确信有经验的读者会问为什么我不使用 lambda 函数？在回答之前，先看下我们可以在一行中使用 <code>lambda</code> 函数完成的操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>].apply(<span class="keyword">lambda</span> x: x.replace(<span class="string">'$'</span>, <span class="string">''</span>).replace(<span class="string">','</span>, <span class="string">''</span>)).astype(<span class="string">'float'</span>)</div></pre></td></tr></table></figure><p>使用 <code>lambda</code>，我们可以将代码简化为一行，这是非常有效的方法。但我对这种方法有三个主要的意见：</p><ul><li>如果你只是在学习 Python / Pandas，或者如果将来会有 Python 新人来维护代码，我认为更长的函数的可读性更好。主要原因是它可以包含注释，也可以分解为若干步骤。lambda 函数对于新手来说更难以掌握。</li><li>其次，如果你打算在多个列上重复使用这个函数，复制长长的 lambda 函数并不方便。</li><li>最后，使用函数可以在使用 <code>read_csv()</code> 时轻松清洗数据。我将在文章结尾处介绍具体的使用方法。</li></ul><p>有些人也可能会争辩说，其他基于 lambda 的方法比自定义函数的性能有所提高。但为了教导新手，我认为函数方法更好。</p><p>以下是使用 <code>convert_currency</code> 函数转换两个销售（2016 / 2017）列中数据的完整示例。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>] = df[<span class="string">'2016'</span>].apply(convert_currency)</div><div class="line">df[<span class="string">'2017'</span>] = df[<span class="string">'2017'</span>].apply(convert_currency)</div><div class="line"></div><div class="line">df.dtypes</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number      int64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>               float64</div><div class="line"><span class="number">2017</span>               float64</div><div class="line">Percent Growth      object</div><div class="line">Jan Units           object</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active              object</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>有关使用 <code>lambda</code> 和函数的另一个例子，我们可以看看修复 <code>Percent Growth</code> 列的过程。</p><p>使用 <code>lambda</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Percent Growth'</span>].apply(<span class="keyword">lambda</span> x: x.replace(<span class="string">'%'</span>, <span class="string">''</span>)).astype(<span class="string">'float'</span>) / <span class="number">100</span></div></pre></td></tr></table></figure><p>用自定义函数做同样的事情：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_percent</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Convert the percentage string to an actual floating point percent</span></div><div class="line"><span class="string">    - Remove %</span></div><div class="line"><span class="string">    - Divide by 100 to make decimal</span></div><div class="line"><span class="string">    """</span></div><div class="line">    new_val = val.replace(<span class="string">'%'</span>, <span class="string">''</span>)</div><div class="line">    <span class="keyword">return</span> float(new_val) / <span class="number">100</span></div><div class="line"></div><div class="line">df[<span class="string">'Percent Growth'</span>].apply(convert_percent)</div></pre></td></tr></table></figure><p>两者返回的值相同：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">0.30</span></div><div class="line"><span class="number">1</span>    <span class="number">0.10</span></div><div class="line"><span class="number">2</span>    <span class="number">0.25</span></div><div class="line"><span class="number">3</span>    <span class="number">0.04</span></div><div class="line"><span class="number">4</span>   <span class="number">-0.15</span></div><div class="line">Name: Percent Growth, dtype: float64</div></pre></td></tr></table></figure><p>我将介绍的最后一个自定义函数是使用 <code>np.where()</code> 将活动（Active）列转换为布尔值。有很多方法来解决这个特定的问题。<code>np.where()</code> 方法对于很多类型的问题都很有用，所以我选择在这里介绍它。</p><p>其基本思想是使用 <code>np.where()</code> 函数将所有 <code>Y</code> 值转换为 <code>True</code>，其他所有值为 <code>False</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">"Active"</span>] = np.where(df[<span class="string">"Active"</span>] == <span class="string">"Y"</span>, <span class="keyword">True</span>, <span class="keyword">False</span>)</div></pre></td></tr></table></figure><p>其结果如下 dataframe：</p><table><thead><tr><th></th><th>Customer Number</th><th>Customer Name</th><th>2016</th><th>2017</th><th>Percent Growth</th><th>Jan Units</th><th>Month</th><th>Day</th><th>Year</th><th>Active</th></tr></thead><tbody><tr><td>0</td><td>10002.0</td><td>Quest Industries</td><td>$125,000.00</td><td>$162500.00</td><td>30.00%</td><td>500</td><td>1</td><td>10</td><td>2015</td><td>True</td></tr><tr><td>1</td><td>552278.0</td><td>Smith Plumbing</td><td>$920,000.00</td><td>$101,2000.00</td><td>10.00%</td><td>700</td><td>6</td><td>15</td><td>2014</td><td>True</td></tr><tr><td>2</td><td>23477.0</td><td>ACME Industrial</td><td>$50,000.00</td><td>$62500.00</td><td>25.00%</td><td>125</td><td>3</td><td>29</td><td>2016</td><td>True</td></tr><tr><td>3</td><td>24900.0</td><td>Brekke LTD</td><td>$350,000.00</td><td>$490000.00</td><td>4.00%</td><td>75</td><td>10</td><td>27</td><td>2015</td><td>True</td></tr><tr><td>4</td><td>651029.0</td><td>Harbor Co</td><td>$15,000.00</td><td>$12750.00</td><td>-15.00%</td><td>Closed</td><td>2</td><td>2</td><td>2014</td><td>False</td></tr></tbody></table><p>dtype 被正确地设置为了 <code>bool</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number    float64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>                object</div><div class="line"><span class="number">2017</span>                object</div><div class="line">Percent Growth      object</div><div class="line">Jan Units           object</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active                bool</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>无论你选择使用 <code>lambda</code> 函数，还是创建一个更标准的 Python 函数，或者是使用其他方法（如 <code>np.where</code>），这些方法都非常灵活，并且可以根据你自己独特的数据需求进行定制。</p><h2 id="Pandas-辅助函数"><a href="#Pandas-辅助函数" class="headerlink" title="Pandas 辅助函数"></a>Pandas 辅助函数</h2><p>Pandas 在直白的 <code>astype()</code> 函数和复杂的自定义函数之间有一个中间地带。这些辅助函数对于某些数据类型转换非常有用。</p><p>如果你顺序读下来，你会注意到我没有对日期列或 <code>Jan Units</code> 列做任何事情。这两种列都可以使用 Pandas 的内置函数（如 <code>pd.to_numeric()</code> 和 <code>pd.to_datetime()</code>）进行转换。</p><p><code>Jan Units</code> 转换出现问题的原因是列中包含一个非数字值。如果我们尝试使用 <code>astype()</code>，我们会得到一个错误（如前所述）。<code>pd.to_numeric()</code> 函数可以更优雅地处理这些值：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.to_numeric(df[<span class="string">'Jan Units'</span>], errors=<span class="string">'coerce'</span>)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">500.0</span></div><div class="line"><span class="number">1</span>    <span class="number">700.0</span></div><div class="line"><span class="number">2</span>    <span class="number">125.0</span></div><div class="line"><span class="number">3</span>     <span class="number">75.0</span></div><div class="line"><span class="number">4</span>      NaN</div><div class="line">Name: Jan Units, dtype: float64</div></pre></td></tr></table></figure><p>这里有几个值得注意的地方。首先，该函数轻松地处理了数据并创建了一个 <code>float64</code> 列。 此外，它会用 <code>NaN</code> 值替换无效的 <code>Closed</code> 值，因为我们配置了 <code>errors=coerce</code>。我们可以将 <code>Nan</code> 留在那里，也可以使用 <code>fillna（0）</code> 来用 0 填充：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.to_numeric(df[<span class="string">'Jan Units'</span>], errors=<span class="string">'coerce'</span>).fillna(<span class="number">0</span>)</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">500.0</span></div><div class="line"><span class="number">1</span>    <span class="number">700.0</span></div><div class="line"><span class="number">2</span>    <span class="number">125.0</span></div><div class="line"><span class="number">3</span>     <span class="number">75.0</span></div><div class="line"><span class="number">4</span>      <span class="number">0.0</span></div><div class="line">Name: Jan Units, dtype: float64</div></pre></td></tr></table></figure><p>我最终介绍的转换是将单独的月份、日期和年份列转换为到一个 <code>datetime</code> 类型的列。Pandas 的 <code>pd.to_datetime()</code> 函数 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html" target="_blank" rel="external">可定制性很好</a>，但默认情况下也十分明智。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.to_datetime(df[[<span class="string">'Month'</span>, <span class="string">'Day'</span>, <span class="string">'Year'</span>]])</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>   <span class="number">2015</span><span class="number">-01</span><span class="number">-10</span></div><div class="line"><span class="number">1</span>   <span class="number">2014</span><span class="number">-06</span><span class="number">-15</span></div><div class="line"><span class="number">2</span>   <span class="number">2016</span><span class="number">-03</span><span class="number">-29</span></div><div class="line"><span class="number">3</span>   <span class="number">2015</span><span class="number">-10</span><span class="number">-27</span></div><div class="line"><span class="number">4</span>   <span class="number">2014</span><span class="number">-02</span><span class="number">-02</span></div><div class="line">dtype: datetime64[ns]</div></pre></td></tr></table></figure><p>在这种情况下，函数将这些列组合成适当 <code>datateime64</code> dtype 的新列。</p><p>我们需要确保将这些值赋值回 dataframe：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[&quot;Start_Date&quot;] = pd.to_datetime(df[[&apos;Month&apos;, &apos;Day&apos;, &apos;Year&apos;]])</div><div class="line">df[&quot;Jan Units&quot;] = pd.to_numeric(df[&apos;Jan Units&apos;], errors=&apos;coerce&apos;).fillna(0)</div></pre></td></tr></table></figure><table><thead><tr><th></th><th>Customer Number</th><th>Customer Name</th><th>2016</th><th>2017</th><th>Percent Growth</th><th>Jan Units</th><th>Month</th><th>Day</th><th>Year</th><th>Active</th><th>Start_Date</th></tr></thead><tbody><tr><td>0</td><td>10002</td><td>Quest Industries</td><td>125000.0</td><td>162500.0</td><td>0.30</td><td>500.0</td><td>1</td><td>10</td><td>2015</td><td>True</td><td>2015-01-10</td></tr><tr><td>1</td><td>552278</td><td>Smith Plumbing</td><td>920000.0</td><td>1012000.0</td><td>0.10</td><td>700.0</td><td>6</td><td>15</td><td>2014</td><td>True</td><td>2014-06-15</td></tr><tr><td>2</td><td>23477</td><td>ACME Industrial</td><td>50000.0</td><td>62500.0</td><td>0.25</td><td>125.0</td><td>3</td><td>29</td><td>2016</td><td>True</td><td>2016-03-29</td></tr><tr><td>3</td><td>24900</td><td>Brekke LTD</td><td>350000.0</td><td>490000.0</td><td>0.04</td><td>75.0</td><td>10</td><td>27</td><td>2015</td><td>True</td><td>2015-10-27</td></tr><tr><td>4</td><td>651029</td><td>Harbor Co</td><td>15000.0</td><td>12750.0</td><td>-0.15</td><td>NaN</td><td>2</td><td>2</td><td>2014</td><td>False</td><td>2014-02-02</td></tr></tbody></table><p>现在数据已正确转换为我们需要的所有类型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number             int64</div><div class="line">Customer Name              object</div><div class="line"><span class="number">2016</span>                      float64</div><div class="line"><span class="number">2017</span>                      float64</div><div class="line">Percent Growth            float64</div><div class="line">Jan Units                 float64</div><div class="line">Month                       int64</div><div class="line">Day                         int64</div><div class="line">Year                        int64</div><div class="line">Active                       bool</div><div class="line">Start_Date         datetime64[ns]</div></pre></td></tr></table></figure><p>Dataframe 已准备好进行分析！</p><h2 id="把它们放在一起"><a href="#把它们放在一起" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h2><p>在数据采集过程中应该尽早地使用 <code>astype()</code> 和自定义转换函数。如果你有一个打算重复处理的数据文件，并且它总是以相同的格式存储，你可以定义在读取数据时需要应用的 <code>dtype</code> 和 <code>converters</code>。将 <code>dtype</code> 视为对数据执行 <code>astype()</code> 很有帮助。<code>converters</code> 参数允许你将函数应用到各种输入列，类似于上面介绍的方法。</p><p>需要注意的是，只能使用 <code>dtype</code> 或 <code>converter</code> 函数中的一种来应用于指定的列。如果你尝试将两者应用于同一列，则会跳过 <code>dtype</code>。</p><p>下面是一个简化的例子，它在数据读入 dataframe 时完成几乎所有的转换：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">df_2 = pd.read_csv(<span class="string">"sales_data_types.csv"</span>,</div><div class="line">                   dtype=&#123;<span class="string">'Customer Number'</span>: <span class="string">'int'</span>&#125;,</div><div class="line">                   converters=&#123;<span class="string">'2016'</span>: convert_currency,</div><div class="line">                               <span class="string">'2017'</span>: convert_currency,</div><div class="line">                               <span class="string">'Percent Growth'</span>: convert_percent,</div><div class="line">                               <span class="string">'Jan Units'</span>: <span class="keyword">lambda</span> x: pd.to_numeric(x, errors=<span class="string">'coerce'</span>),</div><div class="line">                               <span class="string">'Active'</span>: <span class="keyword">lambda</span> x: np.where(x == <span class="string">"Y"</span>, <span class="keyword">True</span>, <span class="keyword">False</span>)</div><div class="line">                              &#125;)</div><div class="line"></div><div class="line">df_2.dtypes</div></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number      int64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>               float64</div><div class="line"><span class="number">2017</span>               float64</div><div class="line">Percent Growth     float64</div><div class="line">Jan Units          float64</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active              object</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>正如前面提到的，我选择了包含用于转换数据的 <code>lambda</code> 示例和函数示例。唯一无法被应用在这里的函数就是那个用来将 <code>Month</code>、<code>Day</code> 和 <code>Year</code> 三列转换到 <code>datetime</code> 列的函数。不过，这仍是一个强大的可以帮助改进数据处理流程的约定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>探索新数据集的第一步是确保数据类型设置正确。大部分时间 Pandas 都会做出合理推论，但数据集中有很多细微差别，因此知道如何使用 Pandas 中的各种数据转换选项非常重要。如果你有任何其他建议，或者有兴趣探索 <code>category</code> 数据类型，请随时在下面发表评论。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自：&lt;a href=&quot;http://pbpython.com/pandas_dtypes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Overview of Pandas Data Types&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162adb65a757dd0a?w=700&amp;amp;h=526&amp;amp;f=png&amp;amp;s=152073&quot; alt=&quot;article header image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>让 Apache Cassandra 尾部延迟减小 10 倍</title>
    <link href="http://stormluke.me/open-sourcing-a-10x-reduction-in-apache-cassandra-tail-latency/"/>
    <id>http://stormluke.me/open-sourcing-a-10x-reduction-in-apache-cassandra-tail-latency/</id>
    <published>2018-04-03T02:00:00.000Z</published>
    <updated>2018-04-21T07:23:43.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 <a href="https://engineering.instagram.com/open-sourcing-a-10x-reduction-in-apache-cassandra-tail-latency-d64f86b43589" target="_blank" rel="external">Open-sourcing a 10x reduction in Apache Cassandra tail latency</a></p></blockquote><p>在 Instagram，我们的数据库是全球最大的 Apache Cassandra 部署之一。我们于 2012 年开始用 Cassandra 取代 Redis，来支持欺诈检测、信息流和 Direct 收件箱等产品需求。最初我们在 AWS 环境中运行 Cassandra 集群，但当其他 Instagram 服务迁移到 Facebook 的基础设施上时，我们也迁过去了。对我们来说 Cassandra 的可靠性和可用性体验都很不错，但是在读取延迟上仍有改进空间。</p><p>去年，Instagram 的 Cassandra 团队开始致力于一个项目，目标是显著减少 Cassandra 的读取延迟，我们称之为 Rocksandra。在这篇文章中，我将介绍该项目的动机、我们克服的挑战以及在内部环境和公共云环境中的性能指标。</p><a id="more"></a><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在 Instagram 我们大量使用 Apache Cassandra 作为通用的键值存储服务。大部分 Instagram 的 Cassandra 请求都是实时（Online）的，为了向巨量的 Instagram 用户提供可靠和快速的用户体验，我们对这些指标的 SLA（服务等级协议，Service Level Agreement）非常严格。</p><p>Instagram 维护 5-9 秒的可靠性 SLA，这意味着在任何时候，请求失败率应该小于 0.001％。为了提高性能，我们实时监控不同 Cassandra 集群的吞吐量和延迟，尤其是 P99 读取延迟。</p><p>下图展示了生产环境中的一个 Cassandra 集群的客户端延迟。蓝线是平均读取延迟（5ms），橙线是 P99 读取延迟（在 25ms 到 60ms 的范围内，并随着客户端流量变化而变动）。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/3/16289f8799b4abde?w=800&amp;h=507&amp;f=png&amp;s=75971" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/4/3/16289f87964ba58d?w=800&amp;h=507&amp;f=png&amp;s=68026" alt=""></p><p>经过调查，我们发现 JVM 垃圾收集器（GC）对延迟峰值作出了很大贡献。我们定义了一个叫做 GC 暂停（GC stall）百分比的度量标准，用于度量 Cassandra 服务器在 stop-the-world GC（新生代 GC）并且无法响应客户端请求时所占时间百分比。这是另一张图，显示了我们生产环境 Cassandra 服务器的 GC 暂停百分比。在流量最小的时间段内，这一比例为 1.25％，在高峰时段可以高达 2.5％。</p><p>该图显示 Cassandra 服务器会把 2.5％ 的运行时间用于垃圾收集，而不是响应客户端请求。GC 开销显然对我们的 P99 延迟有很大影响，所以如果能够降低 GC 暂停百分比，也就能够显著降低 P99 延迟。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Apache Cassandra 是一个分布式数据库，它使用自己以 Java 编写的基于 LSM 树的存储引擎。我们发现存储引擎中的某些组件，例如 memtable、压缩、读/写的代码路径等等，在 Java 堆中创建了很多对象，并给 JVM 增加了很多开销。为了减少存储引擎带来的 GC 问题，我们考虑了不同的方法，最终决定开发一个 C++ 存储引擎来替代现有的引擎。</p><p>我们不想从头开始构建新的存储引擎，因此决定在 RocksDB 之上构建新的存储引擎。</p><p>RocksDB 是一款开源的高性能嵌入式数据库，用于处理键值数据。它用 C++ 编写，并且提供了 C++、C 和 Java 的官方 API。RocksDB 针对性能进行了优化，尤其是针对 SSD 这样的快速存储设备。它在业界被广泛用作 MySQL、mongoDB 和其他流行数据库的存储引擎。</p><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>在 RocksDB 上构建新的存储引擎时，我们克服了三个主要挑战。</p><p>第一个挑战是 Cassandra 的架构不支持可插拔的存储引擎，就是说现有的存储引擎与数据库中的其他组件耦合在一起。为了在大量重构和快速迭代之间找到平衡，我们定义了一个新的存储引擎 API，包括最常见的读/写和流接口。通过这种方式，我们可以在 API 后面构建新的存储引擎，并将其插入到 Cassandra 内部的相关代码路径中。</p><p>其次，Cassandra 支持丰富的数据类型和表模式，而 RocksDB 只提供纯粹的键值接口。我们仔细地定义了编码/解码算法，以便在 RocksDB 的数据结构之上支持 Cassandra 的数据模型，并支持与原始 Cassandra 相同的查询语义。</p><p>第三个挑战是流接口。流传输是像 Cassandra 这样的分布式数据库的重要组成部分。我们新增或移除 Cassandra 集群中的节点时，Cassandra 需要在不同节点之间传输数据以平衡集群中的负载。现有的流传输实现是基于当前存储引擎中的内部细节的。因此，我们必须将它们分离开，建立一个抽象层，并使用 RocksDB API 重新实现流传输。为了提高流吞吐量，目前我们先将数据写入到 temp sst 文件，然后使用 RocksDB ingest file API 将它们一次性批量加载到 RocksDB 中。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>经过大约一年的开发和测试，我们已经完成了第一个版本的实现，并成功在 Instagram 内部将其推广部署到多个 Cassandra 集群。在我们的其中一个生产集群中，P99 读取延迟从 60ms 降至 20ms。我们还观察到，该群集上的 GC 暂停从 2.5％ 下降到 0.3％，足足减小了 10 倍！</p><p>我们还想验证 Rocksandra 在公共云环境中是否会表现良好。我们使用三个 i3.8 xlarge EC2 实例在 AWS 环境中配置 Cassandra 集群，每个实例都有 32 个 CPU 核心，244GB 内存以及 4 个 nvme 闪存磁盘组成的 raid0。</p><p>我们使用 <a href="https://github.com/Netflix/ndbench" target="_blank" rel="external">NDBench</a> 作为基准测试框架，并使用这个框架中默认的表模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TABLE emp (</div><div class="line">  emp_uname text PRIMARY KEY,</div><div class="line">  emp_dept text,</div><div class="line">  emp_first text,</div><div class="line">  emp_last text`</div><div class="line">)</div></pre></td></tr></table></figure><p>我们预加载了 2.5 亿行每行 6KB 的数据到数据库中（每个服务器在磁盘上存储大约 500GB 数据），并在 NDBench 中配置了 128 个读取端和 128 个写入端。</p><p>我们测试了不同的负载并测量了平均/P99/P999的读/写延迟。如你所见，Rocksandra 提供了更低且更稳定的尾部读/写延迟。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/3/16289f8796350173?w=800&amp;h=512&amp;f=png&amp;s=38320" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/4/3/16289f87adbae992?w=800&amp;h=512&amp;f=png&amp;s=37834" alt=""></p><p>我们还测试了只读负载，并观察到在相似的 P99 读取延迟（2ms）下，Rocksandra 可以提供 10 倍的读取吞吐量（Rocksandra 为 300K/s，C* 3.0 为 30K/s）。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/3/16289f87ad9a7f05?w=800&amp;h=402&amp;f=png&amp;s=57283" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/4/3/16289f87ac04333c?w=800&amp;h=430&amp;f=png&amp;s=67432" alt=""></p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>我们已经开源了 <a href="https://github.com/Instagram/cassandra/tree/rocks_3.0" target="_blank" rel="external">Rocksandra 代码库</a> 和 <a href="https://github.com/Instagram/cassandra-aws-benchmark" target="_blank" rel="external">基准测试框架</a>，你可以从 Github 上下载并在自己的环境中尝试！请让我们知道它的表现。</p><p>作为下一步，我们正在积极开发更多的 C<em> 功能支持，如二级索引，数据修复等等。我们还在开发一个 [C</em> 可插拔存储引擎架构](<a href="https://issues.apache.org/jira/browse/CASSANDRA-13474)，将我们的工作回馈给" target="_blank" rel="external">https://issues.apache.org/jira/browse/CASSANDRA-13474)，将我们的工作回馈给</a> Apache Cassandra 社区。</p><p>如果您身处湾区，并有兴趣了解更多关于 Cassandra 开发的信息，请参加我们的下一次 <a href="https://www.meetup.com/Apache-Cassandra-Bay-Area/events/248376266/" target="_blank" rel="external">聚会活动</a>。</p><p>Dikang Gu 是 Instagram 的一名基础架构工程师</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 &lt;a href=&quot;https://engineering.instagram.com/open-sourcing-a-10x-reduction-in-apache-cassandra-tail-latency-d64f86b43589&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Open-sourcing a 10x reduction in Apache Cassandra tail latency&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Instagram，我们的数据库是全球最大的 Apache Cassandra 部署之一。我们于 2012 年开始用 Cassandra 取代 Redis，来支持欺诈检测、信息流和 Direct 收件箱等产品需求。最初我们在 AWS 环境中运行 Cassandra 集群，但当其他 Instagram 服务迁移到 Facebook 的基础设施上时，我们也迁过去了。对我们来说 Cassandra 的可靠性和可用性体验都很不错，但是在读取延迟上仍有改进空间。&lt;/p&gt;
&lt;p&gt;去年，Instagram 的 Cassandra 团队开始致力于一个项目，目标是显著减少 Cassandra 的读取延迟，我们称之为 Rocksandra。在这篇文章中，我将介绍该项目的动机、我们克服的挑战以及在内部环境和公共云环境中的性能指标。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效管理 Elasticsearch 中基于时间的索引</title>
    <link href="http://stormluke.me/es-managing-time-based-indices-efficiently/"/>
    <id>http://stormluke.me/es-managing-time-based-indices-efficiently/</id>
    <published>2017-06-25T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.elastic.co/blog/managing-time-based-indices-efficiently" target="_blank" rel="external">And the big one said “Rollover” — Managing Elasticsearch time-based indices efficiently</a></p><p>用 Elasticsearch 来索引诸如日志事件等基于时间的数据的人可能已经习惯了“每日一索引”模式：使用以天为粒度的索引名字来存放当天的日志数据，一天过去后再建一个新索引。新索引的属性可以由<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html" target="_blank" rel="external">索引模板</a>来提前控制。</p><p>这种模式很容易理解并且易于实现，但是它粉饰了索引管理的一些复杂的地方：</p><ul><li>为了达到较高的写入速度，活跃索引分片需要分布在<em>尽可能多的</em>节点上。</li><li>为了提高搜索速度和降低资源消耗，分片数量需要<em>尽可能地少</em>，但是也不能有过大的单个分片进而不便操作</li><li>一天一个索引确实易于清理陈旧数据，但是一天到底需要多少个分片呢？</li><li>每天的写入压力是一成不变的吗？还是一天分片过多，而下一天分片不够用呢？</li></ul><p>在这篇文章中我将介绍新的”滚动模式“和用来实现它的 API 们，这个模式可以更加简单且高效地管理基于时间的索引。</p><a id="more"></a><h3 id="滚动模式"><a href="#滚动模式" class="headerlink" title="滚动模式"></a>滚动模式</h3><p>滚动模式工作流程如下：</p><ul><li>有一个用于写入的索引别名，其指向活跃索引</li><li>另外一个用于读取（搜索）的索引别名，指向不活跃索引</li><li>活跃索引具有和热节点数量一样多的分片，可以充分发挥昂贵硬件的索引写入能力</li><li>当活跃索引太满或者太老的时候，它就会<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html" target="_blank" rel="external">滚动</a>：新建一个索引并且索引别名自动从老索引切换到新索引</li><li>移动老索引到冷节点上并且<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html" target="_blank" rel="external">缩小</a>为一个分片，之后可以<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html" target="_blank" rel="external">强制合并</a>和压缩。</li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>假设我们有一个具有 10 个<em>热</em>节点和一个<em>冷</em>节点池的集群。理想情况下我们的活跃索引（接收所有写入的索引）应该在每个热节点上均匀分布一个分片，以此来尽可能地在多个机器上分散写入压力。</p><p>我们让每个主分片都有一个复制分片来允许一个节点失效而不丢失数据。这意味着我们的活跃索引应该有 5 个主分片，加起来一共 10 个分片（每个节点一个）。我们也可以用 10 个主分片（包含冗余一共 20 个分片），这样每个节点两个分片。</p><p>首先，为活跃索引创建一个<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html" target="_blank" rel="external">索引模版</a>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PUT _template/active-logs</div><div class="line">&#123;</div><div class="line">  <span class="attr">"template"</span>: <span class="string">"active-logs-*"</span>,</div><div class="line">  <span class="attr">"settings"</span>: &#123;</div><div class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">"routing.allocation.include.box_type"</span>: <span class="string">"hot"</span>,</div><div class="line">    <span class="attr">"routing.allocation.total_shards_per_node"</span>: <span class="number">2</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"aliases"</span>: &#123;</div><div class="line">    <span class="attr">"active-logs"</span>: &#123;&#125;, </div><div class="line">    <span class="attr">"search-logs"</span>: &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由这个模板创建的索引会被分配到标记为 <code>box_type:hot</code> 的节点上，而 <code>total_shards_per_node</code> 配置会保证将分片均匀分布在<em>热</em>节点中。我把其设置为 <code>2</code> 而不是 <code>1</code>，这样当一个节点失效时也可以继续分配分片。</p><p>我们将会用 <code>active-logs</code> 别名来写入当前的活跃索引，用 <code>search-logs</code> 别名来查询所有的日志索引。</p><p>下面是非活跃索引的模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PUT _template/inactive-logs</div><div class="line">&#123;</div><div class="line">  <span class="attr">"template"</span>: <span class="string">"inactive-logs-*"</span>, </div><div class="line">  <span class="attr">"settings"</span>: &#123; </div><div class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">1</span>, </div><div class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"routing.allocation.include.box_type"</span>: <span class="string">"cold"</span>,</div><div class="line">    <span class="attr">"codec"</span>: <span class="string">"best_compression"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>归档的索引应该被分配到<em>冷</em>节点上并且使用 <code>deflate</code> 压缩来节约磁盘空间。我会在之后解释为什么把 <code>replicas</code> 设置为 <code>0</code>。</p><p>现在可以创建第一个活跃索引了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PUT active-logs-1</div></pre></td></tr></table></figure><p>Rollover API 会将名字中的 <code>-1</code> 识别为一个计数器。</p><h3 id="索引日志事件"><a href="#索引日志事件" class="headerlink" title="索引日志事件"></a>索引日志事件</h3><p>当创建 <code>active-logs-1</code> 索引时，我们也创建了 <code>active-logs</code> 别名。在此之后，我们应该仅使用别名来写入，文档会被发送到当前的活动索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST active-logs/log/_bulk</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-01T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-02T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-03T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-04T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-05T01:00:00Z&quot; &#125;</div></pre></td></tr></table></figure><h3 id="滚动索引"><a href="#滚动索引" class="headerlink" title="滚动索引"></a>滚动索引</h3><p>在某个时间点，活跃索引变得过大或者过老，这时你想用一个新的空索引来替换它。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html" target="_blank" rel="external">Rollover API</a> 允许你指定触发滚动操作的具体大小或者时间限制。</p><p>多大才是过大？一如以往，看情况。这取决于你的硬件性能，你的搜索操作的类型，你想要达到的性能效果和你能接受的分片恢复时间等等。可以从例如 1 亿或者 10 亿这种数字开始，依据搜索性能、数据保留时间和可用磁盘空间来上下调整。</p><p>一个分片能包含的文档数有一个硬限制：2147483519。如果你打算把活跃索引缩小到一个分片，那么活跃索引中的文档数不能超过 21 亿。如果活跃索引中的文档一个分片放不下，你可以将活跃索引缩小到多个分片，只要目标分片数是原来分片数的因子，例如 6 到 3 或者 6 到 2。</p><p>基于时间来滚动索引很方便，因为可以按照小时、天或者星期来整理索引。但其实按照索引中的文档数来滚动索引更加高效。按照数量来滚动的优点之一就是所有的分片会具有大致相同的大小，这样做负载均衡更加方便。</p><p>可以用定时任务来定期调用 rollover API 去检查是否到达了 <code>max_docs</code> 或者 <code>max_age</code> 限制。当超过某个限制时，索引就会被滚动。因为我们在例子中只索引了 5 个文档，我们将 <code>max_docs</code> 值设置为 <code>5</code>，并且（为了完整性）将 <code>max_age</code> 设置为一周：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST active-logs/_rollover</div><div class="line">&#123;</div><div class="line">  <span class="attr">"conditions"</span>: &#123;</div><div class="line">    <span class="attr">"max_age"</span>: <span class="string">"7d"</span>,</div><div class="line">    <span class="attr">"max_docs"</span>: <span class="number">5</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个请求告诉 Elasticsearch 去滚动 <code>active-logs</code> 别名指向的索引，如果这个索引至少在七天之前创建或者至少包含 5 个文档。应答如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"old_index"</span>: <span class="string">"active-logs-1"</span>,</div><div class="line">  <span class="attr">"new_index"</span>: <span class="string">"active-logs-2"</span>,</div><div class="line">  <span class="attr">"rolled_over"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"dry_run"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"conditions"</span>: &#123;</div><div class="line">    <span class="attr">"[max_docs: 5]"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"[max_age: 7d]"</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为满足了 <code>max_docs: 5</code> 条件，<code>active-logs-1</code> 索引被滚动到 <code>active-logs-2</code> 索引。这意味着一个叫做 <code>active-logs-2</code> 的索引被创建（基于 <code>active-logs</code> 模板），并且 <code>active-logs</code> 别名从 <code>active-logs-1</code> 切换到 <code>active-logs-2</code>。</p><p>顺带一提，如果你想覆写索引模板中的某些值（例如 <code>settings</code> 或者 <code>mappings</code>），只需要把它们放在 <code>_rollover</code> 的请求体中就可以（和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html" target="_blank" rel="external">创建索引 API</a> 一样）。</p><h4 id="为什么不支持-max-size-限制？"><a href="#为什么不支持-max-size-限制？" class="headerlink" title="为什么不支持 max_size 限制？"></a>为什么不支持 <code>max_size</code> 限制？</h4><p>既然想尽可能地让分片大小相似，为什么不在 <code>max_docs</code> 之外在加上支持 <code>max_size</code> 限制呢？答案是分片的大小并不是一个可靠的测量标准，因为正在进行中的合并会产生大量的临时分片大小增长，而当合并结束后这些增长会消失掉。五个主分片，每个都在合并到一个 5GB 分片的过程中，那么此时索引大小会临时增多 25GB！而对于文档数量来说，它的增长则是可以预测的。</p><h3 id="缩小索引"><a href="#缩小索引" class="headerlink" title="缩小索引"></a>缩小索引</h3><p>此时 <code>acitve-logs-1</code> 不再用于写入，我们可以把它移到冷节点上并且把它缩小到一个分片，这个新索引叫做 <code>inactive-logs-1</code>。在缩小之前，我们必须：</p><ul><li>设置索引为只读</li><li>将所有分片移动到同一个节点上。可以任意选择目标节点，比如选择具有最大剩余空间的<em>冷</em>节点</li></ul><p>用以下命令来做这些事情：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PUT active-logs-1/_settings</div><div class="line">&#123;</div><div class="line">  <span class="attr">"index.blocks.write"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"index.routing.allocation.require._name"</span>: <span class="string">"some_node_name"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>allocation</code> 配置保证了每个分片的至少一个拷贝会被移动到 <code>some_node_name</code> 节点上。这并不会移动所有分片——因为复制分片不能和主分片分配在同一个节点上——但它会保证至少一个主分片或者复制分片会被移动。</p><p>当索引完成迁移后（用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html" target="_blank" rel="external">集群健康 API</a> 来检查），使用一下请求来缩小索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST active-logs-1/_shrink/inactive-logs-1</div></pre></td></tr></table></figure><p>如果你的文件系统支持硬链接，那么缩小会瞬间完成。如果你的文件系统不支持硬链接，那你就得等待所有的分段文件从一个索引拷贝到另一个索引……</p><p>你可以用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html" target="_blank" rel="external">恢复状态查询 API</a> 或者集群健康 API 来监控缩小过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _cluster/health/inactive-logs-1?wait_for_status=yellow</div></pre></td></tr></table></figure><p>当缩小完成后，你就可以从 <code>search-logs</code> 别名中删除老索引并加入新索引：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">POST _aliases</div><div class="line">&#123;</div><div class="line">  <span class="attr">"actions"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"remove"</span>: &#123;</div><div class="line">        <span class="attr">"index"</span>: <span class="string">"active-logs-1"</span>,</div><div class="line">        <span class="attr">"alias"</span>: <span class="string">"search-logs"</span></div><div class="line">      &#125; </div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"add"</span>: &#123;</div><div class="line">        <span class="attr">"index"</span>: <span class="string">"inactive-logs-1"</span>,</div><div class="line">        <span class="attr">"alias"</span>: <span class="string">"search-logs"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="节约空间"><a href="#节约空间" class="headerlink" title="节约空间"></a>节约空间</h3><p>我们的索引已经缩小到单个分片，但它依旧包含和之前相同数量的段文件，并且 <code>best_compression</code> 设置并没有生效，因为没有任何写入操作。我们可以用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html" target="_blank" rel="external">强制合并</a>来将单分片索引优化为单分段索引，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST inactive-logs-1/_forcemerge?max_num_segments=1</div></pre></td></tr></table></figure><p>这个请求会创建一个新的分段来替换之前的多个分段。并且因为 Elasticsearch 必须要写入新分段，<code>best_compression</code> 设置就会起作用，新分段会用 <code>deflate</code> 压缩写入。</p><p>在主分片和复制分片上分别运行强制合并是没有意义的，这就是为什么我们的非活跃索引模板中 <code>number_of_replicas</code> 设置被为 <code>0</code>。现在当强制合并结束后，我们可以打开复制分片以获得冗余：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUT inactive-logs-1/_settings</div><div class="line">&#123; <span class="attr">"number_of_replicas"</span>: <span class="number">1</span> &#125;</div></pre></td></tr></table></figure><p>当复制分片被分配之后（用 <code>?wait_for_status=green</code> API 查询），我们就可以确定拥有了一个冗余，此时便可以安全地删掉 <code>active-logs-1</code> 索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE active-logs-1</div></pre></td></tr></table></figure><h3 id="删除旧索引"><a href="#删除旧索引" class="headerlink" title="删除旧索引"></a>删除旧索引</h3><p>在使用老的每日一索引模式时，决定删除哪些索引十分方便。而在使用滚动模式时，似乎并不好确定索引包含了什么时间段的数据。</p><p>幸运的是，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html" target="_blank" rel="external">字段统计 API</a> 可以轻松确定这些。我们只需要具有找出超过我们阈值的最大 <code>@timestamp</code> 字段的索引列表就可以了：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET search-logs/_field_stats?level=indices</div><div class="line">&#123;</div><div class="line">  <span class="attr">"fields"</span>: [<span class="string">"@timestamp"</span>],</div><div class="line">  <span class="attr">"index_constraints"</span>: &#123;</div><div class="line">    <span class="attr">"@timestamp"</span>: &#123;</div><div class="line">      <span class="attr">"max_value"</span>: &#123;</div><div class="line">        <span class="attr">"lt"</span>: <span class="string">"2016/07/03"</span>,</div><div class="line">        <span class="attr">"format"</span>: <span class="string">"yyyy/MM/dd"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个请求返回的索引都可以删除。</p><h3 id="未来的改进"><a href="#未来的改进" class="headerlink" title="未来的改进"></a>未来的改进</h3><p>通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html" target="_blank" rel="external">滚动</a>、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html" target="_blank" rel="external">缩小</a>、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html" target="_blank" rel="external">强制合并</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html" target="_blank" rel="external">字段统计</a> API，我们向你提供了高效管理基于时间的索引的基础工具。</p><p>当然，这里有许多步骤可以被自动化来让生活更美好。这些步骤并在 Elasticsearch 中并不是很容易内置，因为我们需要在发生意料之外的情况时通知别人。这是在 Elasticsearch 之上构建的工具或应用程序的职责。</p><p>期待可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/index.html" target="_blank" rel="external">Curator index management tool</a> 和 <a href="https://www.elastic.co/guide/en/x-pack/current/index.html" target="_blank" rel="external">X-Pack</a> 中看到相应的工作流和 UI。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自：&lt;a href=&quot;https://www.elastic.co/blog/managing-time-based-indices-efficiently&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;And the big one said “Rollover” — Managing Elasticsearch time-based indices efficiently&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用 Elasticsearch 来索引诸如日志事件等基于时间的数据的人可能已经习惯了“每日一索引”模式：使用以天为粒度的索引名字来存放当天的日志数据，一天过去后再建一个新索引。新索引的属性可以由&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;索引模板&lt;/a&gt;来提前控制。&lt;/p&gt;
&lt;p&gt;这种模式很容易理解并且易于实现，但是它粉饰了索引管理的一些复杂的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了达到较高的写入速度，活跃索引分片需要分布在&lt;em&gt;尽可能多的&lt;/em&gt;节点上。&lt;/li&gt;
&lt;li&gt;为了提高搜索速度和降低资源消耗，分片数量需要&lt;em&gt;尽可能地少&lt;/em&gt;，但是也不能有过大的单个分片进而不便操作&lt;/li&gt;
&lt;li&gt;一天一个索引确实易于清理陈旧数据，但是一天到底需要多少个分片呢？&lt;/li&gt;
&lt;li&gt;每天的写入压力是一成不变的吗？还是一天分片过多，而下一天分片不够用呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇文章中我将介绍新的”滚动模式“和用来实现它的 API 们，这个模式可以更加简单且高效地管理基于时间的索引。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 YCSB 压力测试 HBase</title>
    <link href="http://stormluke.me/ycsb-hbase-readme/"/>
    <id>http://stormluke.me/ycsb-hbase-readme/</id>
    <published>2017-05-22T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.040Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/brianfrankcooper/YCSB" target="_blank" rel="external">YCSB</a>（Yahoo! Cloud Serving Benchmark）是雅虎开源的用于测试新式数据库（主要为 NoSQL）性能的框架，使用 Java 实现，可以测试 HBase、Cassandra、Infinispan、MongoDB 等等。</p><p>YCSB 包括两个部分：</p><ul><li>YCSB 客户端，一个可以扩展的 workload 生成器</li><li>Core workloads，预先配置好的 workloads</li></ul><a id="more"></a><h3 id="安装-YCSB"><a href="#安装-YCSB" class="headerlink" title="安装 YCSB"></a>安装 YCSB</h3><p>下载 <a href="https://github.com/brianfrankcooper/YCSB/releases/latest" target="_blank" rel="external">YCSB 最新发行版</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -O --location https://github.com/brianfrankcooper/YCSB/releases/download/0.12.0/ycsb-0.12.0.tar.gz</div><div class="line">tar xfvz ycsb-0.12.0.tar.gz</div><div class="line"><span class="built_in">cd</span> ycsb-0.12.0</div></pre></td></tr></table></figure><p>其中 <code>workloads</code> 文件夹中为预置的 Core workload，<code>*-binding</code> 文件夹中为预置的数据库接口层。</p><h3 id="运行一个压力测试"><a href="#运行一个压力测试" class="headerlink" title="运行一个压力测试"></a>运行一个压力测试</h3><p>运行一个压力测试需要 6 步：</p><ul><li>配置需要测试的数据库</li><li>选择合适的数据库接口层</li><li>选择合适的 workload</li><li>选择合适的运行时参数</li><li>装载数据（loading phase）</li><li>运行测试（transaction phase）</li></ul><p>这些步骤适合于在单个客户端上运行（小型和中型集群，10 个左右的服务节点），更大的集群需要多个客户端同时运行测试。</p><h4 id="第一步：配置需要测试的数据库"><a href="#第一步：配置需要测试的数据库" class="headerlink" title="第一步：配置需要测试的数据库"></a>第一步：配置需要测试的数据库</h4><p>YCSB 不负责表的创建，需要在数据库中手动创建用于测试的表。例如在 HBase 中，需要手动创建一个表和一个列族。</p><p>为了让测试数据均匀分布在不同节点中，创建 HBase 表时需要设置预先分片策略（参考 <a href="https://issues.apache.org/jira/browse/HBASE-4163" target="_blank" rel="external">HBASE-4163</a>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hbase(main):001:0&gt; n_splits = 20 # HBase recommends (10 * number of regionservers)</div><div class="line">hbase(main):002:0&gt; create &apos;usertable&apos;, &apos;cf&apos;, &#123;SPLITS =&gt; (1..n_splits).map &#123;|i| &quot;user#&#123;1000+i*(9999-1000)/n_splits&#125;&quot;&#125;&#125;</div></pre></td></tr></table></figure><p>这里 <code>n_splits</code> 推荐设置为 <code>RegionServer</code> 数量 * 10。</p><h4 id="第二步：选择合适的数据库接口层"><a href="#第二步：选择合适的数据库接口层" class="headerlink" title="第二步：选择合适的数据库接口层"></a>第二步：选择合适的数据库接口层</h4><p>YCSB 预置了一些常用数据库的接口层，对于 HBase 测试，需要选择 <code>com.yahoo.ycsb.db.HBaseClient</code> 作为接口。</p><p>另外 YCSB 需要知道如何连接到 HBase 的 Zookeeper 服务，最简单的方法是将目标测试服务器上的 HBase 配置文件 <code>$HBASE_HOME/conf/hbase-site.xml</code> 复制到 <code>$YCSB/hbase12/conf</code> 中（低版本 HBase 需要复制到对应的 <code>hbase10</code> 等文件夹中）。</p><p>YCSB 也提供了一个 <code>com.yahoo.ycsb.BasicDB</code> 数据库接口层，这个接口层仅仅打印收到的数据库操作请求，可以用来调试。</p><p>可以用 <code>bin/yscb shell &lt;interface&gt;</code> 来测试数据库接口层配置是否正确，例如使用 <code>BasicDB</code> 层：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ./bin/ycsb shell basic</div><div class="line">&gt; <span class="built_in">help</span></div><div class="line">Commands:</div><div class="line">  <span class="built_in">read</span> key [field1 field2 ...] - Read a record</div><div class="line">  scan key recordcount [field1 field2 ...] - Scan starting at key</div><div class="line">  insert key name1=value1 [name2=value2 ...] - Insert a new record</div><div class="line">  update key name1=value1 [name2=value2 ...] - Update a record</div><div class="line">  delete key - Delete a record</div><div class="line">  table [tablename] - Get or [<span class="built_in">set</span>] the name of the table</div><div class="line">  quit - Quit</div></pre></td></tr></table></figure><h4 id="第三步：选择合适的-workload"><a href="#第三步：选择合适的-workload" class="headerlink" title="第三步：选择合适的 workload"></a>第三步：选择合适的 workload</h4><p>Workload 定义了如何向数据库中加载测试数据，包括两个部分：</p><ul><li>Workload Java 类（<code>com.yahoo.ycsb.Workload</code> 的子类）</li><li>配置文件（Java Properties 格式）</li></ul><p>YCSB 的 CoreWorkload 预置了一些标准测试数据，可以直接使用，包括 6 个不同的类型：</p><ul><li>Workload A：<ul><li>重更新，50% 读 50% 写，例如 session sotre</li></ul></li><li>Workload B：<ul><li>读多写少，95% 读 5% 写，例如 photo tagging</li></ul></li><li>Workload C：<ul><li>只读：100% 读，例如 user profile cache</li></ul></li><li>Workload D：<ul><li>读最近更新：这个 workload 会插入新纪录，越新的纪录读取概率越大，例如：user status updates</li></ul></li><li>Workload E：<ul><li>小范围查询：这个 workload 会查询小范围的纪录，而不是单个纪录，例如：threaded conversations</li></ul></li><li>Workload F：<ul><li>读取-修改-写入：这个 workload 会读取一个纪录，然后修改这个纪录，最后写回，例如：user database</li></ul></li></ul><p>可以根据测试需求选择合适的 workload，也可以新建一个新的 workload。</p><h4 id="第四步：选择合适的运行时参数"><a href="#第四步：选择合适的运行时参数" class="headerlink" title="第四步：选择合适的运行时参数"></a>第四步：选择合适的运行时参数</h4><p>除了在 workload 中配置参数外，YCSB 还支持这些运行时参数：</p><ul><li><code>-threads</code>：客户端线程数，默认为 1</li><li><code>-target</code>：每秒的目标操作数，默认为无限制（尽可能快地完成操作）。例如一个操作需要 100 ms，那么一个线程 1s 内可以完成 10 个操作，通过 <code>-target</code> 参数可以将操作放缓，控制在 10 个以下</li><li><code>-s</code>：每 10s 打印一次客户端状态，用于调试</li></ul><h4 id="第五步：装载数据"><a href="#第五步：装载数据" class="headerlink" title="第五步：装载数据"></a>第五步：装载数据</h4><p>Workload 包含两个阶段：装载阶段和事务阶段。在装载阶段向数据库中插入测试数据。对于 HBase 测试，可以使用下面的命令装载数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/ycsb load hbase12 -P workloads/workloada -p table=usertable -p columnfamily=cf -p recordcount=100000000 -p operationcount=100000000 -thread 50 -s</div></pre></td></tr></table></figure><p>各个参数的含义为：</p><ul><li><code>hbase12</code>：使用 HBase 1.2.x 版本的数据库连接层</li><li><code>-P</code> 指定 workload 配置文件路径，使用 Workload A 类型</li><li><code>-p</code> 指定单个配置（会覆盖之前文件中的配置）<ul><li><code>table=</code>，<code>columnfamily=</code>, 指定 HBase 表名和列族</li><li><code>recordcount=</code>，<code>operationcount=</code>，指定纪录数和操作数</li></ul></li><li><code>-thread</code> 指定客户端线程数</li><li><code>-s</code> 打印状态</li></ul><h4 id="第六步：运行测试"><a href="#第六步：运行测试" class="headerlink" title="第六步：运行测试"></a>第六步：运行测试</h4><p>当装载完测试数据后，就可以运行 workload 测试了。对于 HBase 测试命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/ycsb run hbase12 -P workloads/workloada -p table=usertable -p columnfamily=cf -p recordcount=100000000 -p operationcount=100000000 -thread 50 -s</div></pre></td></tr></table></figure><p>参数含义与装载数据时相同，区别在用 <code>run</code> 替代了 <code>load</code>。</p><p>运行结束后可以看到 YCSB 打印出了一些测试统计结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">[OVERALL], RunTime(ms), 11551.0</div><div class="line">[OVERALL], Throughput(ops/sec), 8657.259111765215</div><div class="line">[TOTAL_GCS_PS_Scavenge], Count, 12.0</div><div class="line">[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 66.0</div><div class="line">[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.5713791013765043</div><div class="line">[TOTAL_GCS_PS_MarkSweep], Count, 0.0</div><div class="line">[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 0.0</div><div class="line">[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0</div><div class="line">[TOTAL_GCs], Count, 12.0</div><div class="line">[TOTAL_GC_TIME], Time(ms), 66.0</div><div class="line">[TOTAL_GC_TIME_%], Time(%), 0.5713791013765043</div><div class="line">[READ], Operations, 50011.0</div><div class="line">[READ], AverageLatency(us), 4418.49443122513</div><div class="line">[READ], MinLatency(us), 1584.0</div><div class="line">[READ], MaxLatency(us), 208895.0</div><div class="line">[READ], 95thPercentileLatency(us), 8207.0</div><div class="line">[READ], 99thPercentileLatency(us), 11463.0</div><div class="line">[READ], Return=OK, 50011</div><div class="line">[CLEANUP], Operations, 100.0</div><div class="line">[CLEANUP], AverageLatency(us), 1393.0</div><div class="line">[CLEANUP], MinLatency(us), 1.0</div><div class="line">[CLEANUP], MaxLatency(us), 138623.0</div><div class="line">[CLEANUP], 95thPercentileLatency(us), 18.0</div><div class="line">[CLEANUP], 99thPercentileLatency(us), 258.0</div><div class="line">[UPDATE], Operations, 49989.0</div><div class="line">[UPDATE], AverageLatency(us), 6124.871431714977</div><div class="line">[UPDATE], MinLatency(us), 1947.0</div><div class="line">[UPDATE], MaxLatency(us), 429311.0</div><div class="line">[UPDATE], 95thPercentileLatency(us), 10087.0</div><div class="line">[UPDATE], 99thPercentileLatency(us), 15335.0</div><div class="line">[UPDATE], Return=OK, 49989</div></pre></td></tr></table></figure><p>各个参数的含义在结果解析中解释。</p><p>如果想获得直方图或者时间序列结果（参考测量参数），可以使用 <code>measurementtype=timeseries</code> 参数。客户端默认每 1s 纪录一次平均延迟，可以通过 <code>timeseries.granularity=2000</code> 参数（毫秒）来修改。此时测试报告为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">[READ], 0, 12064.403652090341</div><div class="line">[READ], 1000, 6515.2218055956155</div><div class="line">[READ], 2000, 5907.763636363637</div><div class="line">[READ], 3000, 4967.781086610593</div><div class="line">[READ], 4000, 4397.277823577906</div><div class="line">[READ], 5000, 5179.516736401673</div><div class="line">[READ], 6000, 4398.908602150537</div><div class="line">[READ], 7000, 4493.980899323517</div><div class="line">[READ], 8000, 4431.4615697437985</div><div class="line">[READ], 9000, 4365.6925873560895</div><div class="line">[READ], 10000, 5771.521574205784</div><div class="line">[READ], 11000, 4300.872277227722</div><div class="line">[READ], 12000, 3728.5879396984924</div><div class="line">...</div></pre></td></tr></table></figure><p>此时整个测试过程就结束了。</p><p>注意 YCSB 的延迟为端到端的延迟，在开始调用数据库接口层方法前开始计时，在方法返回时结束计时，也就是说延迟包括这几个部分：</p><ul><li>在接口层内代码的运行时间</li><li>客户端到数据库服务器的网络延迟</li><li>数据库的执行时间</li></ul><p>其中并不包括由 <code>-target</code> 节流参数引入的延迟。</p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><h4 id="YCSB-参数"><a href="#YCSB-参数" class="headerlink" title="YCSB 参数"></a>YCSB 参数</h4><p>所有的 workload 文件都可以使用以下参数：</p><ul><li><code>workload</code>：workload 类</li><li><code>db</code>：数据库接口层类，默认为 <code>com.yahoo.ycsb.BasicDB</code>，也可以通过命令行指定</li><li><code>exporter</code>：报告类，默认为 <code>com.yahoo.ycsb.measurements.exporter.TextMeasurementsExporter</code></li><li><code>exportfile</code>：报告输出路径，默认 <code>stdout</code></li><li><code>threadcount</code>：客户端线程数，默认 1</li><li><code>measurementtype</code>：测量类型，支持 <code>histogram</code> 和 <code>timeseries</code>，默认 <code>histogram</code></li></ul><h4 id="预置-Core-workload-包参数"><a href="#预置-Core-workload-包参数" class="headerlink" title="预置 Core workload 包参数"></a>预置 Core workload 包参数</h4><p>预置的 workload 支持以下参数：</p><ul><li><code>fieldcount</code>：每个纪录中字段的个数，默认：10</li><li><code>fieldlength</code>：每个字段的大小，默认：100</li><li><code>readallfields</code>：是否读取所有字段还是一个字段，默认：true（读取所有字段）</li><li><code>readproportion</code>：读取操作所占比例，默认 0.95</li><li><code>updateproportion</code>：更新操作所占比例，默认 0.05</li><li><code>insertproportion</code>：插入操作所占比例，默认 0</li><li><code>scanproportion</code>：扫描操作所占比例，默认 0</li><li><code>readmodifywriteproportion</code>：读-更新-写操作所占比例：默认 0</li><li><code>requestdistribution</code>：请求的概率分布类型，支持 <code>uniform</code>、<code>zipfian</code>、<code>latest</code>，默认 <code>uniform</code><ul><li><code>uniform</code>：均匀分布</li><li><code>zipfian</code>：<a href="https://www.wikiwand.com/zh/%E9%BD%8A%E5%A4%AB%E5%AE%9A%E5%BE%8B" target="_blank" rel="external">齐夫分布</a></li><li><code>latest</code>：数据越新访问概率越高</li></ul></li><li><code>maxscanlength</code>：扫描操作最长的范围，默认 1000</li><li><code>scanlengthdistribution</code>：扫描操作范围的概率分布类型（从 1 到 <code>scanlengthdistribution</code>），默认 <code>uniform</code></li><li><code>insertorder</code>：插入顺序<ul><li><code>ordered</code>：根据 key 排序插入</li><li><code>hashed</code>：根据 hash 结果排序插入</li></ul></li><li><code>operationcount</code>：操作数</li><li><code>maxexecutiontime</code>：最长总体执行时间（秒）</li><li><code>table</code>：数据库表名，默认 <code>usertable</code></li><li><code>recordcount</code>：纪录数，默认 0</li><li><code>core_workload_insertion_retry_limit</code>：插入失败重试次数，默认 0</li><li><code>core_workload_insertion_retry_interval</code>：重试间隔（秒），默认 3</li></ul><h4 id="测量参数"><a href="#测量参数" class="headerlink" title="测量参数"></a>测量参数</h4><ul><li><code>hdrhistogram</code> 生成 <code>hdrhistogram</code> 格式的报告，可以使用 <a href="http://hdrhistogram.github.io/HdrHistogram/plotFiles.html" target="_blank" rel="external">HdrHistogram Plotter</a> 展示图形结果<ul><li><code>hdrhistogram.percentiles</code>：测量百分位分区，用逗号隔开，默认 95,99（参考<a href="https://www.zhihu.com/question/20575291" target="_blank" rel="external">第95个百分位（95th percentile）是什么概念？</a>）</li><li><code>hdrhistogram.fileoutput=true|false</code>：是否输出到文件，文件地址由 <code>hdrhistogram.output.path</code> 指定</li></ul></li><li><code>histogram</code><ul><li><code>histogram.buckets</code>：直方图的分区数，默认 1000</li></ul></li><li><code>timeseries</code><ul><li><code>timeseries.granularity</code>：时间序列的粒度（毫秒），默认 1000</li></ul></li></ul><h3 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析"></a>结果解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[OVERALL], RunTime(ms), 16487.0</div><div class="line">[OVERALL], Throughput(ops/sec), 6065.384848668648</div></pre></td></tr></table></figure><ul><li><code>[OVERALL]</code> 区显示测试总体情况<ul><li><code>RunTime(ms)</code> 运行总时间</li><li><code>Throughput(ops/sec)</code> 吞吐量，每秒操作数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[TOTAL_GCS_PS_Scavenge], Count, 23.0</div><div class="line">[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 88.0</div><div class="line">[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.5337538666828411</div><div class="line">[TOTAL_GCS_PS_MarkSweep], Count, 0.0</div><div class="line">[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 0.0</div><div class="line">[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0</div><div class="line">[TOTAL_GCs], Count, 23.0</div><div class="line">[TOTAL_GC_TIME], Time(ms), 88.0</div><div class="line">[TOTAL_GC_TIME_%], Time(%), 0.5337538666828411</div></pre></td></tr></table></figure><ul><li><code>[TOTAL_GC*]</code> 区显示垃圾回收情况（<a href="http://www.jdon.com/idea/jvm-gc.html" target="_blank" rel="external">JVM有关垃圾回收机制的配置</a>）<ul><li><code>[TOTAL_GCS_PS_Scavenge], Count, 23.0</code> Parallel Scavenge 回收次数</li><li><code>[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 88.0</code> Parallel Scavenge 回收时间</li><li><code>[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.5337538666828411</code> Parallel Scavenge 回收时间百分比</li><li><code>[TOTAL_GCS_PS_MarkSweep], Count, 0.0</code> PS MarkSweep 回收次数</li><li><code>[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 0.0</code> PS MarkSweep 回收时间</li><li><code>[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0</code> PS MarkSweep 回收时间百分比</li><li><code>[TOTAL_GCs], Count, 23.0</code> 全局 GC 次数</li><li><code>[TOTAL_GC_TIME], Time(ms), 88.0</code> 全局 GC 时间</li><li><code>[TOTAL_GC_TIME_%], Time(%), 0.5337538666828411</code> 全局 GC 时间百分比</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[READ], Operations, 50011.0</div><div class="line">[READ], AverageLatency(us), 4418.49443122513</div><div class="line">[READ], MinLatency(us), 1584.0</div><div class="line">[READ], MaxLatency(us), 208895.0</div><div class="line">[READ], 95thPercentileLatency(us), 8207.0</div><div class="line">[READ], 99thPercentileLatency(us), 11463.0</div><div class="line">[READ], Return=OK, 50011</div></pre></td></tr></table></figure><ul><li><code>[READ]</code> 区显示读取操作的统计结果<ul><li><code>Operations</code> 总操作数</li><li><code>AverageLatency(us)</code> 平均延迟（微秒）</li><li><code>MinLatency(us)</code> 最小延迟</li><li><code>MaxLatency(us)</code> 最大延迟</li><li><code>95thPercentileLatency(us)</code> 第 95 百分位延迟（<a href="https://www.zhihu.com/question/20575291" target="_blank" rel="external">第95个百分位（95th percentile）是什么概念？</a>）</li><li><code>99thPercentileLatency(us)</code> 第 99 百分位延迟</li><li><code>Return=OK, 50011</code> 结果（正确），总操作数</li></ul></li></ul><p><code>[CLEANUP]</code>（清理操作）、<code>[UPDATE]</code>（更新操作）等等和 <code>[READ]</code> 区类似，不再介绍。</p><h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h3><p>客户端默认会读取并操作所有的测试记录数据，在想多个客户端并行测试时这可能有些问题。可以用 <code>insertstart</code> 和 <code>insertcount</code> 两个参数来限制客户端操作测试纪录的范围，例如对于 4 个客户端测试 100000000 条纪录可以这样配置：</p><p>第一个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=0</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure><p>第二个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=25000000</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure><p>第三个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=50000000</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure><p>第四个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=75000000</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/brianfrankcooper/YCSB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YCSB&lt;/a&gt;（Yahoo! Cloud Serving Benchmark）是雅虎开源的用于测试新式数据库（主要为 NoSQL）性能的框架，使用 Java 实现，可以测试 HBase、Cassandra、Infinispan、MongoDB 等等。&lt;/p&gt;
&lt;p&gt;YCSB 包括两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YCSB 客户端，一个可以扩展的 workload 生成器&lt;/li&gt;
&lt;li&gt;Core workloads，预先配置好的 workloads&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 拾遗 02 - Java 7 的异常处理</title>
    <link href="http://stormluke.me/about-java-02/"/>
    <id>http://stormluke.me/about-java-02/</id>
    <published>2016-08-03T12:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Multicatch"><a href="#Multicatch" class="headerlink" title="Multicatch"></a>Multicatch</h3><p>Java 7 新加了 multicatch 特性，一个 <code>catch</code> 语句中可以捕获多种异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  String fileText = getFile(fileName);</div><div class="line">  cfg = verifyConfig(parseConfig(fileText));</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException | ParseException | ConfigurationException e) &#123;</div><div class="line">  System.err.println(<span class="string">"Config file '"</span> + fileName + <span class="string">"' is missing or malformed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="final-重抛"><a href="#final-重抛" class="headerlink" title="final 重抛"></a>final 重抛</h3><p>Java 7 之前重抛异常时会被强制限制为 <code>catch</code> 到的异常类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  doSomethingWhichMightThrowIOException();</div><div class="line">  doSomethingElseWhichMightThrowSQLException();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">  <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码中的 <code>e</code> 可能为 <code>IOException</code> 或者 <code>SQLException</code> 类型，但是真实的类型被覆盖了。Java 7 中可以用 <code>final</code> 来修饰异常类型，这样重抛时的类型不会被改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  doSomethingWhichMightThrowIOException();</div><div class="line">  doSomethingElseWhichMightThrowSQLException();</div><div class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">  <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>Java 中关闭资源的时候很容易出错，比如关闭一个流要记得先检查 <code>null</code>，再 <code>try</code> <code>close()</code>，出现异常还要记得处理（一般什么也做不了）等等。Java 7 中加入了自动管理资源的特性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">     InputStream is = url.openStream()) &#123;</div><div class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</div><div class="line">  <span class="keyword">int</span> len;</div><div class="line">  <span class="keyword">while</span> ((len = is.read(buf)) &gt; <span class="number">0</span>) &#123;</div><div class="line">    out.write(buf, <span class="number">0</span>, len);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码结束后会自动关闭资源。但是要小心，这样写是不对的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"someFile.bin"</span>))) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部的 <code>new FileInputStream(&quot;someFile.bin&quot;)</code> 如果失败并不会被关闭，正确的方法是为每个资源声明独立变量。</p><p>TWR 还有个好处是改善了异常堆栈，比如说会抑制异常堆栈中的 <code>NullPointerException</code> 等等。</p><p>TWR 依靠新接口 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html" target="_blank" rel="external"><code>AutoCloseable</code></a> 实现，Java 7 大部分的资源类都实现了这个接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Multicatch&quot;&gt;&lt;a href=&quot;#Multicatch&quot; class=&quot;headerlink&quot; title=&quot;Multicatch&quot;&gt;&lt;/a&gt;Multicatch&lt;/h3&gt;&lt;p&gt;Java 7 新加了 multicatch 特性，一个 &lt;code&gt;catch&lt;/code&gt; 语句中可以捕获多种异常：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  String fileText = getFile(fileName);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  cfg = verifyConfig(parseConfig(fileText));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (FileNotFoundException | ParseException | ConfigurationException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  System.err.println(&lt;span class=&quot;string&quot;&gt;&quot;Config file &#39;&quot;&lt;/span&gt; + fileName + &lt;span class=&quot;string&quot;&gt;&quot;&#39; is missing or malformed&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 拾遗 01 - Colleciton 基础</title>
    <link href="http://stormluke.me/about-java-01/"/>
    <id>http://stormluke.me/about-java-01/</id>
    <published>2016-08-03T00:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://docs.oracle.com/javase/tutorial/collections/index.html" target="_blank" rel="external">Oracle 的文档</a>中提到，Collection 是：</p><ul><li>接口</li><li>实现</li><li>算法</li></ul><a id="more"></a><p>的集合。Collection 的好处有：</p><ul><li>减少编程工作量</li><li>提高程序速度和质量</li><li>允许无关的API之间的互操作性</li><li>让学习和使用新 API 更省力</li><li>让设计新 API 更省力</li><li>促进软件重用</li></ul><p>Java 中的基础 Collection 接口有：</p><ul><li><code>Set</code> / <code>SortedSet</code></li><li><code>List</code><ul><li><code>Queue</code> / <code>Deque</code>（双端队列，Double Ended QUEue）</li></ul></li><li><code>Map</code> / <code>SortedMap</code></li></ul><p>Java 对这些接口提供了一些通用的实现：</p><ul><li><code>Set</code><ul><li><code>HashSet</code>，Java 1.2，无序，散列</li><li><code>TreeSet</code>，Java 1.2，升序，红黑树</li><li><code>LinkedHashSet</code>，Java 1.4，插入序，散列</li></ul></li><li><code>List</code><ul><li><code>ArrayList</code>，Java 1.2，数组</li><li><code>LinkedList</code>，Java 1.2，链表</li><li><code>ArrayDeque</code>，Java 1.6，数组</li></ul></li><li><code>Map</code><ul><li><code>HashMap</code>，Java 1.2，无序，散列</li><li><code>TreeMap</code>，Java 1.2，升序，红黑树</li><li><code>LinkedHashMap</code>，Java 1.4，插入序，散列</li></ul></li></ul><p>它们之间的关系如下：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1f6ghss8lpvj20z00zejw5.jpg" alt=""></p><p>值得注意的是 <code>Map</code> 不遵循 <code>Collection</code>，<code>Set</code> 的实现依赖于 <code>Map</code>。这些 Collection 均没有考虑线程安全。</p><p>某些面试题中问到 <code>Vector</code> 和 <code>ArrayList</code> 的区别，主要有以下几点：</p><ul><li><code>Vector</code> 在 Java 1.0 加入，<code>ArrayList</code> 在 Java 1.2 加入</li><li><code>Vector</code> 线程安全（由 <code>synchronized</code> 实现），<code>ArrayList</code> 没考虑线程安全，但有专门的易互转的 <code>CopyOnWriteArrayList</code> 等来应对多线程应用</li><li><code>Vector</code> 每次扩容一倍，<code>ArrayList</code> 扩容 50%</li><li>在<a href="https://dzone.com/articles/java-collection-performance" target="_blank" rel="external">这个 benchmark</a> 中 <code>Vector</code> 比 <code>ArrayList</code> 略慢</li></ul><p>所以 <code>Vector</code> 一般存在于面试题中。同样，<code>Hashtable</code>、<code>Dictionary</code>、<code>BitSet</code>、<code>Stack</code>、<code>Properties</code> 这些类也都是遗留的。</p><p>关于不同 Collection 的算法实现效率，可以参考 <a href="http://bigocheatsheet.com/" target="_blank" rel="external">Big-O Cheat Sheet（Java 无关）</a>／<a href="http://stackoverflow.com/a/559862" target="_blank" rel="external">big-o-summary-for-java-collections-framework-implementations（Java 相关）</a>。</p><p>更多关于 Collection 的参考：</p><ul><li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/collections/overview.html" target="_blank" rel="external">Collections Framework Overview</a></li><li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/collections/reference.html" target="_blank" rel="external">Annotated Outline of Collections Framework</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Oracle 的文档&lt;/a&gt;中提到，Collection 是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WWDC16 笔记——协议和值在 UIKit 中的应用</title>
    <link href="http://stormluke.me/wwdc-2016-session-419-note/"/>
    <id>http://stormluke.me/wwdc-2016-session-419-note/</id>
    <published>2016-07-05T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.040Z</updated>
    
    <content type="html"><![CDATA[<p>这个 <a href="http://asciiwwdc.com/2016/sessions/419" target="_blank" rel="external">Session</a> 通过一个 App 实例讲解了协议和值类型在 UIKit 中的应用。</p><h3 id="Local-Reasoning"><a href="#Local-Reasoning" class="headerlink" title="Local Reasoning"></a>Local Reasoning</h3><p>Local reasoning 是指，当看到面前的代码时，不必考虑其他代码是如何和它交互的。这让代码更容易维护，更容易编写，更容易测试。</p><p>下面通过一个实际的 App 来说明。这个 App 叫做 <a href="https://developer.apple.com/go/?id=lucid-dreams" target="_blank" rel="external">Lucid Dreams</a>，它用来记录程序员做过的白日梦。</p><a id="more"></a><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5ja7n5g1nj20qe0ssn03.jpg" alt=""></p><h3 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h3><p>一个梦的模型可能是这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dream</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> description: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> creature: <span class="type">Creature</span></div><div class="line">  <span class="keyword">var</span> effects: <span class="type">SetEffect</span>&gt;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但 <code>class</code> 型是引用语义，这会带来一个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dream1 = <span class="type">Dream</span>(...)</div><div class="line"><span class="keyword">var</span> dream2 = dream1</div><div class="line">dream2.description = <span class="string">"Unicorns all over"</span></div></pre></td></tr></table></figure><p>改变 <code>dream2</code> 会导致 <code>dream1</code> 一起变化：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jaj4vetoj20so0lwmyq.jpg" alt=""></p><p>不同的对象间关系复杂，<code>class</code> 的引用语义在这里会造成不小麻烦：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbjw1f5jaiuk123j219q0saads.jpg" alt=""></p><p>这不符合 local reasoning，可以用 <code>struct</code> 型来改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dream</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> description: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> creature: <span class="type">Creature</span></div><div class="line">  <span class="keyword">var</span> effects: <span class="type">SetEffect</span>&gt;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> dream1 = <span class="type">Dream</span>(...)</div><div class="line"><span class="keyword">var</span> dream2 = dream1</div></pre></td></tr></table></figure><p>此时两个 <code>dream</code> 是不同的：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jal1fignj20ju0r6myw.jpg" alt=""></p><h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p>这个 App 里有一个列表来显示做过的梦，它的 <code>UITableViewCell</code> 是这样的继承结构：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5japsvp5lj21ag0ne0vv.jpg" alt=""></p><p>这样做层次分明，但问题来了，在梦的详情页面里有个几乎一模一样的界面来展示梦的缩略图和标题，但它是个直接继承 <code>UIView</code> 的视图：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jase7k6bj21kw0kz42q.jpg" alt=""></p><p>仅仅是因为子类类型的区别，相同的视图代码重复写了两次。更严重的是，之后还想用 <code>SKNode</code> 来展示同样的界面，只是缩略图是动态的，难道还要再复制粘贴一份代码吗？当然不是，这些界面有相似之处，即布局相同，可以把它们的布局逻辑抽象成同一个对象来减少重复：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbjw1f5jaymru9gj21kw0ivta6.jpg" alt=""></p><p>把布局代码单独抽取出来作为 <code>DecoratingLayout</code>，它有一个只关心如何布局的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">UIView</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">UIView</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="comment">// Perform layout...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来布局逻辑和 <code>UITableViewCell</code> 解耦，可以用在 <code>UIView</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamCell</span> : <span class="title">UITableViewCell</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line">    decoratingLayout.layout(<span class="keyword">in</span>: bounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamDetailView</span> : <span class="title">UIView</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line">    decoratingLayout.layout(<span class="keyword">in</span>: bounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样做还有一个好处，就是测试代码更容易写，不需要创建 <code>UITableView</code> 就可以测试布局：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> child1 = <span class="type">UIView</span>()</div><div class="line">  <span class="keyword">let</span> child2 = <span class="type">UIView</span>()</div><div class="line">  <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)</div><div class="line">  layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(child1.frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>UIView</code> 和 <code>UITableViewCell</code> 的问题解决了，<code>SKNode</code> 的问题还没有。这主要是因为在 <code>DecoratingLayout</code> 里强制限定了 <code>UIView</code> 类型，把它换成一个 <code>protocol Layout</code> 即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span>: <span class="title">Layout</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Child</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="comment">// Perform layout...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> frame: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span> </span>&#123;&#125;</div></pre></td></tr></table></figure><p>现在又有一个新的视图，它和之前的布局相似，只是缩略图变成了层叠的：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5jbsrbw8sj21580eq0u5.jpg" alt=""></p><p>可以用组合 <code>UIView</code> 的方式解决这个问题，把视图分为两个部分，一个负责层叠的缩略图部分，一个负责整体的横向布局：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5jbtwihisj21340im3zc.jpg" alt=""></p><p>但是注意：</p><ul><li><code>class</code> 实例开销很大！</li><li><code>struct</code> 开销却很小</li><li>组合和值类型配合得更好</li></ul><p>所以说可以用组合 <code>struct</code> 来改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayoutChild</span> : <span class="title">Layout</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">var</span> children: [<span class="type">Child</span>]</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看起来不错，但 <code>CascadingLayout</code> 和 <code>DecoratingLayout</code> 都有 <code>layout</code> 方法，而且布局并不需要读写 <code>frame</code> 这么大的权限，因此可以用 <code>protocol Layout</code> 来泛化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>, ...&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayoutChild</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> decoration = <span class="type">CascadingLayout</span>(children: accessories)</div><div class="line"><span class="keyword">var</span> composedLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line"></div><div class="line">composedLayout.layout(<span class="keyword">in</span>: rect)</div></pre></td></tr></table></figure><p>还有个问题，层叠视图中的子视图具有先后的顺序关系，需要在 <code>protocol</code> 中体现它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Layout</span>] &#123; <span class="keyword">get</span> &#125; <span class="comment">// UIView and SKNode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但这样一来 <code>content</code> 的类型限制就没了。怎么办？用 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md" target="_blank" rel="external"><code>associatedtype</code></a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  associatedtype <span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Child</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>问题又来了，<code>content</code> 和 <code>decoration</code> 类型一致（<code>Child</code>），两个都是 <code>UIView</code> 时固然没错，但如果想如下布局该怎么办？</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5jcyc5n7nj20p60egmyb.jpg" alt=""></p><p>改类型，用约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>, <span class="title">Decoration</span> : <span class="title">Layout</span></span></div><div class="line"><span class="class">                        <span class="title">where</span> <span class="title">Child</span>.<span class="title">Content</span> == <span class="title">Decoration</span>.<span class="title">Content</span>&gt; : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Decoration</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>终于结束了。好处也是有的，测试时不必使用真正的 <code>UIView</code> 类型，随便换个遵循 <code>protocol Layout</code>的就可以了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> child1 = <span class="type">TestLayout</span>()</div><div class="line">  <span class="keyword">let</span> child2 = <span class="type">TestLayout</span>()</div><div class="line">  <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)</div><div class="line">  layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">0</span>].frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">1</span>].frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestLayout</span> : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> frame: <span class="type">CGRect</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="控制器层"><a href="#控制器层" class="headerlink" title="控制器层"></a>控制器层</h3><p>这个 App 还有一个功能：摇晃撤销上次修改。相关的代码是这样写的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]</div><div class="line">  <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>dreams</code> 和 <code>favoriteCreature</code> 都要支持撤销操作，它们均被撤销管理器管理：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5k0jbwx61j218a0lcq4q.jpg" alt=""></p><p>这就有问题了，每个属性都要写一份自己的撤销操作代码，如果之后有更多的属性，那就得写更多的重复代码。怎么办？可以把这些属性封装成一个整体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> model: <span class="type">Model</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span> : <span class="title">Equatable</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]</div><div class="line">  <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来每次撤销操作都操作一个整体模型，避免了把琐碎的撤销操作分散到不同的地方：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1f5k0pprxm1j21iw10q796.jpg" alt=""></p><p>整体容易撤销操作了，但具体的界面更新怎么办？根据模型变化部分更新：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">modelDidChange</span><span class="params">(old: Model, new: Model)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> old.favoriteCreature != new.favoriteCreature &#123;</div><div class="line">      <span class="comment">// Reload table view section for favorite creature.</span></div><div class="line">      tableView.reloadSections(...)</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    undoManager?.registerUndo(withTarget: <span class="keyword">self</span>, handler: &#123; target <span class="keyword">in</span></div><div class="line">      target.model = old</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个 App 还有三种不同的状态，浏览、选择、分享。这些状态的相关代码分成了好几个属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> isInViewingMode: <span class="type">Bool</span></div><div class="line">  <span class="keyword">var</span> sharingDreams: [<span class="type">Dream</span>]?</div><div class="line">  <span class="keyword">var</span> selectedRows: <span class="type">IndexSet</span>?</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这不好，因为改变其中一个属性的同时还要记得改变相关的属性。用一个 <code>struct</code> 模型来改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> state: <span class="type">State</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> viewing</div><div class="line">  <span class="keyword">case</span> sharing(dreams: [<span class="type">Dream</span>])</div><div class="line">  <span class="keyword">case</span> selecting(selectedRows: <span class="type">IndexSet</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最终整体的 MVC 结构如下：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5k5mxg7elj21kw0tmaea.jpg" alt=""></p><ul><li>通过组合来自定义</li><li>使用 <code>protocol</code> 来编写通用的、可重用的代码</li><li>多利用值语义的优点</li><li>Local reasoning</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个 &lt;a href=&quot;http://asciiwwdc.com/2016/sessions/419&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Session&lt;/a&gt; 通过一个 App 实例讲解了协议和值类型在 UIKit 中的应用。&lt;/p&gt;
&lt;h3 id=&quot;Local-Reasoning&quot;&gt;&lt;a href=&quot;#Local-Reasoning&quot; class=&quot;headerlink&quot; title=&quot;Local Reasoning&quot;&gt;&lt;/a&gt;Local Reasoning&lt;/h3&gt;&lt;p&gt;Local reasoning 是指，当看到面前的代码时，不必考虑其他代码是如何和它交互的。这让代码更容易维护，更容易编写，更容易测试。&lt;/p&gt;
&lt;p&gt;下面通过一个实际的 App 来说明。这个 App 叫做 &lt;a href=&quot;https://developer.apple.com/go/?id=lucid-dreams&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lucid Dreams&lt;/a&gt;，它用来记录程序员做过的白日梦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>东西@2016</title>
    <link href="http://stormluke.me/things-2016/"/>
    <id>http://stormluke.me/things-2016/</id>
    <published>2016-06-20T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.038Z</updated>
    
    <content type="html"><![CDATA[<ul><li><del>Synology DiskStation DS216j</del> (WD MyCloud)</li><li><del>Apple iPad mini 4 64GB</del> (Apple iPad Air 2 128GB)</li><li><del>Sandisk CZ88</del></li><li><del>NETGEAR R7000</del> (极路由 3)</li><li><del>Logi BASE Charging Stand with Smart Connector for iPad Pro</del></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;del&gt;Synology DiskStation DS216j&lt;/del&gt; (WD MyCloud)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Apple iPad mini 4 64GB&lt;/del&gt; (Apple iPad Air 2 128GB)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Sandisk CZ88&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;NETGEAR R7000&lt;/del&gt; (极路由 3)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Logi BASE Charging Stand with Smart Connector for iPad Pro&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据的哈希学习：入门教程 － 引子</title>
    <link href="http://stormluke.me/learning-to-hash-intro/"/>
    <id>http://stormluke.me/learning-to-hash-intro/</id>
    <published>2016-05-07T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.035Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://cs.nju.edu.cn/lwj/slides/L2H.pdf" target="_blank" rel="external">Learning to Hash for Big Data: A Tutorial</a>。</p><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><h4 id="大数据中的最近邻搜索"><a href="#大数据中的最近邻搜索" class="headerlink" title="大数据中的最近邻搜索"></a>大数据中的最近邻搜索</h4><p>最近邻搜索（Nearest Neighbor Search）：给定查询点 q，返回数据库中距离 q 最近（最相似）的点集。</p><ul><li>Facebook：7.5 亿用户</li><li>Flickr：6 千万照片</li><li>Wal-Mart: 每天 2.67 亿商品；4PB 数据仓库</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%B2%E9%9A%86%E6%95%B8%E4%BD%8D%E5%B7%A1%E5%A4%A9" target="_blank" rel="external">Sloan Digital Sky Survery</a>：新墨西哥州望远镜每天获取 200GB 图像数据</li></ul><a id="more"></a><p>大数据中的最近邻搜索挑战：</p><ul><li>维数灾难</li><li>存储</li><li>查询速度</li></ul><h4 id="Similarity-Preserving-Hashing（相似保留哈希）"><a href="#Similarity-Preserving-Hashing（相似保留哈希）" class="headerlink" title="Similarity Preserving Hashing（相似保留哈希）"></a>Similarity Preserving Hashing（相似保留哈希）</h4><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f60tbwescjj21gg0w6dug.jpg" alt=""></p><p>让无关图像对应的哈希编码尽可能不同，让相似图像的哈希编码尽可能相同。</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f60tbcewrvj211q0uun0o.jpg" alt=""></p><p>存储空间需求减少。</p><p>使用哈希编码来建立索引，可以达到常数或次线性查询时间复杂度。</p><p>某些情况下线性时间的全搜索也可以接受，因为二进制表示下的距离计算消耗很低。</p><h4 id="哈希函数学习的两个阶段"><a href="#哈希函数学习的两个阶段" class="headerlink" title="哈希函数学习的两个阶段"></a>哈希函数学习的两个阶段</h4><ul><li>第一类<ul><li>投影阶段（Projection Stage）（降维）<ul><li>用实值投影函数投影</li><li>给定点 x，每个投影维度 i 都和一个实值投影函数相关联 fi(x)（比如 fi(x)=Wi^T*x</li></ul></li><li>量化阶段（Quantization Stage）<ul><li>将实数转化为二进制（Turn real into binary）</li><li>度量学习（metric learning）和哈希学习（learning to hash）的本质区别</li></ul></li></ul></li><li>第二类<ul><li>二进制编码学习阶段</li><li>哈希函数学习阶段</li></ul></li></ul><h4 id="数据无关方法"><a href="#数据无关方法" class="headerlink" title="数据无关方法"></a>数据无关方法</h4><p>哈希函数的定义和训练数据集无关。</p><ul><li>Locality-sensitive hashing (LSH) 位置敏感哈希 (Gionis et al., 1999; Andoni and Indyk, 2008)<ul><li>和它的扩展 (Datar et al., 2004; Kulis and Grauman, 2009; Kulis et al., 2009)</li></ul></li><li>SIKH: 偏移不变核函数哈希（Shift invariant kernel hashing）(SIKH) (Raginsky and Lazebnik, 2009)</li><li>MinHash (Broder et al., 1998)<ul><li>和它的扩展 (Li and K ̈onig, 2011)</li></ul></li></ul><p>这些方法的哈希函数使用了<strong>随机投影</strong>或者是<strong>人工构造</strong>的，所以不属于哈希学习。</p><h4 id="数据相关方法"><a href="#数据相关方法" class="headerlink" title="数据相关方法"></a>数据相关方法</h4><p>哈希函数是从给定的训练数据集中学习得到。</p><p>和数据无关方法相比，数据相关方法（即哈希学习）可以在更短的二进制编码上获得相近甚至更好的精确度。</p><p>开创性论文：(Salakhutdinov and Hinton, 2007, 2009; Torralba et al., 2008; Weiss et al., 2008)</p><p>两个种类：</p><ul><li>单模态<ul><li>监督式方法：给定一些监督的（语义）信息，例如 pairwise 标签 s_ij, pointwise 标签 yi 或者 triplet 标签 (xi, xj, xk)</li><li>非监督式方法</li></ul></li><li>多模态<ul><li>监督式方法</li><li>非监督式方法</li></ul></li></ul><h4 id="单模态非监督方法"><a href="#单模态非监督方法" class="headerlink" title="单模态非监督方法"></a>单模态非监督方法</h4><p>没有指示训练点类别的标签。</p><ul><li>PCAH：主成分分析</li><li>SH：数据相似度图中计算出的<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%BE%B5%E5%87%BD%E6%95%B8" target="_blank" rel="external">本征函数（eigenfunctions）</a> (Weiss et al., 2008)</li><li>AGH：基于锚图（anchor graph）的哈希 (Liu et al., 2011)</li><li>ITQ：用<a href="https://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5" target="_blank" rel="external">正交旋转矩阵（orthogonal rotation matrix）</a>来改进由 PCA 学习到的初始影射矩阵 (Gong and Lazebnik, 2011)</li><li>IsoHash：使用<a href="https://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5" target="_blank" rel="external">正交旋转矩阵（orthogonal rotation matrix）</a>来让不同方向的变化<a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7" target="_blank" rel="external">各向同性（isotropic）</a>（相等） (Kong and Li, 2012b)</li><li>DGH：直接学习离散二进制编码 (Liu et al., 2014)</li><li>SGH: 使用特征变换的可扩展的图哈希 (Jiang and Li, 2015)</li></ul><h4 id="单模态监督（半监督）方法"><a href="#单模态监督（半监督）方法" class="headerlink" title="单模态监督（半监督）方法"></a>单模态监督（半监督）方法</h4><p>具有类标签或者配对（pairwise）约束。</p><ul><li>SSH (SPLH)：半监督哈希，同时利用有标签和无标签数据 (Wang et al., 2010a,b)</li><li>MLH：基于隐式结构（latent structural）SVM 框架的最小化损失哈希 (Norouzi and Fleet, 2011)</li><li>LDAHash：基于线性区分分析（Linear discriminant analysis）的哈希 (Strecha et al., 2012)</li><li>KSH：基于核函数（Kernel）的监督式哈希 (Liu et al., 2012)</li><li>LFH：隐含因子模型的监督式哈希 (Zhang et al., 2014)</li><li>FastH：使用图割和决策树的监督式哈希 (Lin et al., 2014)</li><li>SDH：使用逐点（pointwise）标签的监督式离散哈希 (Shen et al., 2015)</li><li>COSDISH：使用 pairwise 监督的可扩展的离散哈希</li></ul><h4 id="基于排序的方法"><a href="#基于排序的方法" class="headerlink" title="基于排序的方法"></a>基于排序的方法</h4><p>监督信息是排序标签，例如三元组 (xi, xj, xk)。</p><ul><li>HDML：汉明距离度量学习（metric learning）(Norouzi et al., 2012)</li><li>OPH：顺序保留哈希，近似最近邻搜索 (Wang et al., 2013b)</li><li>RSH：用 listwise 监督式学习哈希编码 (Wang et al., 2013a)</li><li>RPH：排序保留哈希，快速相似度搜索 (Wang et al., 2015)</li></ul><h4 id="多媒体方法"><a href="#多媒体方法" class="headerlink" title="多媒体方法"></a>多媒体方法</h4><ul><li>多来源哈希（Multi-Source）</li><li>跨媒体哈希（Cross-Modal Hashing）</li></ul><h5 id="多来源方法"><a href="#多来源方法" class="headerlink" title="多来源方法"></a>多来源方法</h5><ul><li>目标是利用辅助视图（auxiliary views）来学习比单模态哈希更好的编码</li><li>假设查询提供了所有视图</li><li>MFH：多特征哈希 (Song et al., 2011)</li><li>CH：复合哈希 (Zhang et al., 2011)</li></ul><h5 id="跨媒体方法"><a href="#跨媒体方法" class="headerlink" title="跨媒体方法"></a>跨媒体方法</h5><p>给定包含图片或文字的查询，返回相关的图片或文字。</p><ul><li>CVH：跨视图哈希 (Kumar and Udupa, 2011)</li><li>MLBE：多模态隐含二进制嵌入 (Zhen and Yeung, 2012a)</li><li>CRH：同时正则化（Co-regularized）哈希 (Zhen and Yeung, 2012b)</li><li>IMH：媒体间哈希（Inter-media hashing）(Song et al., 2013)</li><li>RaHH：关系感知异构（Relation-aware heterogeneous）哈希 (Ou et al., 2013)</li><li>SCM：语义相关最大化（Semantic correlation maximization）(Zhang and Li, 2014)</li><li>CMFH：集体矩阵分解（Collective matrix factorization）哈希 (Ding et al., 2014)</li><li>QCH：量化相关哈希（Quantized correlation hashing）(Wu et al., 2015)</li><li>SePH：语义保留哈希 (Lin et al., 2015b)</li></ul><h4 id="深度哈希"><a href="#深度哈希" class="headerlink" title="深度哈希"></a>深度哈希</h4><p>使用深度学习的哈希。</p><ul><li>CNNH：通过图片表达学习的监督式哈希 (Xia et al., 2014)</li><li>NINH：用深度神经网络同时特征学习和哈希编码 (Lai et al., 2015)</li><li>DSRH：基于深度语义排序的哈希 (Zhao et al., 2015)</li><li>DRSCH：位可扩展（Bit-scalable）深度哈希 (Zhang et al., 2015)</li><li>DH：深度哈希，压缩二进制编码学习 (Liong et al., 2015)</li><li>二进制编码学习深度哈希 (Lin et al., 2015a)</li><li>DPSH：基于特征学习的使用 pairwise 标签的深度监督哈希 (Li et al., 2015)</li></ul><h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>量化阶段和投影阶段一样重要。</p><ul><li>DBQ：双位（Double-bit）量化 (Kong and Li, 2012a)</li><li>MQ：曼哈顿（Manhattan）量化 (Kong et al., 2012)</li><li>VBQ：可变位（Variable bit quantization）量化 (Moran et al., 2013)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;http://cs.nju.edu.cn/lwj/slides/L2H.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Learning to Hash for Big Data: A Tutorial&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h3&gt;&lt;h4 id=&quot;大数据中的最近邻搜索&quot;&gt;&lt;a href=&quot;#大数据中的最近邻搜索&quot; class=&quot;headerlink&quot; title=&quot;大数据中的最近邻搜索&quot;&gt;&lt;/a&gt;大数据中的最近邻搜索&lt;/h4&gt;&lt;p&gt;最近邻搜索（Nearest Neighbor Search）：给定查询点 q，返回数据库中距离 q 最近（最相似）的点集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facebook：7.5 亿用户&lt;/li&gt;
&lt;li&gt;Flickr：6 千万照片&lt;/li&gt;
&lt;li&gt;Wal-Mart: 每天 2.67 亿商品；4PB 数据仓库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%B2%E9%9A%86%E6%95%B8%E4%BD%8D%E5%B7%A1%E5%A4%A9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sloan Digital Sky Survery&lt;/a&gt;：新墨西哥州望远镜每天获取 200GB 图像数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa README 笔记</title>
    <link href="http://stormluke.me/reactive-cocoa-readme/"/>
    <id>http://stormluke.me/reactive-cocoa-readme/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md" target="_blank" rel="external">ReactiveCocoa/README.md</a></p><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">FRP</a></p><blockquote><p>事件流</p></blockquote><ul><li><code>Signal</code></li><li><code>SignalProducer</code></li></ul><a id="more"></a><p>用来统一这些模式：</p><ul><li>Delegate methods</li><li>Callback blocks</li><li><code>NSNotification</code>s</li><li>Control actions and responder chain events</li><li>Futures and promises</li><li>Key-value observing (KVO)</li></ul><h3 id="例子-在线搜索"><a href="#例子-在线搜索" class="headerlink" title="例子: 在线搜索"></a>例子: 在线搜索</h3><h4 id="观察文本的编辑"><a href="#观察文本的编辑" class="headerlink" title="观察文本的编辑"></a>观察文本的编辑</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchStrings = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div></pre></td></tr></table></figure><p>这样获取到一个发送 <code>String</code> 类型的 <code>SignalProducer</code>。为了支持 Objective-C 的 extension 方法，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2182" target="_blank" rel="external">目前 <code>as!</code> 是必须的</a>。</p><h4 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchResults = searchStrings</div><div class="line">    .flatMap(.<span class="type">Latest</span>) &#123; (query: <span class="type">String</span>) -&gt; <span class="type">SignalProducerNSData</span>, <span class="type">NSURLResponse</span>), <span class="type">NSError</span>&gt; <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> <span class="type">URLRequest</span> = <span class="keyword">self</span>.searchRequestWithEscapedQuery(query)</div><div class="line">        <span class="keyword">return</span> <span class="type">NSURLSession</span>.sharedSession().rac_dataWithRequest(<span class="type">URLRequest</span>)</div><div class="line">    &#125;</div><div class="line">    .<span class="built_in">map</span> &#123; (data, <span class="type">URLResponse</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> string = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)!</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.parseJSONResultsFromString(string)</div><div class="line">    &#125;</div><div class="line">    .observeOn(<span class="type">UIScheduler</span>())</div></pre></td></tr></table></figure><ul><li><code>observeOn(UIScheduler())</code> 在主线程上推送结果</li><li><code>flatMap(.Latest)</code> 保证只有最后一个网络请求是活动的</li></ul><h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>上面的代码并没有开始“运行”。直到下面这句话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">searchResults.startWithNext &#123; results <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"Search results: \(results)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>观察 <code>Next</code> 事件并处理。</p><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>在这个例子里，任何网络错误会生成 <code>Failed</code> 事件，并且会终止事件流。但上面的代码并没有处理。修复一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.flatMap(.<span class="type">Latest</span>) &#123; (query: <span class="type">String</span>) -&gt; <span class="type">SignalProducerNSData</span>, <span class="type">NSURLResponse</span>), <span class="type">NSError</span>&gt; <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> <span class="type">URLRequest</span> = <span class="keyword">self</span>.searchRequestWithEscapedQuery(query)</div><div class="line">    <span class="keyword">return</span> <span class="type">NSURLSession</span>.sharedSession()</div><div class="line">        .rac_dataWithRequest(<span class="type">URLRequest</span>)</div><div class="line">        .flatMapError &#123; error <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"Network error occurred: \(error)"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">SignalProducer</span>.empty</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>记录错误日志并且忽略错误。把错误换成了 <code>empty</code> 事件流。</p><p>如果出错则重试似乎更好，巧的是，确实有个 <code>retry</code> 算子。</p><h4 id="限流请求"><a href="#限流请求" class="headerlink" title="限流请求"></a>限流请求</h4><p>只想在用户停止输入后执行搜索以减少流量。ReactiveCocoa 有个 <code>throttle</code> 算子。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchStrings = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div></pre></td></tr></table></figure><h4 id="调试事件流"><a href="#调试事件流" class="headerlink" title="调试事件流"></a>调试事件流</h4><p>事件的栈轨迹会是一大坨，让调试很恶心。一种 navie 的调试方法是给流注入副作用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchString = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div><div class="line">    .on(event: &#123; <span class="built_in">print</span> ($<span class="number">0</span>) &#125;) <span class="comment">// the side effect</span></div></pre></td></tr></table></figure><p><code>SignalProducer</code> 和 <code>Signal</code> 提供 <code>logEvents</code> 算子来自动做这件事：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchString = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div><div class="line">    .logEvents()</div></pre></td></tr></table></figure><h3 id="Objective-C-和-Swift"><a href="#Objective-C-和-Swift" class="headerlink" title="Objective-C 和 Swift"></a>Objective-C 和 Swift</h3><p>3.0 版本后所有的重要特性开发都集中在 Swfit API。</p><p>Objective-C API 和 Swift API 完全是分离的，但有<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/ObjectiveCBridging.md" target="_blank" rel="external">桥接方法</a>。</p><h3 id="ReactiveCocoa-和-Rx-的关系？"><a href="#ReactiveCocoa-和-Rx-的关系？" class="headerlink" title="ReactiveCocoa 和 Rx 的关系？"></a>ReactiveCocoa 和 Rx 的关系？</h3><p>ReactiveCocoa <em>故意</em>不是 Rx 的直接移植版。</p><p>RAC 相比于 Rx 主要用于：</p><ul><li>建立更简单的 API</li><li>Address common sources of confusion</li><li>更符合 Cocoa 习惯</li></ul><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>在 Rx 的绝大多数版本里，流被叫做 <code>Observable</code>，是 .NET <code>Enumerable</code> 类型的并行版。另外，Rx.NET 的许多操作的名字来源于 LINQ，主要用于影射关系型数据库，比如 <code>Select</code>、<code>Where</code>。</p><p>RAC 则主要遵循 Swift 命名，比如 <code>map</code>、<code>filter</code>。其他命名的差异一般是来自 Haskell 或 Elm 中明显更好的名字。</p><h4 id="Singles-和-Signal-Producers-“hot”-和-“cold”-observables"><a href="#Singles-和-Signal-Producers-“hot”-和-“cold”-observables" class="headerlink" title="Singles 和 Signal Producers (“hot” 和 “cold” observables)"></a>Singles 和 Signal Producers (“hot” 和 “cold” observables)</h4><p>Rx 里难理解的部分中的一个就是 <a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html" target="_blank" rel="external">“hot”, “cold”, and “warm” observables</a>。</p><p>简单来说，只给出如下的函数声明</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">IObservable</span>&lt;string&gt; <span class="type">Search</span>(string query)</div></pre></td></tr></table></figure><p><strong>不可能</strong>看出订阅这个 <code>IObservable</code> 会不会引入副作用，如果它<em>确实</em>有副作用，也不能看出是否<em>每个订阅</em>会有副作用还是仅仅第一个订阅会有副作用。</p><p>这个例子展示了让 Rx（和 3.0 版前的 ReactiveCocoa）代码难一眼看懂的<strong>真实普遍的问题</strong>。</p><p>ReacitveCocoa 3.0 用 <code>Signal</code> 和 <code>SignalProducer</code> 来区分副作用。</p><p>换句话说，ReactiveCocoa 的改变<a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="external">简约不简单</a>。</p><h4 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h4><p>RAC 允许使用 <code>NoError</code> 来<em>静态保证</em>一个事件流不允许发出异常。<strong>这消除了许多由意外异常事件引发的 bug</strong>。</p><p>在 Rx 里没有错误类型。</p><h4 id="UI-编程"><a href="#UI-编程" class="headerlink" title="UI 编程"></a>UI 编程</h4><p>Rx 一般不知道它如何被使用，尽管用 Rx 来 UI 编程很常见。</p><p>RAC 受到很多来自 ReactiveUI 的启发，比如 <code>Action</code>。</p><p>和 ReactiveUI 不能直接改造 Rx 不同，RAC 为 UI 编程改进了很多次，即使这样会和 Rx 变得越来越不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa/README.md&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_reactive_programming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FRP&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事件流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Signal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SignalProducer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>书单@2016</title>
    <link href="http://stormluke.me/book-list-2016/"/>
    <id>http://stormluke.me/book-list-2016/</id>
    <published>2016-01-22T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<p>书堆的有点多&amp;基本上是专业书。。</p><a id="more"></a><ul><li><em>数学女孩</em></li><li><em>数学女孩 2</em></li><li><a href="https://book.douban.com/subject/26386810/" target="_blank" rel="external">Scala与Clojure函数式编程模式</a></li><li><em>Javascript函数式编程</em></li><li><em>无器械健身</em></li><li><em>大学之路</em></li><li><a href="https://book.douban.com/subject/26583236/" target="_blank" rel="external">七周七Web开发框架</a></li><li><em>硬派健身</em></li><li><em>写给大忙人看的Java SE 8</em></li><li><em>编写可测试的Javascript代码</em></li><li><em>图解机器学习</em></li><li><em>设计思考</em></li><li><em>图解TCP/IP</em></li><li><em>数据科学实战</em></li><li><em>Clojure编程</em></li><li><em>算法的乐趣</em></li><li><em>挑战程序设计竞赛</em></li><li><em>Vim实用技巧</em></li><li><em>Haskell函数式编程基础</em></li><li><em>Pattern Recongnition and Machine Learning</em></li><li><em>The Elements of Statistical Learning</em></li><li><em>算法导论</em></li><li><em>编译原理</em></li><li><em>Machine Learning</em></li><li><em>iOS Auto Layout开发秘籍</em></li><li><em>C++程序设计语言</em></li><li><em>大数据日知录</em></li><li><em>互联网大规模数据挖掘与分布式处理</em></li><li><em>Java虚拟机并发编程</em></li><li><em>超级漫画素描技法</em></li><li><em>编译器设计</em></li><li><em>CPU自制入门</em></li><li><em>数学桥</em></li><li><em>iOS编程实战</em></li><li><em>具体数学</em></li><li><em>OpenGL超级宝典</em></li><li><em>深入理解计算机系统</em></li><li><em>五天学会绘画</em></li><li><em>统计思维</em></li><li><em>概率导论</em></li><li><em>线性代数应该这样学</em></li><li><a href="https://book.douban.com/subject/26337939/" target="_blank" rel="external">七周七并发模型</a></li><li><em>禅与摩托车维修艺术</em></li><li><em>文明之光</em></li><li><em>Ruby元编程</em></li><li><em>设计中的设计</em></li><li><em>只是为了好玩</em></li><li><em>用AngularJS开发下一代Web应用</em></li><li><em>计算机程序的构造和解释</em></li><li><em>编程本色</em></li><li><em>HTTP权威指南</em></li><li><em>算法心得</em></li><li><em>30天学会绘画</em></li><li><em>GEB</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书堆的有点多&amp;amp;基本上是专业书。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蹦床（trampoline）原理</title>
    <link href="http://stormluke.me/trampoline-in-javascript/"/>
    <id>http://stormluke.me/trampoline-in-javascript/</id>
    <published>2015-12-21T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.039Z</updated>
    
    <content type="html"><![CDATA[<p>摘录自 <em>Functional JavaScript</em>。</p><p>来看一个相互递归的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">evenSteven</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> oddJohn(<span class="built_in">Math</span>.abs(n) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">oddJohn</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> evenSteven(<span class="built_in">Math</span>.abs(n) - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个函数相互回弹调用彼此，递减某个绝对值，直到一方到达零为止。这是一个相当优雅的解决方式。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">evenSteven(<span class="number">4</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">oddJohn(<span class="number">11</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>尽管技术上可以实现尾递归的优化，但目前 JavaScript 引擎并不支持。因此在调用以上函数时可能会遇到这个错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">evenSteven(<span class="number">100000</span>);</div><div class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded (or some variant)</span></div></pre></td></tr></table></figure><p>这种错误称为“blowing the stack”，是因为 <code>evenSteven</code> 和 <code>oddJohn</code> 互相调用过多造成了栈溢出。</p><p>可以是用蹦床（trampoline）原理的控制结构来消除这类错误。它的基本原理是，使用蹦床展平调用，而不是深度嵌套的递归调用。</p><p>首先看看如何来手动修复这两个函数使得递归不会溢出。一个方法是返回一个函数，它包装调用，而不是直接调用。可以使用 <code>partial1</code> 来实现这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial1</span>(<span class="params">fun, arg1</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> fun.bind(<span class="literal">undefined</span>, arg1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">这时对应的函数为：</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">` js</span></div><div class="line"><span class="string">function evenOline(n) &#123;</span></div><div class="line"><span class="string">  if (n === 0)</span></div><div class="line"><span class="string">    return true;</span></div><div class="line"><span class="string">  else</span></div><div class="line"><span class="string">    return partial1(oddOline, Math.abs(n) - 1);</span></div><div class="line"><span class="string">&#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">function oddOline(n) &#123;</span></div><div class="line"><span class="string">  if (n === 0)</span></div><div class="line"><span class="string">    return false;</span></div><div class="line"><span class="string">  else</span></div><div class="line"><span class="string">    return partial1(evenOline, Math.abs(n) - 1);</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure><p>这两个函数返回一个包装函数而不是直接进行 <code>evenOline</code> 和 <code>oddOline</code> 的互相调用。调用终止情况时都能正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">evenOline(<span class="number">0</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">oddOline(<span class="number">0</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>现在可以手动调用递归来展平：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">oddOline(<span class="number">3</span>);</div><div class="line"><span class="comment">//=&gt; function() &#123; return evenOline(Math.abs(n) - 1) &#125;</span></div><div class="line">oddOline(<span class="number">3</span>)();</div><div class="line"><span class="comment">//=&gt; function() &#123; return oddOline(Math.abs(n) - 1) &#125;</span></div><div class="line">oddOline(<span class="number">3</span>)()();</div><div class="line"><span class="comment">//=&gt; function() &#123; return evenOline(Math.abs(n) - 1) &#125;</span></div><div class="line">oddOline(<span class="number">3</span>)()()();</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">oddOline(<span class="number">200000001</span>)()()()(); <span class="comment">//... a bunch more ()s</span></div></pre></td></tr></table></figure><p>看起来能用了，但可以提供另外一个函数 <code>trampoline</code>，从程序执行来进行扁平化处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fun <span class="regexp">/*, args */</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = fun.apply(fun, _.rest(<span class="built_in">arguments</span>));</div><div class="line">  <span class="keyword">while</span> (_.isFunction(result)) &#123;</div><div class="line">    result = result();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>trampoline</code> 所做的是不断调用函数的返回值，直到它不再是一个函数。具体是这样工作的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">trampoline(oddOline, <span class="number">3</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">trampoline(evenOline, <span class="number">200000</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">trampoline(oddOline, <span class="number">300000</span>);</div><div class="line"><span class="comment">//=&gt; false</span></div><div class="line">trampoline(evenOline, <span class="number">200000000</span>);</div><div class="line"><span class="comment">// wait a few seconds</span></div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>由于调用链的间接性，使用蹦床增加了相互递归函数的一些开销。然而，慢总比溢出好。如果不想强迫用户使用 <code>trampoline</code>，只是为了避免堆栈溢出，其实也可以隐藏其外观：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEvenSafe</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> trampoline(partial1(oddOline, <span class="built_in">Math</span>.abs(n) - <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOddSafe</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> trampoline(partial1(evenOline, <span class="built_in">Math</span>.abs(n) - <span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>试试能否正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">isOddSafe(<span class="number">2000001</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">idEvenSafe(<span class="number">2000001</span>);</div><div class="line"><span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘录自 &lt;em&gt;Functional JavaScript&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;来看一个相互递归的例子&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;evenSteven&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oddJohn(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.abs(n) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;oddJohn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; evenSteven(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.abs(n) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两个函数相互回弹调用彼此，递减某个绝对值，直到一方到达零为止。这是一个相当优雅的解决方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015.10.16</title>
    <link href="http://stormluke.me/2015-10-16/"/>
    <id>http://stormluke.me/2015-10-16/</id>
    <published>2015-10-15T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.030Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见。</p><p>读到老罗的<a href="http://weibo.com/p/1001603808740469043389" target="_blank" rel="external">骂街文章</a>，正文并没有什么意思，但结尾很棒：</p><a id="more"></a><blockquote><p>最后，我想用<a href="http://www.asa3.org/ASA/education/views/teresa.htm" target="_blank" rel="external">特蕾莎修女写在加尔各答孤儿院上的几句诗</a>和 OpenSSL 共勉：</p><p>“如果你友善，人们可能会说你自私自利，动机不良<br>无论如何，你还是要友善</p><p>如果你诚实坦率，人们可能会欺骗你<br>无论如何，你还是要诚实坦率</p><p>你多年建造的东西，可能被人一夜之间摧毁<br>无论如何，你还是要去建造</p><p>你今天做的善事，明天就会被人们忘记<br>无论如何，你还是要做善事</p><p>即使你把你最好的都给了这个世界，可能还是远远不够<br>无论如何，你还是要把你最好的给这个世界”</p></blockquote><p>愿你我的心一直柔软。纪念日快乐 &lt;3</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不见。&lt;/p&gt;
&lt;p&gt;读到老罗的&lt;a href=&quot;http://weibo.com/p/1001603808740469043389&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;骂街文章&lt;/a&gt;，正文并没有什么意思，但结尾很棒：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应式编程笔记 08</title>
    <link href="http://stormluke.me/reactive-programming-note-08/"/>
    <id>http://stormluke.me/reactive-programming-note-08/</id>
    <published>2015-05-07T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 <code>Observable</code></h2><p>所有的 <code>Observable</code> 工厂方法都是由下面这个派生而来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](s: <span class="type">Observer</span>[<span class="type">T</span>] 􏰀 <span class="type">Subscription</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epy87ziblyj20vw0a9jtb.jpg" alt="Observable.create"></p><p>首先是两个最简单的：<code>never</code> 和 <code>error</code></p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epy8canoq9j20x507zt8z.jpg" alt="never"></p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epy8ddjvggj20xd07q74o.jpg" alt="error"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">never</span></span>(): <span class="type">Observable</span>[<span class="type">Nothing</span>] = <span class="type">Observable</span>[<span class="type">Nothing</span>](observer =&gt;􏰀 &#123;</div><div class="line">  <span class="type">Subscription</span> &#123;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](error: <span class="type">Throwable</span>): <span class="type">Observable</span>[<span class="type">T</span>] =</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer 􏰀=&gt; &#123;</div><div class="line">    observer.onError(error)</div><div class="line">    <span class="type">Subscription</span> &#123;&#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>然后是 <code>startWith</code>，它能在流之前添加元素：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epy8gethuwj20t70dwwgo.jpg" alt="startWith"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">startWith</span></span>(ss: <span class="type">T</span>*): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer 􏰀=&gt; &#123;</div><div class="line">    <span class="keyword">for</span>(s &lt;- ss) observer.onNext(s)</div><div class="line">    subscribe(observer)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>filter</code>：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epy8j13td9j20q10d275n.jpg" alt="filter"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> 􏰀=&gt; <span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer 􏰀=&gt; &#123;</div><div class="line">    subscribe (</div><div class="line">      (t: <span class="type">T</span>) 􏰀=&gt; &#123; <span class="keyword">if</span>(p(t)) observer.onNext(t) &#125;,</div><div class="line">      (e: <span class="type">Throwable</span>) 􏰀=&gt; &#123; observer.onError(e) &#125;,</div><div class="line">      () 􏰀=&gt; &#123; observer.onCompleted() &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>map</code>：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epy8lchhfcj20qd0d0jt9.jpg" alt="map"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> 􏰀=&gt; <span class="type">S</span>): <span class="type">Observable</span>[<span class="type">S</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">S</span>](observer 􏰀=&gt; &#123;</div><div class="line">    subscribe (</div><div class="line">      (t: <span class="type">T</span>) =&gt; &#123; observer.onNext(f(t)) &#125;,</div><div class="line">      (e: <span class="type">Throwable</span>) =&gt; &#123; observer.onError(e) &#125;,</div><div class="line">      () =&gt; &#123; observer.onCompleted() &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和 <code>Iterable</code> 的 <code>map</code> 对比下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>): <span class="type">Iterable</span>[<span class="type">S</span>] = &#123;</div><div class="line">  <span class="keyword">new</span> <span class="type">Iterable</span>[<span class="type">S</span>] &#123;</div><div class="line">    <span class="keyword">val</span> it = <span class="keyword">this</span>.iterator()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>: <span class="type">Iterator</span>[<span class="type">S</span>] = <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">S</span>] &#123;</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = &#123; it.hasNext &#125;</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">S</span> = &#123; f(it.next()) &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a><code>Subject</code></h2><p>现在想将一个 <code>Future[T]</code> 转化成 <code>Observable[T]</code>：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epy8qf2k1xj20su0ep75a.jpg" alt="future-to-observable"></p><p>为了要达成这个目的，需要引入一个新类型：<code>Subject</code>。回顾下 <code>Promise</code> 是如何做的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">S</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">S</span>]()</div><div class="line">  onComplete &#123;</div><div class="line">    <span class="keyword">case</span> result =&gt; &#123;... p.complete(<span class="type">E</span>) ...&#125;</div><div class="line">  &#125;(executor)</div><div class="line">  p.future</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当在 <code>Promise</code> 上调用 <code>complete</code> 时，<code>Promise</code> 会调用内部的 <code>Future</code> 上的 <code>onComplete</code>：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epy8y1okjwj20yk0c2abn.jpg" alt="promise"></p><p><code>Subject[T]</code> 和 <code>Promise[T]</code> 所担任的角色类似，它同时包含 <code>Observer[T]</code> 和 <code>Observable[T]</code>，既可以在 <code>Observer[T]</code> 上调用 <code>onNext</code> 等方法，也能 <code>subscribe</code> 一个 <code>Observable[T]</code>。可以说 <code>Subject</code> 让 Cold Observable 变成了 Hot Observable：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epyagmpawdj20yi0gn41q.jpg" alt="subject"></p><p>来看几个不同类型的 <code>Subject</code> 的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = <span class="type">PublishSubject</span>[<span class="type">Int</span>]()</div><div class="line"><span class="keyword">val</span> a = channel.subscribe(x =&gt; println(<span class="string">"a: "</span>+x))</div><div class="line"><span class="keyword">val</span> b = channel.subscribe(x =&gt; println(<span class="string">"b: "</span>+x)) channel.onNext(<span class="number">42</span>)</div><div class="line">a.unsubscribe()</div><div class="line">channel.onNext(<span class="number">4711</span>)</div><div class="line">channel.onCompleted()</div><div class="line"><span class="keyword">val</span> c = channel.subscribe(x􏰀println(<span class="string">"c: "</span>+x))</div><div class="line">channel.onNext(<span class="number">13</span>)</div><div class="line"><span class="comment">// a: 42; b:42, 4711, !; c: !</span></div></pre></td></tr></table></figure><p><code>PublishSubject</code> 是基础行为的 <code>Subject</code>，当订阅一个已经停止的 <code>PublishSubject</code> 时，会直接收到 <code>onCompleted()</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = <span class="type">ReplaySubject</span>[<span class="type">Int</span>]()</div><div class="line"><span class="keyword">val</span> a = channel.subscribe(x =&gt; println(<span class="string">"a: "</span>+x))</div><div class="line"><span class="keyword">val</span> b = channel.subscribe(x =&gt; println(<span class="string">"b: "</span>+x))</div><div class="line">channel.onNext(<span class="number">42</span>)</div><div class="line">a.unsubscribe()</div><div class="line">channel.onNext(<span class="number">4711</span>)</div><div class="line">channel.onCompleted()</div><div class="line"><span class="keyword">val</span> c = channel.subscribe(x􏰀println(<span class="string">"c: "</span>+x))</div><div class="line">channel.onNext(<span class="number">13</span>)</div><div class="line"><span class="comment">// a: 42; b: 42, 4711, !; c: 42, 4711, !</span></div></pre></td></tr></table></figure><p><code>ReplaySubject</code> 会缓存所有元素，当订阅一个已经停止的 <code>ReplaySubject</code> 时，会收到所有的元素。</p><p>还用两种 <code>Subject</code>，一个是 <code>BehaviorSubject</code>，它会缓存最后一个元素，当订阅一个已经停止的 <code>BehaviorSubject</code> 时，会收到最后一个元素；另一个是 <code>AsyncSubject</code>，它也会缓存最后一个元素，但不论何时订阅，都只能收到最后一个元素。下面是它们的对比图：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epyavfalrgj20yq0gmdiy.jpg" alt="subjects"></p><p>练习：</p><p>下面这段代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = <span class="type">AsyncSubject</span>[<span class="type">Int</span>]()</div><div class="line"><span class="keyword">val</span> a = channel.subscribe(x =&gt; println(<span class="string">"a: "</span>+x))</div><div class="line"><span class="keyword">val</span> b = channel.subscribe(x =&gt; println(<span class="string">"b: "</span>+x))</div><div class="line">channel.onNext(<span class="number">42</span>)</div><div class="line">a.unsubscribe()</div><div class="line">channel.onNext(<span class="number">4711</span>)</div><div class="line">channel.onCompleted()</div><div class="line"><span class="keyword">val</span> c = channel.subscribe(x􏰀println(<span class="string">"c: "</span>+x))</div><div class="line">channel.onNext(<span class="number">13</span>)</div></pre></td></tr></table></figure><p>哪个频道输出是正确的？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a: <span class="number">4711</span>, !</div><div class="line">b: <span class="number">42</span>, <span class="number">4711</span>, !</div><div class="line">b: <span class="number">4711</span>, !</div></pre></td></tr></table></figure><p>答案是 b 频道。</p><p>于是就可以这样来将 <code>Future[T]</code> 转化成 <code>Observable[T]</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](f: <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> subject = <span class="type">AsyncSubject</span>[<span class="type">T</span>]()</div><div class="line">    f onComplete &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Failure</span>(e) 􏰀 &#123; subject.onError(e) &#125;</div><div class="line">      <span class="keyword">case</span> <span class="type">Success</span>(c) 􏰀 &#123; subject.onNext(c); subject.onCompleted() &#125;</div><div class="line">    &#125;</div><div class="line">    subject</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a><code>Notification</code></h2><p>想显式处理流中的错误怎么办？可以用 <code>Notification</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Try</span>[+<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Success</span>[<span class="type">T</span>](<span class="params">elem: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Failure</span>(<span class="params">t: <span class="type">Throwable</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">abstract</span> <span class="title">class</span> <span class="title">Notification</span>[+<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">OnNext</span>[<span class="type">T</span>](<span class="params">elem: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">OnError</span>(<span class="params">t: <span class="type">Throwable</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">OnCompleted</span> <span class="keyword">extends</span> <span class="title">Notification</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">def</span> <span class="title">materialize</span></span>: <span class="type">Observable</span>[<span class="type">Notification</span>[<span class="type">T</span>]] = &#123; ... &#125;</div></pre></td></tr></table></figure><p>弹子图如下：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epybkdyh2qj20r20dr0ub.jpg" alt="Notification"></p><h2 id="阻塞-Observable"><a href="#阻塞-Observable" class="headerlink" title="阻塞 Observable"></a>阻塞 <code>Observable</code></h2><p>可以通过 <code>Observable.toBlockingObservable()</code> 或者 <code>BlockingObservable.from()</code> 方法将非阻塞的 <code>Observable</code> 变为阻塞的。但应注意 Rx 中所有的操作都是非阻塞的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> second).take(<span class="number">5</span>)</div><div class="line"><span class="keyword">val</span> ys: <span class="type">List</span>[<span class="type">Long</span>] = xs.toBlockingObservable.toList</div><div class="line">println(ys)</div><div class="line">println(<span class="string">"bye"</span>)</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Long</span>] = xs.sum</div><div class="line"><span class="keyword">val</span> s: <span class="type">Long</span> = zs.toBlockingObservable.single</div></pre></td></tr></table></figure><h2 id="归约-Observable"><a href="#归约-Observable" class="headerlink" title="归约 Observable"></a>归约 <code>Observable</code></h2><p>可以使用 <code>reduce</code> 方法来创建标量 <code>Observable</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(f: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epyhpkrhd1j20rb0ec760.jpg" alt="reduce"></p><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a><code>Scheduler</code></h2><p>如何设计一个将 <code>Iterable</code> 转变成 <code>Observable</code> 的函数？这个 <code>from</code> 函数要支持无限流，并且能取消订阅：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1epzsukxgj6j20ty0exq51.jpg" alt="from"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>]) : <span class="type">Observable</span>[<span class="type">T</span>] = &#123; ... &#125;</div><div class="line"><span class="keyword">val</span> infinite: <span class="type">Iterable</span>[<span class="type">Int</span>] = nats()</div><div class="line"><span class="keyword">val</span> subscription = from(infinite). subscribe(x =&gt; println(x))</div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure><p>注意 <code>Iterable</code> 是懒求值的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nats</span></span>(): <span class="type">Iterable</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Iterable</span>[<span class="type">Int</span>] &#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">-1</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>: <span class="type">Iterator</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">Int</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = &#123; <span class="literal">true</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">Int</span> = &#123; i +=<span class="number">1</span>; i &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于流可能是无限的，直接用 <code>foreach</code> 不行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>]) : <span class="type">Observable</span>[<span class="type">T</span>] = &#123; <span class="type">Observable</span>(observer =&gt; &#123;</div><div class="line">seq.foreach(s =&gt; observer.onNext(s)) observer.onCompleted()</div><div class="line">  <span class="comment">// we never get here</span></div><div class="line">  <span class="type">Subscription</span>&#123;&#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> infinite: <span class="type">Iterable</span>[<span class="type">Integer</span>] = nats()</div><div class="line"><span class="keyword">val</span> subscription = from(infinite).subscribe(x =&gt; println(x))</div><div class="line"><span class="comment">// hence we never get here</span></div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure><p>必须在其他的线程中执行生成器，这时就需要 <code>Scheduler</code> 了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: =&gt;<span class="type">Unit</span>): <span class="type">Subscription</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> scheduler = <span class="type">Scheduler</span>.<span class="type">NewThreadScheduler</span></div><div class="line"><span class="keyword">val</span> subscription = scheduler.schedule &#123;</div><div class="line">  println(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <code>Scheduler</code> 中使用 <code>foreach</code> 虽然不会阻塞当前线程，但不能取消订阅：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer =&gt; &#123;</div><div class="line">    scheduler.schedule &#123;</div><div class="line">      seq.foreach(s ⇒ observer.onNext(s))</div><div class="line">      observer.onCompleted()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要演化出两个更精细的控制方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: =&gt;<span class="type">Unit</span>): <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: <span class="type">Scheduler</span>=&gt;<span class="type">Subscription</span>): <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: (=&gt;<span class="type">Unit</span>)=&gt;<span class="type">Unit</span>): <span class="type">Subscription</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这次就没问题了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> it = seq.iterator()</div><div class="line">    scheduler.schedule(self =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (it.hasnext) &#123; observer.onNext(it.next()); self() &#125;</div><div class="line">      <span class="keyword">else</span> &#123; observer.onCompleted() &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (it.hasnext) &#123; observer.onNext(it.next()); self() &#125;</div></pre></td></tr></table></figure><p>的调用过程大概是这样：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1epzt8u4pkdj20vk0e2dim.jpg" alt="self-call"></p><p>那么 <code>schedule</code> 到底是如何定义的呢？如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: (=&gt;<span class="type">Unit</span>)=&gt;<span class="type">Unit</span>): <span class="type">Subscription</span> = &#123;</div><div class="line">  <span class="keyword">val</span> subscription = <span class="keyword">new</span> <span class="type">MultipleAssignmentSubscription</span>();</div><div class="line">  schedule(scheduler =&gt; &#123;</div><div class="line">    loop(scheduler, work, subscription);</div><div class="line">    subscription;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(s: <span class="type">Scheduler</span>, w: (=&gt;<span class="type">Unit</span>)=&gt;<span class="type">Unit</span>), m: <span class="type">MultipleAssignmentSubscription</span>): <span class="type">Unit</span> = &#123;</div><div class="line">   m.<span class="type">Subscription</span> = s.schedule &#123; w &#123; loop(s, w, m) &#125; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>把 <code>loop</code> 整理到 <code>schedule</code> 内部，就变成了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: (⇒<span class="type">Unit</span>)⇒<span class="type">Unit</span>): <span class="type">Subscription</span> = &#123;</div><div class="line">  <span class="keyword">val</span> subscription = <span class="keyword">new</span> <span class="type">MultipleAssignmentSubscription</span>()</div><div class="line">  schedule(scheduler =&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">      subscription.<span class="type">Subscription</span> = scheduler.schedule &#123;</div><div class="line">        work &#123; loop() &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    loop()</div><div class="line">    subscription</div><div class="line">   &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在想将 <code>Scheduler</code> 转化成 <code>Observable[Unit]</code>，实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>()(<span class="keyword">implicit</span> scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">Unit</span>] = &#123;</div><div class="line">    <span class="type">Observable</span>(observer =&gt; &#123;</div><div class="line">      scheduler.schedule(self =&gt; &#123;</div><div class="line">          observer.<span class="type">OnNext</span>(())</div><div class="line">          self()</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> scheduler = <span class="type">Scheduler</span>.<span class="type">NewThreadScheduler</span></div><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Unit</span>] = <span class="type">Observable</span>()</div></pre></td></tr></table></figure><h2 id="Rx-约定"><a href="#Rx-约定" class="headerlink" title="Rx 约定"></a>Rx 约定</h2><p><code>subscribe</code> 的实现可以概括成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">Observer</span>[<span class="type">T</span>]=&gt;<span class="type">Subscription</span>) = <span class="keyword">new</span> <span class="type">Observable</span>[<span class="type">T</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span></span>(o: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Subscription</span> = &#123; <span class="type">Magic</span>(s(o)) &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是说</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="type">Observable</span>(o=&gt;<span class="type">F</span>(o)).subscribe(observer)</div></pre></td></tr></table></figure><p>在概念上和</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="type">Magic</span>(<span class="type">F</span>(observer))</div></pre></td></tr></table></figure><p>相同。<code>Magic</code> 所做的工作是当在 <code>F</code> 中调用 <code>observer.onCompleted</code> 或 <code>observer.onError</code> 时，它会取消 <code>s</code> 的订阅。</p><p>就是说，流只能以多个 <code>onNext</code> 后接零个或多个 <code>onCompleted</code> 或 <code>onError</code> 构成。这是 Rx 的约定，表示为 <code>(onNext)*(onCompleted+onError)?</code>。</p><p>注意，绝不要自己实现 <code>Observable[T]</code> 或 <code>Observer[T]</code>，而应该始终使用 <code>Observable(...)</code> 和 <code>Observer(...)</code> 工厂方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建-Observable&quot;&gt;&lt;a href=&quot;#创建-Observable&quot; class=&quot;headerlink&quot; title=&quot;创建 Observable&quot;&gt;&lt;/a&gt;创建 &lt;code&gt;Observable&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;所有的 &lt;code&gt;Observable&lt;/code&gt; 工厂方法都是由下面这个派生而来：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Observable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;](s: &lt;span class=&quot;type&quot;&gt;Observer&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;] 􏰀 &lt;span class=&quot;type&quot;&gt;Subscription&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Observable&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应式编程笔记 07</title>
    <link href="http://stormluke.me/reactive-programming-note-07/"/>
    <id>http://stormluke.me/reactive-programming-note-07/</id>
    <published>2015-05-06T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Future-T-和-Try-T-是对偶（dual）"><a href="#Future-T-和-Try-T-是对偶（dual）" class="headerlink" title="Future[T] 和 Try[T] 是对偶（dual）"></a><code>Future[T]</code> 和 <code>Try[T]</code> 是<a href="http://en.wikipedia.org/wiki/Dual_%28category_theory%29" target="_blank" rel="external">对偶（dual）</a></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">OnComplete</span></span>[<span class="type">U</span>](func: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">U</span>)(<span class="keyword">implicit</span> ex: <span class="type">ExecutionContext</span>): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>对 <code>OnComplete</code> 方法的类型进行化简（<code>U</code> 化简为 <code>Unit</code>），得到</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p>翻转这个类型，得到</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Unit</span> =&gt; (<span class="type">Unit</span> =&gt; <span class="type">Try</span>[<span class="type">T</span>])</div></pre></td></tr></table></figure><p>继续简化，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; Try[T]) ≈ Try[T]</div></pre></td></tr></table></figure><p>可以看出，对方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span></span>(): <span class="type">Future</span>[<span class="type">T</span>] = &#123; ... &#125;</div></pre></td></tr></table></figure><p>传递回调（<code>Try[T] =&gt; Unit</code>）得到 <code>Try[T]</code>，而方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span></span>(): <span class="type">Try</span>[<span class="type">T</span>] = &#123; ... &#125;</div></pre></td></tr></table></figure><p>一直阻塞直到返回 <code>Try[T]</code>。</p><h3 id="同步数据流：Iterable-T"><a href="#同步数据流：Iterable-T" class="headerlink" title="同步数据流：Iterable[T]"></a>同步数据流：<code>Iterable[T]</code></h3><p>这是 Scala 所有集合类型的基 trait，它定义了一个迭代器方法来一个一个地遍历集合中的元素。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterable</span>[<span class="type">T</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(): <span class="type">Iterator</span>[<span class="type">T</span>] &#125;</div></pre></td></tr></table></figure><p>迭代器是用来遍历序列元素的数据结构。它有个 <code>hasNext</code> 方法来检测下一个元素是否存在，还有个 <code>next</code> 方法来返回下一个元素。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span>[<span class="type">T</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span>; <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span> &#125;</div></pre></td></tr></table></figure><p>画成图是这样：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx0gia2dkj20vu0ecdha.jpg" alt="Iterable"></p><p>操作 <code>Iterable[T]</code> 的高阶函数有这些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">Iterable</span>[<span class="type">B</span>]): <span class="type">Iterable</span>[<span class="type">B</span>] <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">Iterable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeWhile</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>(): <span class="type">List</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">B</span>](that: <span class="type">Iterable</span> [<span class="type">B</span>]): <span class="type">Iterable</span>[(<span class="type">A</span>, <span class="type">B</span>)]</div></pre></td></tr></table></figure><p>这是一个单子。</p><p>常常用弹子图（Marble Diagram）来描述这种类型。</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx0p5e16yj20t10ehach.jpg" alt="Marble Diagram"></p><p>如果将不同命令的执行时间放大到人类级别，将会是这样：</p><p><a href="http://norvig.com/21-days.html#answers" target="_blank" rel="external"><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx0y76ydrj20s90flq6y.jpg" alt="Timings on human scale"></a></p><p>这时用 <code>Iterator</code> 从磁盘中读取文件会让程序阻塞很长时间：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadLinesFromDisk</span></span>(path: <span class="type">String</span>): <span class="type">Iterator</span>[<span class="type">String</span>] = &#123;</div><div class="line">  <span class="type">Source</span>.fromFile(path).getLines()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> lines = <span class="type">ReadLinesFromDisk</span>(<span class="string">"\c:\tmp.txt"</span>)</div><div class="line"><span class="keyword">for</span> (line </div><div class="line">  ... <span class="type">DoWork</span>(line) ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 weeks per line.</span></div></pre></td></tr></table></figure><p>现在用之前的对偶化技巧将拉（pull）模型转化为推（push）模型。</p><p>第零步，化简。将之前的签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(): <span class="type">Iterator</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抽象出类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; <span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]])</div></pre></td></tr></table></figure><ul><li><code>() =&gt; ( ... )</code> 由 <code>iterator()</code> 而来，</li><li><code>() =&gt; Try[Option[T]]</code> 由 <code>next()</code> 而来，</li><li><code>Option</code> 表示了 <code>hasNext</code>，</li><li><code>Try</code> 显式化了错误。</li></ul><p>第一步，翻转。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; <span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]])</div></pre></td></tr></table></figure><p>翻转为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p>第二步，化简。将组合在一起的类型拆分为三个：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">( <span class="type">T</span> =&gt; <span class="type">Unit</span>,</div><div class="line">  <span class="type">Throwable</span> =&gt; <span class="type">Unit</span>,</div><div class="line">  () =&gt; <span class="type">Unit</span></div><div class="line">) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p>第三步，复杂化。得出对应的签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Subscribe</span></span>(observer: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Subscription</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observer</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onNext</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onError</span></span>(error: <span class="type">Throwable</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onCompleted</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过对比可发现 <code>Iterable[T]</code> 和 <code>Observable[T]</code> 是对偶。</p><h3 id="对比-Future-和-Observable"><a href="#对比-Future-和-Observable" class="headerlink" title="对比 Future 和 Observable"></a>对比 <code>Future</code> 和 <code>Observable</code></h3><p>首先看签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">Observable</span>[<span class="type">T</span>] = (<span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div><div class="line"><span class="type">Future</span>[<span class="type">T</span>]     = (<span class="type">Try</span>[      [<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p><code>Observable[T]</code> 多了 <code>Option</code>，这使其可以处理多次数据。</p><p>并发方面有什么不同呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt; <span class="type">T</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">observeOn</span></span>(scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Future</code> 只执行一次，仅需要当前线程相关的 <code>ExecutionContext</code>，而 <code>Observable</code> 执行多次，需要一个 <code>Scheduler</code> 来控制。</p><h3 id="Observable-基础"><a href="#Observable-基础" class="headerlink" title="Observable 基础"></a><code>Observable</code> 基础</h3><p>来看一个使用 <code>Observable</code> 的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> seconds)</div><div class="line"><span class="keyword">val</span> evens: <span class="type">Observable</span>[<span class="type">Long</span>] = ticks.filter(s=&gt;s%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line"><span class="keyword">val</span> bufs: <span class="type">Observable</span>[<span class="type">Seq</span>[<span class="type">Long</span>]] = ticks.buffer(<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> s = bufs.subscribe(b=&gt;printLn(b))</div><div class="line">readLine()</div><div class="line">s.unscubscribe()</div></pre></td></tr></table></figure><p>分步执行如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> seconds)</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx1vfkdbzj20qo02kwer.jpg" alt="Observable-eg-01"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> evens: <span class="type">Observable</span>[<span class="type">Long</span>] = ticks.filter(s=&gt;s%<span class="number">2</span>==<span class="number">0</span>)</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx1vrs8z6j20qi02kmxi.jpg" alt="Observable-eg-02"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bufs: <span class="type">Observable</span>[<span class="type">Seq</span>[<span class="type">Long</span>]] = ticks.buffer(<span class="number">2</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx1xgfogjj20qq02x3yx.jpg" alt="Observable-eg-03"></p><p>练习：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs = <span class="type">Observable</span>.range(<span class="number">1</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure><p>的弹子图如下：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epx205cuvoj20qq02maac.jpg" alt="range"></p><p>那么</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ys = xs.map(x =&gt; x + <span class="number">1</span>)</div></pre></td></tr></table></figure><p>的弹子图是什么？</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx20fkytoj20zp0asac4.jpg" alt="options"></p><p>答案是 B。</p><h3 id="Observable-上的组合子"><a href="#Observable-上的组合子" class="headerlink" title="Observable 上的组合子"></a><code>Observable</code> 上的组合子</h3><p>操作 <code>Observable[T]</code> 的高阶函数有这些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">Observable</span>[<span class="type">B</span>]): <span class="type">Observable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">Observable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeWhile</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>(): <span class="type">List</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">B</span>](that: <span class="type">Observable</span>[<span class="type">B</span>]): <span class="type">Observable</span>[(<span class="type">A</span>, <span class="type">B</span>)]</div></pre></td></tr></table></figure><p>其中 <code>map</code> 的弹子图是：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx3yeqsnaj20th0ehdi5.jpg" alt="map"></p><p><code>flatMap</code> 定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(f: <span class="type">T</span>=&gt;<span class="type">Observable</span>[<span class="type">S</span>]): <span class="type">Observable</span>[<span class="type">S</span>] = &#123; map(f).flatten() &#125;</div></pre></td></tr></table></figure><p>其弹子图为：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx416dmvkj20zq0e6acj.jpg" alt="flatMap"></p><p>有两种扁平化叠套流的方法，一种是 <code>flatten</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Int</span>] = <span class="type">Observable</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> yss: <span class="type">Observable</span>[<span class="type">Observable</span>[<span class="type">Int</span>]] =</div><div class="line">   xs.map(x =&gt; <span class="type">Observable</span>.<span class="type">Interval</span>(x seconds).map(_=&gt;x).take(<span class="number">2</span>))</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Int</span>] = yss.flatten()</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx45oxj4rj20z80aigna.jpg" alt="flatten"></p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx478ezznj20t60htmzd.jpg" alt="merge"></p><p>另一种是 <code>concat</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Int</span>] = <span class="type">Observable</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> yss: <span class="type">Observable</span>[<span class="type">Observable</span>[<span class="type">Int</span>]] =</div><div class="line">   xs.map(x =&gt; <span class="type">Observable</span>.<span class="type">Interval</span>(x seconds).map(_=&gt;x).take(<span class="number">2</span>))</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Int</span>] = yss.concat()</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx492aeysj20ys0ah0uk.jpg" alt="concat-eg"></p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx49b2cuuj20t20hpdib.jpg" alt="concat"></p><p>下面通过一个处理地震通知的例子来展示如何映射和过滤异步的数据流。定义基本的结构如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">usgs</span></span>(): <span class="type">Observable</span>[<span class="type">EarthQuake</span>] = &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EarthQuake</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">magnitude</span></span>: <span class="type">Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">location</span></span>: <span class="type">GeoCoordinate</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Magnitude</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(magnitude: <span class="type">Double</span>): <span class="type">Magnitude</span> = &#123; ... &#125;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Magnitude</span> </span>= <span class="type">Value</span></div><div class="line">  <span class="keyword">val</span> <span class="type">Micro</span>, <span class="type">Minor</span>, <span class="type">Light</span>, <span class="type">Moderate</span>, <span class="type">Strong</span>, <span class="type">Major</span>, <span class="type">Great</span> = <span class="type">Value</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用起来大概是这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> quakes = usgs()</div><div class="line"><span class="keyword">val</span> major = quakes</div><div class="line">  .map(q=&gt;(q.<span class="type">Location</span>, <span class="type">Magnitude</span>(q.<span class="type">Magnitude</span>)))</div><div class="line">  .filter&#123; <span class="keyword">case</span> (loc,mag) =&gt; mag &gt;= <span class="type">Major</span> &#125;</div><div class="line">major.subscribe(&#123; <span class="keyword">case</span> (loc, mag) =&gt; &#123;</div><div class="line">  println($<span class="string">"Magnitude $&#123; mag &#125; quake at $&#123; loc &#125;"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>现在想通过网络将地震处的地理坐标转换为国家信息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseGeocode</span></span>(c: <span class="type">GeoCoordinate</span>): <span class="type">Future</span>[<span class="type">Country</span>] = &#123; ... &#125;</div><div class="line"><span class="keyword">val</span> withCountry: <span class="type">Observable</span>[<span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]] =</div><div class="line">  usgs().map(quake =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> country: <span class="type">Future</span>[<span class="type">Country</span>] = reverseGeocode(q.<span class="type">Location</span>)</div><div class="line">    <span class="type">Observable</span>(country.map(country=&gt;(quake,country)))</div><div class="line">  &#125;)</div><div class="line"><span class="comment">// This</span></div><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.flatten()</div><div class="line"><span class="comment">// Or this?</span></div><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.concat()</div></pre></td></tr></table></figure><p>那么问题来了，该用 <code>flatten</code> 还是 <code>concat</code>？如果用 <code>flatten</code>：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4ru2yr7j20vu0fvjtc.jpg" alt="geo-flatten"></p><p>最终收到地震消息的顺序会因为反向解析的延迟而出现错乱，而如果用 <code>concat</code> 则没问题：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4trgmxqj210v0eyq54.jpg" alt="geo-concat"></p><p>看一个新函数 <code>groupBy</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](keySelector: <span class="type">T</span>=&gt;<span class="type">K</span>): <span class="type">Observable</span>[(<span class="type">K</span>,<span class="type">Observable</span>[<span class="type">T</span>])]</div></pre></td></tr></table></figure><p>它的弹子图为：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4v4pqr0j20pp0f8dhn.jpg" alt="groupBy"></p><p>原序列元素根据形状分为了两组，最终产生了三个数据流。</p><p>现在想让收到的地震信息根据国家不同而分类，可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.flatten()</div><div class="line"><span class="keyword">val</span> byCountry: <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]] =</div><div class="line">  merged.groupBy&#123; <span class="keyword">case</span> (q,c) =&gt; c &#125;</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx4ylfq96j20xx0a3gmt.jpg" alt="group-eg"></p><p>练习：</p><p>若想统计不同国家发生地震的平均次数，部分代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> byCountry: <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runningAverage</span></span>(s : <span class="type">Observable</span>[<span class="type">Double</span>]): <span class="type">Observable</span>[<span class="type">Double</span>] = &#123;...&#125;</div><div class="line"><span class="keyword">val</span> runningAveragePerCountry : <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[<span class="type">Double</span>])]</div></pre></td></tr></table></figure><p>那么 <code>runningAveragePerCountry</code> 的实现应该是什么？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, quakes) =&gt; (country, runningAverage(quakes))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// b)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, quakes) =&gt; (country, runningAverage(quakes.map(_.<span class="type">Magnitude</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// c)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, cqs) =&gt; (country, runningAverage(cqs.map(_._1.<span class="type">Magnitude</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据类型匹配的原则可以得出答案为 C。</p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>如何取消订阅呢？这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> quakes: <span class="type">Observable</span>[<span class="type">EarthQuake</span>] = ...</div><div class="line"><span class="keyword">val</span> s: <span class="type">Subscription</span> = quakes.<span class="type">Subscribe</span>(...)</div><div class="line">s.unsubscribe()</div></pre></td></tr></table></figure><p><code>Observable</code> 可分为两种，一种称为 Hot Observable，所有的订阅者共享同样的源：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx6vvjgxqj20ih0hwq4k.jpg" alt="hot observable"></p><p>另一种称为 Cold Observable，每个订阅者都有自己的私有源：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx6w6gawnj20ji0hxgni.jpg" alt="cold observable"></p><p>注意取消订阅不等于终止源，因为可能还存在其他订阅者。</p><p><code>Subscription</code> 的基础定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(unsubscribe: =&gt; <span class="type">Unit</span>):<span class="type">Subscription</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Subscription</code> 家族中包含这些成员：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BooleanSubscription</span> <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUnsubscribed</span></span>: <span class="type">Boolean</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CompositeSubscription</span> <span class="keyword">extends</span> <span class="title">BooleanSubscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+=</span></span>(s: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">-=</span></span>(s: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MultipleAssignmentSubscription</span> <span class="keyword">extends</span> <span class="title">BooleanSubscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscription</span></span>: <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscription_=</span></span>(that: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面的代码中 <code>subscription</code> 被调用了两次：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> subscription = <span class="type">Subscription</span> &#123;</div><div class="line">   println(<span class="string">"bye, bye, I’m out fishing"</span>)</div><div class="line">&#125;</div><div class="line">subscription.unsubscribe()</div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure><p>结果是只有第一次会输出字符串。就是说，<code>unsubscribe</code> 可以被调用多次，它必须是<a href="http://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="external">幂等（idempotent）</a>的。</p><p><code>BooleanSubscription</code> 有一个 <code>isUnsubscribed</code> 方法，它能指示此订阅是否已被取消：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> subscription = <span class="type">BooleanSubscription</span> &#123;</div><div class="line">   println(<span class="string">"bye, bye, I’m out fishing"</span>)</div><div class="line">&#125;</div><div class="line">println(subscription.isUnsubscribed)</div><div class="line">subscription.unsubscribe()</div><div class="line">println(subscription.isUnsubscribed)</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7ctkstbj204q0f2glw.jpg" alt="BooleanSubscription"></p><p><code>CompositeSubscription</code> 可以包含许多订阅，当其被取消时所包含的订阅也会被取消：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">BooleanSubscription</span> &#123; println(<span class="string">"A"</span>) &#125;</div><div class="line"><span class="keyword">val</span> b = <span class="type">Subscription</span> &#123; println(<span class="string">"B"</span>) &#125;</div><div class="line"><span class="keyword">val</span> composite = <span class="type">CompositeSubscription</span>(a,b)</div><div class="line">println(composite.isUnsubscribed)</div><div class="line">composite.unsubscribe()</div><div class="line">println(composite.isUnsubscribed)</div><div class="line">println(a.isUnsubscribed)</div><div class="line">composite += <span class="type">Subscription</span>&#123; println (<span class="string">"C"</span>) &#125;</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx7dcsud4j20dr0ipgna.jpg" alt="CompositeSubscription-subscribe"></p><p>当新加入订阅时，若 <code>CompositeSubscription</code> 未被取消则新订阅状态不变，若 <code>CompositeSubscription</code> 已被取消则新订阅会被立刻取消：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx7e96l9tj210h0h0aec.jpg" alt="CompositeSubscription-add"></p><p><code>MultiAssignment</code> 只能包含一个子订阅，且它自身包含了一个隐式的订阅：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7hz7kt6j20zv0h5q7a.jpg" alt="MultiAssignment-subscribe"></p><p>新加入订阅时的行为和 <code>CompositeSubscription</code> 类似：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7kqh7uaj20za0gigpe.jpg" alt="MultiAssignment-add"></p><p>当子订阅被取消时，<code>MultiAssignment</code> 的隐式订阅并不会被取消：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7llgmrrj20yt0f2wh8.jpg" alt="MultiAssignment-unscribe"></p><p>练习：</p><p>有如下代码段：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">BooleanSubscription</span> &#123; println(<span class="string">"A"</span>) &#125;</div><div class="line"><span class="keyword">val</span> b = <span class="type">Subscription</span> &#123; println(<span class="string">"B"</span>) &#125;</div><div class="line"><span class="keyword">val</span> c = <span class="type">CompositeSubscription</span>(a,b)</div><div class="line"><span class="keyword">val</span> m = <span class="type">MultiAssignmentSubscription</span>()</div><div class="line">m.subscription = c</div><div class="line">c.unsubscribe</div></pre></td></tr></table></figure><p>下面哪个是正确的？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) b.isUnsubscribed == <span class="literal">true</span></div><div class="line">b) a.isUnsubscribed == <span class="literal">false</span></div><div class="line">c) m.isUnsubscribed == <span class="literal">true</span></div><div class="line">d) c.isUnsubscribed == <span class="literal">true</span></div></pre></td></tr></table></figure><p>答案是 D。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Future-T-和-Try-T-是对偶（dual）&quot;&gt;&lt;a href=&quot;#Future-T-和-Try-T-是对偶（dual）&quot; class=&quot;headerlink&quot; title=&quot;Future[T] 和 Try[T] 是对偶（dual）&quot;&gt;&lt;/a&gt;&lt;code&gt;Future[T]&lt;/code&gt; 和 &lt;code&gt;Try[T]&lt;/code&gt; 是&lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_%28category_theory%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;对偶（dual）&lt;/a&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Future&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;] &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OnComplete&lt;/span&gt;&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;U&lt;/span&gt;](func: &lt;span class=&quot;type&quot;&gt;Try&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;] =&amp;gt; &lt;span class=&quot;type&quot;&gt;U&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;implicit&lt;/span&gt; ex: &lt;span class=&quot;type&quot;&gt;ExecutionContext&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015.02.19</title>
    <link href="http://stormluke.me/2015-02-19/"/>
    <id>http://stormluke.me/2015-02-19/</id>
    <published>2015-02-18T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.030Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.pixiv.net/member_illust.php?illust_id=48751362&amp;mode=medium" target="_blank" rel="external"><img src="http://ww1.sinaimg.cn/large/6ad06ebbgy1fdulvs47uzj20jk0rs4lo.jpg" alt=""></a></p><a id="more"></a><p><a href="http://music.163.com/#/song?id=401632" target="_blank" rel="external">おひさま</a></p><p>晚安。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.pixiv.net/member_illust.php?illust_id=48751362&amp;amp;mode=medium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6ad06ebbgy1fdulvs47uzj20jk0rs4lo.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小阴谋家——一遍又一遍</title>
    <link href="http://stormluke.me/the-little-schemer-4th-edition-ch9/"/>
    <id>http://stormluke.me/the-little-schemer-4th-edition-ch9/</id>
    <published>2015-02-11T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.038Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://kysmykseka.net/koti/wizardry/Programming/Lisp/Scheme/The%20Little%20Schemer%204th%20Ed.pdf" target="_blank" rel="external"><em>The Little Schemer 4th Edition Ch9 - …and Again, and Again, and Again, …</em></a>。</p><p>（这篇文章提到了 Y combinator。）</p><a id="more"></a><p>A：你想吃<em>鱼子酱</em>吗？</p><p>B：那我们必须去<em>寻找</em>它。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(looking a lat)</code> 的结果是什么？</p><p>B：<code>#t</code>，很明显 <code>caviar</code> 在 <code>lat</code> 中。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 grits caviar 5 7 3)</code> 时 <code>(looking a lat)</code> 呢？</p><p>B：<code>#f</code>。</p><p>A：和你想的不一样？</p><p>B：是啊，<code>caviar</code> 仍在 <code>lat</code> 中。</p><p>A：确实，但 <code>lat</code> 的第一个数字是什么？</p><p>B：6。</p><p>A：那 <code>lat</code> 的第六个元素是什么？</p><p>B：7。</p><p>A：第七个元素呢？</p><p>B：3。</p><p>A：所以 <code>looking</code> 显然找不到 <code>caviar</code>。</p><p>B：确实，因为第三个元素是 <code>grits</code>，和 <code>caviar</code> 一点也不像。</p><p>A：这是 <code>looking</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> looking</div><div class="line">  (<span class="name">lambda</span> (<span class="name">a</span> lat)</div><div class="line">    (<span class="name">keep-looking</span> a (<span class="name">pick</span> <span class="number">1</span> lat) lat)))</div></pre></td></tr></table></figure><p>写出 <code>keep-looking</code>。</p><p>B：我们不期望你知道答案。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(looking a lat)</code> 呢？</p><p>B：<code>#t</code>，因为 <code>(keep-looking a 6 lat)</code> 和 <code>(keep-looking a (pick 1 lat) lat)</code> 结果相同。</p><p>A：当 <code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(pick 6 lat)</code> 的结果是什么？</p><p>B：7。</p><p>A：那我们该怎么办？</p><p>B：<code>(keep-looking a 7 lat)</code>，其中 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 。</p><p>A：当 <code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(pick 7 lat)</code> 的结果是什么？</p><p>B：3。</p><p>A：那么当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(keep-looking a 3 lat)</code> 的结果是什么？</p><p>B：和 <code>(keep-looking a 4 lat)</code> 一样。</p><p>A：那是？</p><p>B：<code>#t</code>。</p><p>A：写出 <code>keep-looking</code>。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> keep-looking</div><div class="line">  (<span class="name">lambda</span> (<span class="name">a</span> sorn lat)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">number</span>? sorn)</div><div class="line">       (<span class="name">keep-looking</span> a (<span class="name">pick</span> sorn lat) lat))</div><div class="line">      (<span class="name">else</span> (<span class="name">eq</span>? sorn a)))))</div></pre></td></tr></table></figure><p>A：你能猜出 <code>sorn</code> 代表啥吗？</p><p>B：符号或者数字。</p><p>A：<code>keep-looking</code> 有什么不寻常的地方？</p><p>B：它在 <code>lat</code> 某一部分上不递归。</p><p>A：我们把这叫做“非原始”递归（”unnatural” recursion）。</p><p>B：这确实很反常。</p><p>A：<code>keep-looking</code> 离其目标越来越近吗？</p><p>B：是的，从目前所有证据看来。</p><p>A：它始终和目标越来越近吗？</p><p>B：有时列表会既不包含 <code>caviar</code> 也不包含 <code>grits</code>。</p><p>A：嗯对。列表可能是元组（仅包含数字）。</p><p>B：嗯，如果我们在 <code>(7 2 4 7 5 6 3)</code> 上开始 <code>looking</code>，我们将永远不会停下来。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(7 1 2 caviar 5 6 3)</code> 时。<code>(looking a lat)</code> 的结果是什么？</p><p>B：这很奇怪！</p><p>A：确实奇怪。发生了啥？</p><p>B：我们不停地查询查询查询……</p><p>A：如同 <code>looking</code> 的函数叫做<a href="http://en.wikipedia.org/wiki/Partial_function" target="_blank" rel="external">偏函数（缺值函数 / partial function）</a>。你觉得我们到目前为止看到的函数叫什么？</p><p>B：它们叫做全函数（total function）。</p><p>A：你能定义一个给定某些参数时不能到达其目标的简短函数吗？</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> eternity</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">eternity</span> x)))</div></pre></td></tr></table></figure><p>A：有多少参数能让 <code>eternity</code> 到达其目标？</p><p>B：一个都没，这可能是最反常的递归了。</p><p>A：<code>eternity</code> 是偏的吗？</p><p>B：这是最偏的函数了。</p><p>A：当 <code>x</code> 是 <code>((a b) c)</code> 时 <code>(shift x)</code> 的结果是什么？</p><p>B：<code>(a (b c))</code>。</p><p>A：当 <code>x</code> 是 <code>((a b) (c d))</code> 时 <code>(shift x)</code> 的结果是什么？</p><p>B：<code>(a (b (c d)))</code>。</p><p>A：定义 <code>shift</code>。</p><p>B：这是平凡的；它甚至不递归！</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> shift</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pair</span>)</div><div class="line">    (<span class="name">build</span> (<span class="name">first</span> (<span class="name">first</span> pair))</div><div class="line">      (<span class="name">build</span> (<span class="name">second</span> (<span class="name">first</span> pair))</div><div class="line">        (<span class="name">second</span> pair)))))</div></pre></td></tr></table></figure><p>A：描述 <code>shift</code> 做了啥。</p><p>B：这是我们的陈述：“函数 <code>shift</code> 接受一个偶对，此偶对的第一部分也是一个偶对。该函数构造一个偶对，这个偶对是由参数偶对的第一部分的偶对的第二部分挪动到参数偶对的第二部分构成的。”</p><p>A：现在看看这个函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> align</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pora</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">atom</span>? pora) pora)</div><div class="line">      ((<span class="name">a-pair</span>? (<span class="name">first</span> pora))</div><div class="line">       (<span class="name">align</span> (<span class="name">shift</span> pora)))</div><div class="line">      (<span class="name">else</span> (<span class="name">build</span> (<span class="name">first</span> pora)</div><div class="line">              (<span class="name">align</span> (<span class="name">second</span> pora)))))))</div></pre></td></tr></table></figure><p>它和 <code>keep-looking</code> 有什么相似之处？</p><p>B：两个函数都改变了自身的参数以作递归用，但两个函数都不保证能到达其目标。</p><p>A：为什么我们不能保证 <code>align</code> 会有进展？</p><p>B：在 <code>cond</code> 的第二行 <code>shift</code> 为 <code>align</code> 创建的参数并不是原参数的一部分。</p><p>A：这违反了哪条戒律？</p><p>B：第七戒。</p><blockquote><p>第七戒<br>在子部分上的递归有同样的本质：<br>在列表的子列表上<br>在算术表达式的子表达式上</p></blockquote><p>A：新参数至少比原参数更小吗？</p><p>B：看起来不像。</p><p>A：为啥呢？</p><p>B：<code>shift</code> 函数仅仅重新排列了它得到的部分。</p><p>A：然后？</p><p>B：<code>shift</code> 的参数和结果有一样的原子个数。</p><p>A：你能写一个计算 <code>align</code> 参数中原子个数的函数吗？</p><p>B：没问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> length *</div><div class="line">  (lambda (pora)</div><div class="line">    (cond</div><div class="line">      ((atom? pora) 1)</div><div class="line">      (else</div><div class="line">        (+ (length* (<span class="name">first</span> pora))</div><div class="line">           (length* (second pora)))))))</div></pre></td></tr></table></figure><p>A：<code>align</code> 是偏函数吗？</p><p>B：我们还不清楚。可能有某些参数使其一直做对齐操作。</p><p>A：<code>align</code> 的参数和其递归过程还有其他改变吗？</p><p>B：有的。偶对的第一部分变得更简单，同时第二部分变得更复杂。</p><p>A：第一部分怎么变得简单了？</p><p>B：它只是原来的第一部分。</p><p>A：这不就是说 <code>length*</code> 不能确定参数的长度？你能找出一个更好的函数吗？</p><p>B：更好的函数应该在第一部分上更加小心。</p><p>A：在第一部分上我们应该多小心？</p><p>B：至少两倍。</p><p>A：你是不是说类似于 <code>weight*</code> 这样的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> weight*</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pora</span>)</div><div class="line">   (<span class="name">cond</span></div><div class="line">     ((<span class="name">atom</span>? pora) <span class="number">1</span>)</div><div class="line">     (<span class="name">else</span></div><div class="line">       (<span class="name">+</span> (<span class="name">*</span> (<span class="name">weight*</span> (<span class="name">first</span> pora)) <span class="number">2</span>)</div><div class="line">          (<span class="name">weight*</span> (<span class="name">second</span> pora))))))</div></pre></td></tr></table></figure><p>B：看起来是。</p><p>A：当 <code>x</code> 是 <code>((a b) c)</code> 时 <code>(weight* x)</code> 的结果是什么？</p><p>B：7。</p><p>A：当 <code>x</code> 是 <code>(a (b c))</code> 时 <code>(weight* x)</code> 的结果是什么？</p><p>B：5。</p><p>A：这是不是意味着参数变简单了？</p><p>B：是的，<code>align</code> 参数的 <code>weight*</code> 值连续地变小。</p><p>A：<code>align</code> 是偏函数吗？</p><p>B：不，它对每个参数都能产生值。</p><p>A：这是 <code>shuffle</code>，它类似于 <code>align</code> 但用第七章中的 <code>revpair</code> 替换了 <code>shift</code>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> shuffle</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pora</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">atom</span>? pora) pora)</div><div class="line">      ((<span class="name">a-pair</span>? (<span class="name">first</span> pora))</div><div class="line">       (<span class="name">shuffle</span> (<span class="name">revpair</span> pora)))</div><div class="line">      (<span class="name">else</span> (<span class="name">build</span> (<span class="name">first</span> pora)</div><div class="line">              (<span class="name">shuffle</span> (<span class="name">second</span> pora)))))))</div></pre></td></tr></table></figure><p>B：当偶对的第一部分是偶对时 <code>shuffle</code> 和 <code>revpair</code> 交换这两个部分。</p><p>A：这说明 <code>shuffle</code> 是完全的？</p><p>B：我们不知道。</p><p>A：让我们试试。当 <code>x</code> 是 <code>(a (b c))</code> 时 <code>(shuffle x)</code> 的结果是什么？</p><p>B：<code>(a (b c))</code>。</p><p>A：当 <code>x</code> 是 <code>(a b)</code> 时 <code>(shuffle x)</code> 呢？</p><p>B：<code>(a b)</code>。</p><p>A：好，让我们来点有趣的。当 <code>x</code> 是 <code>((a b) (c d))</code> 时 <code>(shuffle x)</code> 的结果是什么？</p><p>B：要确定结果，我们需要算出 <code>(shuffle (revpair pora))</code> 的值是什么。其中 <code>pora</code> 是 <code>((a b) (c d))</code>。</p><p>A：那我们该如何做呢？</p><p>B：我们应该确定 <code>(shuffle pora)</code> 的值。其中 <code>pora</code> 是 <code>((c d) (a b))</code>。</p><p>A：这不就是说我们需要知道当 <code>(revpair pora)</code> 是 <code>((a b) (c d))</code> 时 <code>(shuffle (revpair pora))</code> 的值？</p><p>B：是的。</p><p>A：所以？</p><p>B：<code>shuffle</code> 函数不是完全的，因为它现在再次交换了偶对的两部分，这说明我们重新来了一遍。</p><p>A：这个函数是完全的吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> C</div><div class="line">  (<span class="name">lambda</span> (<span class="name">n</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">one</span>? n) <span class="number">1</span></div><div class="line">      (<span class="name">else</span> cond</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">even</span>? n) (<span class="name">C</span> (<span class="name">/</span> (<span class="name">n</span> <span class="number">2</span>)))</div><div class="line">          (<span class="name">else</span> (<span class="name">C</span> (<span class="name">add1</span> (<span class="name">*</span> <span class="number">3</span> n)))))))))</div></pre></td></tr></table></figure><p>B：它不能产生 0，但除此之外没人知道为啥。谢谢你，<a href="http://en.wikipedia.org/wiki/Lothar_Collatz" target="_blank" rel="external">Lothar Collatz (1910-1990)</a>（<a href="http://zh.wikipedia.org/wiki/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3" target="_blank" rel="external">考拉兹猜想</a>）。</p><p>A：<code>(A 1 0)</code> 的值是什么？</p><p>B：2。</p><p>A：<code>(A 1 1)</code>？</p><p>B：3。</p><p>A：<code>(A 2 2)</code>？</p><p>B：7。</p><p>A：这是 <code>A</code> 的定义：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> A</div><div class="line">  (<span class="name">lambda</span> (<span class="name">n</span>, m)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">zero</span>? n) (<span class="name">add1</span> m))</div><div class="line">      ((<span class="name">zero</span>? m) (<span class="name">A</span> (<span class="name">sub1</span> n) <span class="number">1</span>))</div><div class="line">      (<span class="name">else</span> (<span class="name">A</span> (<span class="name">sub1</span> n)</div><div class="line">              (<span class="name">A</span> n (<span class="name">sub1</span> m)))))))</div></pre></td></tr></table></figure><p>B：谢谢你，<a href="http://en.wikipedia.org/wiki/Wilhelm_Ackermann" target="_blank" rel="external">Wilhelm Ackermann (1853-1946)</a>（<a href="http://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8" target="_blank" rel="external">阿克曼函数</a>）。</p><p>A：<code>A</code> 与 <code>shuffle</code> 和 <code>looking</code> 间有什么相同之处？</p><p>B：<code>A</code> 的参数像 <code>shuffle</code> 和 <code>looking</code> 的一样，不会随着递归必定降低。</p><p>A：举个例子？</p><p>B：这很容易：<code>(A 1 2)</code> 需要 <code>(A 0 (A 1 1))</code> 的值。而这又说明我们需要 <code>(A 0 3)</code> 的值。</p><p>A：<code>A</code> 总会给出解答吗？</p><p>B：是的，它是完全的。</p><p>A：那么 <code>(A 4 3)</code> 是多少？</p><p>B：对于实践情况来说，没有答案。</p><p>A：这什么意思？</p><p>B：在我们计算出 <code>(A 4 3)</code> 的结果之前你正在读的这页纸早就已经腐烂了。</p><blockquote><p>But answer came there none<br>And this was scarcely odd, because<br>They’d eaten every one.<br><em>The Walrus and The Carpenter</em><br><em>Lewis Carroll</em></p></blockquote><p>A：如果我们能写一个测定某函数能否对每个参数都有返回值的函数岂不是很棒？</p><p>B：确实会很棒。目前我们已经看到了不返回的函数和返回太慢的函数，我们确实应该有这样一种工具。</p><p>A：好的，让我们写写看。</p><p>B：这听起来很复杂。一个函数可以有许多不同的参数。</p><p>A：那么我们简化一下。作为一个热身练习，让我们只关注检查某函数对空列表是否停止的函数，这是最简单的参数了。</p><p>B：这会简化很多。</p><p>A：这是此函数的开头：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> will-stop?</div><div class="line">  (<span class="name">lambda</span> (<span class="name">f</span>)</div><div class="line">    ...))</div></pre></td></tr></table></figure><p>你能补全点吗？</p><p>B：它要干什么？</p><p>A：<code>will-stop?</code> 会对每个参数返回值吗？</p><p>B：这是最简单的部分：我们说它会返回 <code>#t</code> 或 <code>#f</code>，根据参数被应用上 <code>()</code> 时是否停止。</p><p>A：那么 <code>will-stop?</code> 是完全的吗？</p><p>B：是的。它始终返回 <code>#t</code> 或 <code>#f</code>。</p><p>A：那我们来举些例子。这是第一个。当 <code>f</code> 是 <code>length</code> 时 <code>(will-stop? f)</code> 的结果是什么？</p><p>B：我们知道当 <code>l</code> 是 <code>()</code> 时 <code>(length l)</code> 是 <code>0</code>。</p><p>A：所以？</p><p>B：所以 <code>(will-stop？ length)</code> 的值应当是 <code>#t</code>。</p><p>A：没错。换一个例子呢？ <code>(will-stop? eternity)</code> 的结果是什么？</p><p>B：<code>(eternity (quote ()))</code> 不会返回值。我们刚刚看到了。</p><p>A：这就是说 <code>(will-stop? eternity)</code> 是 <code>#f</code>？</p><p>B：嗯，是。</p><p>A：还需要更多的例子吗？</p><p>B：或许我们还需要另外一个例子。</p><p>A：好的，这个函数可能是 <code>will-stop?</code> 的一个有趣的参数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> last-try</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">and</span> (<span class="name">will-stop</span>? last-try)</div><div class="line">      (<span class="name">eternity</span> x))))</div></pre></td></tr></table></figure><p><code>(will-stop? last-try)</code> 的结果是什么？</p><p>B：它做了啥？</p><p>A：我们需要在 <code>()</code> 上测试它。</p><p>B：如果我们想知道 <code>(last-try (quote ()))</code> 的值，那我们必须确定</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">and</span> (<span class="name">will-stop</span>? last-try)</div><div class="line">  (<span class="name">eternity</span> (<span class="name">quote</span> ())))</div></pre></td></tr></table></figure><p>的值。</p><p>A：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">and</span> (<span class="name">will-stop</span>? last-try)</div><div class="line">  (<span class="name">eternity</span> (<span class="name">quote</span>())))</div></pre></td></tr></table></figure><p>的值是什么？</p><p>B：这取决于 <code>(will-stop? last-try)</code> 的值。</p><p>A：那这只有两种可能。我们假设 <code>(will-stop? last-try)</code> 是 <code>#f</code>。</p><p>B：好，那么 <code>(and #f (eternity (quote ())))</code> 是 <code>#f</code>， 因为 <code>(and #f ...)</code> 始终是 <code>#f</code>。</p><p>A：所以 <code>(last-try (quote ()))</code> 停止了，对吧？</p><p>B：确实停止了。</p><p>A：但刚刚 <code>will-stop</code> 不是说的正相反？</p><p>B：确实相反。我们假设 <code>(will-stop? last-try)</code> 的值是 <code>#f</code>，这说明 <code>last-try</code> 不会停止。</p><p>A：所以我们弄错了 <code>(will-stop? last-try)</code>。</p><p>B：是。它肯定返回 <code>#t</code>，因为 <code>will-stop?</code> 始终返回值。我们说过它是完全的。</p><p>A：很好。如果 <code>(will-stop? last-try)</code> 是 <code>#t</code>，那 <code>(last-try (quote ()))</code> 的值是什么？</p><p>B：现在我们只需确定 <code>(and #t (eternity (quote ())))</code> 的值，而这和 <code>(eternity (quote ()))</code> 的值一致。</p><p>A：<code>(eternity (quote ()))</code> 的值是什么？</p><p>B：它没有值。我们知道它不会停。</p><p>A：但这就意味着我们又错了！</p><p>B：是啊，因为这次我们假设 <code>(will-stop? last-try)</code> 是 <code>#t</code>。</p><p>A：你觉得这意味着什么？</p><p>B：这是我们的想法：“我们仔细检查了两种可能的情况。如果我们能<em>定义</em> <code>will-stop?</code>，那么 <code>(will-stop? last-try)</code> 肯定会产生 <code>#t</code> 或 <code>#f</code>。但是它不能——正是根据 <code>(will-stop?)</code> 被设想应做的那样。这肯定说明 <code>will-stop?</code> 不能被<em>定义</em>。”</p><p>A：这是特别的吗？</p><p>B：是的。这使得 <code>will-stop?</code> 是第一个我们能准确描述但不能在我们的语言中<em>定义</em>的函数。</p><p>A：有什么方法能解决这个问题吗？</p><p>B：没有。谢谢你，<a href="http://en.wikipedia.org/wiki/Alan_Turing" target="_blank" rel="external">Alan M Turing (1912-1954)</a> （<a href="http://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="external">停机问题</a>）和 <a href="http://en.wikipedia.org/wiki/Kurt_G%C3%B6del" target="_blank" rel="external">Kurt Gödel (1906-1978)</a>。</p><p>A：<code>(define ...)</code> 是什么？</p><p>B：这是个好问题。我们刚看到了 <code>(define ..)</code> 对 <code>will-stop?</code> 不管用。</p><p>A：所以啥是递归定义呢？</p><p>B：抓紧，深呼吸，准备好后向前冲。</p><p>A：这是 <code>length</code> 函数吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> length</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div></pre></td></tr></table></figure><p>B：必须是啊。</p><p>A：如果我们没有 <code>(define ...)</code> 该怎么办？我们还能定义 <code>length</code> 吗？</p><p>B：没有 <code>(define ...)</code>，就不能在 <code>length</code> 的定义体中引用到 <code>length</code>。</p><p>A：这个函数做了啥？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">eternity</span> (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>B：它确定空列表的长度，没了。</p><p>A：当我们在一个非空列表上用它时会怎样？</p><p>B：没答案。如果我们给 <code>eternity</code> 一个参数，它不会给出答案。</p><p>A：对于 <code>length</code> 这样的函数这说明什么？</p><p>B：对非空列表来说其不会给出任何答案。</p><p>A：假设我们可以命名这个新函数。啥名字好？</p><p>B：<code>length0</code>。因为这个函数只能确定空列表的长度。</p><p>A：你如何写一个确定包含一个或多个元素的列表的长度的函数？</p><p>B：呃，我们可以试试下面这个。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length0</span> (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>A：差不多，但 <code>(define ...)</code> 对 <code>length0</code> 不管用。</p><p>B：所以，替换 <code>length0</code> 为它的定义。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span></div><div class="line">      (<span class="name">add</span> <span class="number">1</span></div><div class="line">        ((<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">          (<span class="name">cond</span></div><div class="line">            ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">            (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                    (<span class="name">eternity</span> (<span class="name">cdr</span> l))))))</div><div class="line">          (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>A：那这个函数叫啥好呢？</p><p>B：很简单：<code>length≤1</code>。</p><p>A：这是能确定包含两个或更少项的列表长度的函数吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span></div><div class="line">      (<span class="name">add1</span></div><div class="line">        ((<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">           (<span class="name">cond</span></div><div class="line">             ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">             (<span class="name">else</span></div><div class="line">               (<span class="name">add1</span></div><div class="line">                 ((<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">                   (<span class="name">cond</span></div><div class="line">                     ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">                     (<span class="name">else</span></div><div class="line">                       (<span class="name">add1</span></div><div class="line">                         (<span class="name">eternity</span></div><div class="line">                           (<span class="name">cdr</span> l))))))</div><div class="line">                   (<span class="name">cdr</span> l))))))</div><div class="line">          (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>B：是的，这就是 <code>length≤2</code>。我们仅把 <code>eternity</code> 换成了下一版的 <code>length</code>。</p><p>A：现在，你觉得递归是什么？</p><p>B：啥意思？</p><p>A：我们已经看到了如何确定空列表的长度、不多于一项列表的长度和不多于两项列表的长度等等。我们如何才能实现原先的 <code>length</code> 函数？</p><p>B：如果我们能写无穷多个函数，以 <code>length0</code>、<code>length≤1</code>、<code>length≤2</code>、……这样的形式，那我们就可以写出 <code>length∞</code>，这就可以确定我们能做出的所有列表的长度。</p><p>A：我们能做出多长的列表？</p><p>B：呃，列表可能是空的，或者包含一个元素，或者两个，或者三个，或者四个，……，或者 1001 个，……</p><p>A：但我们不能写出一个无穷的函数。</p><p>B：不能。</p><p>A：而且我们仍旧在这些函数里面有这些重复和模式。</p><p>B：是的。</p><p>A：这些模式像什么？</p><p>B：所有的这些程序包含一个像 <code>length</code> 的函数。或许我们应该抽象出这个函数：参见第九戒。</p><blockquote><p>第九戒<br>用新函数抽象通用模式</p></blockquote><p>A：让我们试试看！</p><p>B：我们需要一个看起来像 <code>length</code> 但由 <code>(lambda (length) ...)</code> 开头的函数。</p><p>A：你是说这个？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  eternity)</div></pre></td></tr></table></figure><p>B：嗯，可以。这创建了 <code>length0</code>。</p><p>A：用同样的方式重写 <code>length≤1</code>。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">f</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">f</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">g</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">g</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    eternity))</div></pre></td></tr></table></figure><p>A：我们必须用 <code>length</code> 来命名参数吗？</p><p>B：不用，我们只用了 <code>f</code> 和 <code>g</code>。只要我们保持一致，任何事都没问题。</p><p>A：那 <code>length≤2</code> 呢？</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      eternity)))</div></pre></td></tr></table></figure><p>A：快了，但现在仍有重复。</p><p>B：确实。让我们去掉它们。</p><p>A：我们从哪开始？</p><p>B：给这个以 <code>length</code> 作为参数返回另一个类似 <code>length</code> 函数的函数起个名字。</p><p>A：这个函数啥名字好？</p><p>B：<code>mk-length</code> 咋样？意思是 make length。</p><p>A：行，在 <code>length0</code> 上试试。</p><p>B：没问题。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> eternity))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：这是 <code>length≤1</code> 吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span></div><div class="line">    (<span class="name">mk-length</span> eternity)))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：当然。然后这是 <code>length≤2</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span></div><div class="line">    (<span class="name">mk-length</span></div><div class="line">      (<span class="name">mk-length</span> eternity))))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：你能以这种方法写出 <code>length≤3</code> 吗？</p><p>B：妥妥的。这就是。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span></div><div class="line">    (<span class="name">mk-length</span></div><div class="line">      (<span class="name">mk-length</span></div><div class="line">        (<span class="name">mk-length</span> eternity)))))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：递归像什么？</p><p>B：像一座对任意函数应用 <code>mk-length</code> 的无限高的塔。</p><p>A：我们真的需要一个无限高的塔吗？</p><p>B：当然不必要。每次使用 <code>length</code> 时我们只需要有限的数量，但是我们不知道是多少。</p><p>A：我们能猜出来需要多少吗？</p><p>B：可以，但我们有时候猜的不够大。</p><p>A：如果猜的不够大，什么时候我们才能知道？</p><p>B：当我们应用传递给最内层 <code>mk-length</code> 的 <code>eternity</code> 函数时。</p><p>A：如果此时我们能创建对 <code>mk-length</code> 应用 <code>eternity</code> 的另一个应用会发生什么？</p><p>B：这只会将问题推迟一点，另外，我们怎样才能做到这点呢？</p><p>A：因为没人关心我们给 <code>mk-length</code> 传递了什么函数，我们可以从一开始就传递 <code>mk-length</code>。</p><p>B：这是个好主意。然后我们在 <code>eternity</code> 上应用 <code>mk-length</code>，在 <code>cdr</code> 上应用其结果，这样我们就从塔上多得到了一层。</p><p>A：那么这仍旧是 <code>length0</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：是的，我们甚至能用 <code>mk-length</code> 替代 <code>length</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                (<span class="name">mk-length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：为什么我们想这样做？</p><p>B：所有名字都是平等的，但有些名字比其他名字更平等。</p><p>A：真理：只要我们一致地使用名字，我们就没问题。</p><p>B：<code>mk-length</code> 比 <code>length</code> 平等得多。如果我们用类似 <code>mk-length</code> 这样的名字，这就像一个提示，提示我们 <code>mk-length</code> 的第一个参数是 <code>mk-length</code>。</p><p>A：现在 <code>mk-length</code> 被传递给 <code>mk-length</code>， 我们能用参数来构建另一个递归调用吗？</p><p>B：能，当我们应用 <code>mk-length</code> 一次，我们得到 <code>length≤1</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                ((<span class="name">mk-length</span> eternity)</div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：当 <code>l</code> 是 <code>(apples)</code> 时</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                ((<span class="name">mk-length</span> eternity)</div><div class="line">                  (<span class="name">cdr</span> l))))))))</div><div class="line">  l)</div></pre></td></tr></table></figure><p>的结果是什么？</p><p>B：这是个好练习。不用纸笔解出它。</p><p>A：我们能这样做多于一次吗？</p><p>B：可以，不断把 <code>mk-length</code> 传递给自己就行，我们可以随时需要随时做！</p><p>A：你把这个函数叫做什么？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                ((<span class="name">mk-length</span> mk-length)</div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：这是必须是 <code>length</code> 啊。</p><p>A：它是如何运作的？</p><p>B：它向自身传递 <code>mk-length</code> 来不断添加递归操作，就像它即将到期一样。</p><p>A：还剩一个问题：它不包含一个像 <code>length</code> 的函数了。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                ((<span class="name">mk-length</span> mk-length)</div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>你能改改这个吗？</p><p>B：我们可以把将 <code>mk-length</code> 应用到自身的这个过程抽取出来并称为 <code>length</code>。</p><p>A：为啥？</p><p>B：因为它确实实现了 <code>length</code> 这个功能。</p><p>A：这个怎样？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div></pre></td></tr></table></figure><p>B：看起来不错。</p><p>A：让我们看看它是否能行。</p><p>B：好。</p><p>A：当 <code>l</code> 是 <code>(apples)</code> 时</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div><div class="line">  l)</div></pre></td></tr></table></figure><p>的结果是什么？</p><p>B：应该是 <code>1</code>。</p><p>A：首先，我们需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div></pre></td></tr></table></figure><p>的值。</p><p>B：确实，因为这个表达式的值正是我们要应用 <code>l</code> 的函数，其中 <code>l</code> 是 <code>(apples)</code>。</p><p>A：所以我们其实需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    (<span class="name">mk-length</span> mk-length)))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div></pre></td></tr></table></figure><p>的值。</p><p>B：确实。</p><p>A：但之后我们其实需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length)))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">        (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">          (<span class="name">cond</span></div><div class="line">            ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">            (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">        (<span class="name">mk-length</span> mk-length)))))</div></pre></td></tr></table></figure><p>的值。</p><p>B：是的，确实。这个的终点在哪？我们不还依旧需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">        (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">          (<span class="name">cond</span></div><div class="line">            ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">            (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">        (<span class="name">mk-length</span> mk-length)))</div><div class="line">      (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">        ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">          (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">            (<span class="name">cond</span></div><div class="line">              ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">              (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">          (<span class="name">mk-length</span> mk-length))))))</div></pre></td></tr></table></figure><p>的值？</p><p>A：是，这没个头啊。为啥呢？</p><p>B：因为我们只是一遍一遍地把 <code>mk-length</code> 应用到自己。</p><p>A：这很奇怪吧？</p><p>B：因为之前 <code>mk-length</code> 在我们应用一个参数时会返回一个函数。实际上，它不关心我们应用了什么。</p><p>A：但现在我们把 <code>(mk-length mk-length)</code> 从 <code>length</code> 函数中抽取了出来，它就不在返回函数了。</p><p>B：嗯是。所以该咋办？</p><p>A：把最后正确版本的 <code>mk-length</code> 转换成一个函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                ((<span class="name">mk-length</span> mk-length)</div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：咋弄？</p><p>A：有个不同的办法。如果 <code>f</code> 是个一元函数，那么 <code>(lambda (x) (f x))</code> 也是个一元函数吗？</p><p>B：是。</p><p>A：如果 <code>(mk-length mk-length)</code> 返回一个一元函数，那么</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">  ((<span class="name">mk-length</span> mk-length) x))</div></pre></td></tr></table></figure><p>也返回一个一元函数吗？</p><p>B：实际上，</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">  ((<span class="name">mk-length</span> mk-length) x))</div></pre></td></tr></table></figure><p>是一个函数！</p><p>A：很好，让我们处理下 <code>mk-length</code> 对自己的应用。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                ((<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">                  ((<span class="name">mk-length</span> mk-length) x))</div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：把新函数移出来我们就找回了 <code>length</code>。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span></div><div class="line">            (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">      (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">        ((<span class="name">mk-length</span> mk-length) x)))))</div></pre></td></tr></table></figure><p>A：把函数移出来没问题吗？</p><p>B：我们只是做了把名字换成值正相反的事。这里我们抽取出值并给它一个名字。</p><p>A：我们能把方框里像 <code>length</code> 的那个函数抽取出来并命名吗？</p><p>B：可以，它根本不依赖于 <code>mk-length</code>！</p><p>A：这是正确的函数吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">le</span>)</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">mk-length</span> mk-length))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      (<span class="name">le</span> (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">            ((<span class="name">mk-length</span> mk-length) x)))))))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div></pre></td></tr></table></figure><p>B：对。</p><p>A：我们实际上得到了啥？</p><p>B：我们抽取出了原先的函数 <code>mk-length</code>。</p><p>A：让我们从像 <code>length</code> 的函数中分出创建 <code>length</code> 的函数。</p><p>B：这很简单。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">le</span>)</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">mk-length</span> mk-length))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      (<span class="name">le</span> (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">            ((<span class="name">mk-length</span> mk-length) x))))))</div></pre></td></tr></table></figure><p>A：这个函数有名字吗？</p><p>B：有，这叫做<a href="http://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90" target="_blank" rel="external">应用序 Y 组合子（applicative-order Y combinator）</a>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> Y</div><div class="line">  (<span class="name">lambda</span> (<span class="name">le</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">f</span>) (<span class="name">f</span> f))</div><div class="line">      (<span class="name">lambda</span> (<span class="name">f</span>)</div><div class="line">        (<span class="name">le</span> (<span class="name">lambda</span> (<span class="name">x</span>) ((<span class="name">f</span> f) x)))))))</div></pre></td></tr></table></figure><p>A：<code>(define ...)</code> 又能用了？</p><p>B：是，现在我们知道递归是什么了。</p><p>A：你知道为啥 <code>Y</code> 管用吗？</p><p>B：重新阅读本章你就懂了。</p><p>A：啥是 <code>(Y Y)</code>。</p><p>B：鬼知道，看起来很复杂。</p><p>A：你的帽子还合适不？</p><p>B：在如此一场头脑风暴之后很难说啊。</p><blockquote><p>Stop the World - I Want to Get Off.<br><em>Leslie Bricusse and Anthony Newley</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;http://kysmykseka.net/koti/wizardry/Programming/Lisp/Scheme/The%20Little%20Schemer%204th%20Ed.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;The Little Schemer 4th Edition Ch9 - …and Again, and Again, and Again, …&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;（这篇文章提到了 Y combinator。）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
