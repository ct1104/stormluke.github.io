<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Preferences</title>
  
  <subtitle>Luke&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://stormluke.me/"/>
  <updated>2018-04-21T06:53:32.032Z</updated>
  <id>http://stormluke.me/</id>
  
  <author>
    <name>stormluke</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高效管理 Elasticsearch 中基于时间的索引</title>
    <link href="http://stormluke.me/es-managing-time-based-indices-efficiently/"/>
    <id>http://stormluke.me/es-managing-time-based-indices-efficiently/</id>
    <published>2017-06-25T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.elastic.co/blog/managing-time-based-indices-efficiently" target="_blank" rel="external">And the big one said “Rollover” — Managing Elasticsearch time-based indices efficiently</a></p><p>用 Elasticsearch 来索引诸如日志事件等基于时间的数据的人可能已经习惯了“每日一索引”模式：使用以天为粒度的索引名字来存放当天的日志数据，一天过去后再建一个新索引。新索引的属性可以由<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html" target="_blank" rel="external">索引模板</a>来提前控制。</p><p>这种模式很容易理解并且易于实现，但是它粉饰了索引管理的一些复杂的地方：</p><ul><li>为了达到较高的写入速度，活跃索引分片需要分布在<em>尽可能多的</em>节点上。</li><li>为了提高搜索速度和降低资源消耗，分片数量需要<em>尽可能地少</em>，但是也不能有过大的单个分片进而不便操作</li><li>一天一个索引确实易于清理陈旧数据，但是一天到底需要多少个分片呢？</li><li>每天的写入压力是一成不变的吗？还是一天分片过多，而下一天分片不够用呢？</li></ul><p>在这篇文章中我将介绍新的”滚动模式“和用来实现它的 API 们，这个模式可以更加简单且高效地管理基于时间的索引。</p><a id="more"></a><h3 id="滚动模式"><a href="#滚动模式" class="headerlink" title="滚动模式"></a>滚动模式</h3><p>滚动模式工作流程如下：</p><ul><li>有一个用于写入的索引别名，其指向活跃索引</li><li>另外一个用于读取（搜索）的索引别名，指向不活跃索引</li><li>活跃索引具有和热节点数量一样多的分片，可以充分发挥昂贵硬件的索引写入能力</li><li>当活跃索引太满或者太老的时候，它就会<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html" target="_blank" rel="external">滚动</a>：新建一个索引并且索引别名自动从老索引切换到新索引</li><li>移动老索引到冷节点上并且<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html" target="_blank" rel="external">缩小</a>为一个分片，之后可以<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html" target="_blank" rel="external">强制合并</a>和压缩。</li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>假设我们有一个具有 10 个<em>热</em>节点和一个<em>冷</em>节点池的集群。理想情况下我们的活跃索引（接收所有写入的索引）应该在每个热节点上均匀分布一个分片，以此来尽可能地在多个机器上分散写入压力。</p><p>我们让每个主分片都有一个复制分片来允许一个节点失效而不丢失数据。这意味着我们的活跃索引应该有 5 个主分片，加起来一共 10 个分片（每个节点一个）。我们也可以用 10 个主分片（包含冗余一共 20 个分片），这样每个节点两个分片。</p><p>首先，为活跃索引创建一个<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html" target="_blank" rel="external">索引模版</a>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PUT _template/active-logs</div><div class="line">&#123;</div><div class="line">  <span class="attr">"template"</span>: <span class="string">"active-logs-*"</span>,</div><div class="line">  <span class="attr">"settings"</span>: &#123;</div><div class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">"routing.allocation.include.box_type"</span>: <span class="string">"hot"</span>,</div><div class="line">    <span class="attr">"routing.allocation.total_shards_per_node"</span>: <span class="number">2</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"aliases"</span>: &#123;</div><div class="line">    <span class="attr">"active-logs"</span>: &#123;&#125;, </div><div class="line">    <span class="attr">"search-logs"</span>: &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由这个模板创建的索引会被分配到标记为 <code>box_type:hot</code> 的节点上，而 <code>total_shards_per_node</code> 配置会保证将分片均匀分布在<em>热</em>节点中。我把其设置为 <code>2</code> 而不是 <code>1</code>，这样当一个节点失效时也可以继续分配分片。</p><p>我们将会用 <code>active-logs</code> 别名来写入当前的活跃索引，用 <code>search-logs</code> 别名来查询所有的日志索引。</p><p>下面是非活跃索引的模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PUT _template/inactive-logs</div><div class="line">&#123;</div><div class="line">  <span class="attr">"template"</span>: <span class="string">"inactive-logs-*"</span>, </div><div class="line">  <span class="attr">"settings"</span>: &#123; </div><div class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">1</span>, </div><div class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"routing.allocation.include.box_type"</span>: <span class="string">"cold"</span>,</div><div class="line">    <span class="attr">"codec"</span>: <span class="string">"best_compression"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>归档的索引应该被分配到<em>冷</em>节点上并且使用 <code>deflate</code> 压缩来节约磁盘空间。我会在之后解释为什么把 <code>replicas</code> 设置为 <code>0</code>。</p><p>现在可以创建第一个活跃索引了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PUT active-logs-1</div></pre></td></tr></table></figure><p>Rollover API 会将名字中的 <code>-1</code> 识别为一个计数器。</p><h3 id="索引日志事件"><a href="#索引日志事件" class="headerlink" title="索引日志事件"></a>索引日志事件</h3><p>当创建 <code>active-logs-1</code> 索引时，我们也创建了 <code>active-logs</code> 别名。在此之后，我们应该仅使用别名来写入，文档会被发送到当前的活动索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST active-logs/log/_bulk</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-01T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-02T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-03T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-04T01:00:00Z&quot; &#125;</div><div class="line">&#123; &quot;create&quot;: &#123;&#125;&#125; &#123; &quot;text&quot;: &quot;Some log message&quot;, &quot;@timestamp&quot;: &quot;2016-07-05T01:00:00Z&quot; &#125;</div></pre></td></tr></table></figure><h3 id="滚动索引"><a href="#滚动索引" class="headerlink" title="滚动索引"></a>滚动索引</h3><p>在某个时间点，活跃索引变得过大或者过老，这时你想用一个新的空索引来替换它。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html" target="_blank" rel="external">Rollover API</a> 允许你指定触发滚动操作的具体大小或者时间限制。</p><p>多大才是过大？一如以往，看情况。这取决于你的硬件性能，你的搜索操作的类型，你想要达到的性能效果和你能接受的分片恢复时间等等。可以从例如 1 亿或者 10 亿这种数字开始，依据搜索性能、数据保留时间和可用磁盘空间来上下调整。</p><p>一个分片能包含的文档数有一个硬限制：2147483519。如果你打算把活跃索引缩小到一个分片，那么活跃索引中的文档数不能超过 21 亿。如果活跃索引中的文档一个分片放不下，你可以将活跃索引缩小到多个分片，只要目标分片数是原来分片数的因子，例如 6 到 3 或者 6 到 2。</p><p>基于时间来滚动索引很方便，因为可以按照小时、天或者星期来整理索引。但其实按照索引中的文档数来滚动索引更加高效。按照数量来滚动的优点之一就是所有的分片会具有大致相同的大小，这样做负载均衡更加方便。</p><p>可以用定时任务来定期调用 rollover API 去检查是否到达了 <code>max_docs</code> 或者 <code>max_age</code> 限制。当超过某个限制时，索引就会被滚动。因为我们在例子中只索引了 5 个文档，我们将 <code>max_docs</code> 值设置为 <code>5</code>，并且（为了完整性）将 <code>max_age</code> 设置为一周：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST active-logs/_rollover</div><div class="line">&#123;</div><div class="line">  <span class="attr">"conditions"</span>: &#123;</div><div class="line">    <span class="attr">"max_age"</span>: <span class="string">"7d"</span>,</div><div class="line">    <span class="attr">"max_docs"</span>: <span class="number">5</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个请求告诉 Elasticsearch 去滚动 <code>active-logs</code> 别名指向的索引，如果这个索引至少在七天之前创建或者至少包含 5 个文档。应答如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"old_index"</span>: <span class="string">"active-logs-1"</span>,</div><div class="line">  <span class="attr">"new_index"</span>: <span class="string">"active-logs-2"</span>,</div><div class="line">  <span class="attr">"rolled_over"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"dry_run"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"conditions"</span>: &#123;</div><div class="line">    <span class="attr">"[max_docs: 5]"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"[max_age: 7d]"</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为满足了 <code>max_docs: 5</code> 条件，<code>active-logs-1</code> 索引被滚动到 <code>active-logs-2</code> 索引。这意味着一个叫做 <code>active-logs-2</code> 的索引被创建（基于 <code>active-logs</code> 模板），并且 <code>active-logs</code> 别名从 <code>active-logs-1</code> 切换到 <code>active-logs-2</code>。</p><p>顺带一提，如果你想覆写索引模板中的某些值（例如 <code>settings</code> 或者 <code>mappings</code>），只需要把它们放在 <code>_rollover</code> 的请求体中就可以（和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html" target="_blank" rel="external">创建索引 API</a> 一样）。</p><h4 id="为什么不支持-max-size-限制？"><a href="#为什么不支持-max-size-限制？" class="headerlink" title="为什么不支持 max_size 限制？"></a>为什么不支持 <code>max_size</code> 限制？</h4><p>既然想尽可能地让分片大小相似，为什么不在 <code>max_docs</code> 之外在加上支持 <code>max_size</code> 限制呢？答案是分片的大小并不是一个可靠的测量标准，因为正在进行中的合并会产生大量的临时分片大小增长，而当合并结束后这些增长会消失掉。五个主分片，每个都在合并到一个 5GB 分片的过程中，那么此时索引大小会临时增多 25GB！而对于文档数量来说，它的增长则是可以预测的。</p><h3 id="缩小索引"><a href="#缩小索引" class="headerlink" title="缩小索引"></a>缩小索引</h3><p>此时 <code>acitve-logs-1</code> 不再用于写入，我们可以把它移到冷节点上并且把它缩小到一个分片，这个新索引叫做 <code>inactive-logs-1</code>。在缩小之前，我们必须：</p><ul><li>设置索引为只读</li><li>将所有分片移动到同一个节点上。可以任意选择目标节点，比如选择具有最大剩余空间的<em>冷</em>节点</li></ul><p>用以下命令来做这些事情：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PUT active-logs-1/_settings</div><div class="line">&#123;</div><div class="line">  <span class="attr">"index.blocks.write"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"index.routing.allocation.require._name"</span>: <span class="string">"some_node_name"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>allocation</code> 配置保证了每个分片的至少一个拷贝会被移动到 <code>some_node_name</code> 节点上。这并不会移动所有分片——因为复制分片不能和主分片分配在同一个节点上——但它会保证至少一个主分片或者复制分片会被移动。</p><p>当索引完成迁移后（用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html" target="_blank" rel="external">集群健康 API</a> 来检查），使用一下请求来缩小索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST active-logs-1/_shrink/inactive-logs-1</div></pre></td></tr></table></figure><p>如果你的文件系统支持硬链接，那么缩小会瞬间完成。如果你的文件系统不支持硬链接，那你就得等待所有的分段文件从一个索引拷贝到另一个索引……</p><p>你可以用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html" target="_blank" rel="external">恢复状态查询 API</a> 或者集群健康 API 来监控缩小过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET _cluster/health/inactive-logs-1?wait_for_status=yellow</div></pre></td></tr></table></figure><p>当缩小完成后，你就可以从 <code>search-logs</code> 别名中删除老索引并加入新索引：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">POST _aliases</div><div class="line">&#123;</div><div class="line">  <span class="attr">"actions"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"remove"</span>: &#123;</div><div class="line">        <span class="attr">"index"</span>: <span class="string">"active-logs-1"</span>,</div><div class="line">        <span class="attr">"alias"</span>: <span class="string">"search-logs"</span></div><div class="line">      &#125; </div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"add"</span>: &#123;</div><div class="line">        <span class="attr">"index"</span>: <span class="string">"inactive-logs-1"</span>,</div><div class="line">        <span class="attr">"alias"</span>: <span class="string">"search-logs"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="节约空间"><a href="#节约空间" class="headerlink" title="节约空间"></a>节约空间</h3><p>我们的索引已经缩小到单个分片，但它依旧包含和之前相同数量的段文件，并且 <code>best_compression</code> 设置并没有生效，因为没有任何写入操作。我们可以用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html" target="_blank" rel="external">强制合并</a>来将单分片索引优化为单分段索引，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST inactive-logs-1/_forcemerge?max_num_segments=1</div></pre></td></tr></table></figure><p>这个请求会创建一个新的分段来替换之前的多个分段。并且因为 Elasticsearch 必须要写入新分段，<code>best_compression</code> 设置就会起作用，新分段会用 <code>deflate</code> 压缩写入。</p><p>在主分片和复制分片上分别运行强制合并是没有意义的，这就是为什么我们的非活跃索引模板中 <code>number_of_replicas</code> 设置被为 <code>0</code>。现在当强制合并结束后，我们可以打开复制分片以获得冗余：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUT inactive-logs-1/_settings</div><div class="line">&#123; <span class="attr">"number_of_replicas"</span>: <span class="number">1</span> &#125;</div></pre></td></tr></table></figure><p>当复制分片被分配之后（用 <code>?wait_for_status=green</code> API 查询），我们就可以确定拥有了一个冗余，此时便可以安全地删掉 <code>active-logs-1</code> 索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE active-logs-1</div></pre></td></tr></table></figure><h3 id="删除旧索引"><a href="#删除旧索引" class="headerlink" title="删除旧索引"></a>删除旧索引</h3><p>在使用老的每日一索引模式时，决定删除哪些索引十分方便。而在使用滚动模式时，似乎并不好确定索引包含了什么时间段的数据。</p><p>幸运的是，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html" target="_blank" rel="external">字段统计 API</a> 可以轻松确定这些。我们只需要具有找出超过我们阈值的最大 <code>@timestamp</code> 字段的索引列表就可以了：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET search-logs/_field_stats?level=indices</div><div class="line">&#123;</div><div class="line">  <span class="attr">"fields"</span>: [<span class="string">"@timestamp"</span>],</div><div class="line">  <span class="attr">"index_constraints"</span>: &#123;</div><div class="line">    <span class="attr">"@timestamp"</span>: &#123;</div><div class="line">      <span class="attr">"max_value"</span>: &#123;</div><div class="line">        <span class="attr">"lt"</span>: <span class="string">"2016/07/03"</span>,</div><div class="line">        <span class="attr">"format"</span>: <span class="string">"yyyy/MM/dd"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个请求返回的索引都可以删除。</p><h3 id="未来的改进"><a href="#未来的改进" class="headerlink" title="未来的改进"></a>未来的改进</h3><p>通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html" target="_blank" rel="external">滚动</a>、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html" target="_blank" rel="external">缩小</a>、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html" target="_blank" rel="external">强制合并</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html" target="_blank" rel="external">字段统计</a> API，我们向你提供了高效管理基于时间的索引的基础工具。</p><p>当然，这里有许多步骤可以被自动化来让生活更美好。这些步骤并在 Elasticsearch 中并不是很容易内置，因为我们需要在发生意料之外的情况时通知别人。这是在 Elasticsearch 之上构建的工具或应用程序的职责。</p><p>期待可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/index.html" target="_blank" rel="external">Curator index management tool</a> 和 <a href="https://www.elastic.co/guide/en/x-pack/current/index.html" target="_blank" rel="external">X-Pack</a> 中看到相应的工作流和 UI。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自：&lt;a href=&quot;https://www.elastic.co/blog/managing-time-based-indices-efficiently&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;And the big one said “Rollover” — Managing Elasticsearch time-based indices efficiently&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用 Elasticsearch 来索引诸如日志事件等基于时间的数据的人可能已经习惯了“每日一索引”模式：使用以天为粒度的索引名字来存放当天的日志数据，一天过去后再建一个新索引。新索引的属性可以由&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;索引模板&lt;/a&gt;来提前控制。&lt;/p&gt;
&lt;p&gt;这种模式很容易理解并且易于实现，但是它粉饰了索引管理的一些复杂的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了达到较高的写入速度，活跃索引分片需要分布在&lt;em&gt;尽可能多的&lt;/em&gt;节点上。&lt;/li&gt;
&lt;li&gt;为了提高搜索速度和降低资源消耗，分片数量需要&lt;em&gt;尽可能地少&lt;/em&gt;，但是也不能有过大的单个分片进而不便操作&lt;/li&gt;
&lt;li&gt;一天一个索引确实易于清理陈旧数据，但是一天到底需要多少个分片呢？&lt;/li&gt;
&lt;li&gt;每天的写入压力是一成不变的吗？还是一天分片过多，而下一天分片不够用呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇文章中我将介绍新的”滚动模式“和用来实现它的 API 们，这个模式可以更加简单且高效地管理基于时间的索引。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 YCSB 压力测试 HBase</title>
    <link href="http://stormluke.me/ycsb-hbase-readme/"/>
    <id>http://stormluke.me/ycsb-hbase-readme/</id>
    <published>2017-05-22T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.040Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/brianfrankcooper/YCSB" target="_blank" rel="external">YCSB</a>（Yahoo! Cloud Serving Benchmark）是雅虎开源的用于测试新式数据库（主要为 NoSQL）性能的框架，使用 Java 实现，可以测试 HBase、Cassandra、Infinispan、MongoDB 等等。</p><p>YCSB 包括两个部分：</p><ul><li>YCSB 客户端，一个可以扩展的 workload 生成器</li><li>Core workloads，预先配置好的 workloads</li></ul><a id="more"></a><h3 id="安装-YCSB"><a href="#安装-YCSB" class="headerlink" title="安装 YCSB"></a>安装 YCSB</h3><p>下载 <a href="https://github.com/brianfrankcooper/YCSB/releases/latest" target="_blank" rel="external">YCSB 最新发行版</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -O --location https://github.com/brianfrankcooper/YCSB/releases/download/0.12.0/ycsb-0.12.0.tar.gz</div><div class="line">tar xfvz ycsb-0.12.0.tar.gz</div><div class="line"><span class="built_in">cd</span> ycsb-0.12.0</div></pre></td></tr></table></figure><p>其中 <code>workloads</code> 文件夹中为预置的 Core workload，<code>*-binding</code> 文件夹中为预置的数据库接口层。</p><h3 id="运行一个压力测试"><a href="#运行一个压力测试" class="headerlink" title="运行一个压力测试"></a>运行一个压力测试</h3><p>运行一个压力测试需要 6 步：</p><ul><li>配置需要测试的数据库</li><li>选择合适的数据库接口层</li><li>选择合适的 workload</li><li>选择合适的运行时参数</li><li>装载数据（loading phase）</li><li>运行测试（transaction phase）</li></ul><p>这些步骤适合于在单个客户端上运行（小型和中型集群，10 个左右的服务节点），更大的集群需要多个客户端同时运行测试。</p><h4 id="第一步：配置需要测试的数据库"><a href="#第一步：配置需要测试的数据库" class="headerlink" title="第一步：配置需要测试的数据库"></a>第一步：配置需要测试的数据库</h4><p>YCSB 不负责表的创建，需要在数据库中手动创建用于测试的表。例如在 HBase 中，需要手动创建一个表和一个列族。</p><p>为了让测试数据均匀分布在不同节点中，创建 HBase 表时需要设置预先分片策略（参考 <a href="https://issues.apache.org/jira/browse/HBASE-4163" target="_blank" rel="external">HBASE-4163</a>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hbase(main):001:0&gt; n_splits = 20 # HBase recommends (10 * number of regionservers)</div><div class="line">hbase(main):002:0&gt; create &apos;usertable&apos;, &apos;cf&apos;, &#123;SPLITS =&gt; (1..n_splits).map &#123;|i| &quot;user#&#123;1000+i*(9999-1000)/n_splits&#125;&quot;&#125;&#125;</div></pre></td></tr></table></figure><p>这里 <code>n_splits</code> 推荐设置为 <code>RegionServer</code> 数量 * 10。</p><h4 id="第二步：选择合适的数据库接口层"><a href="#第二步：选择合适的数据库接口层" class="headerlink" title="第二步：选择合适的数据库接口层"></a>第二步：选择合适的数据库接口层</h4><p>YCSB 预置了一些常用数据库的接口层，对于 HBase 测试，需要选择 <code>com.yahoo.ycsb.db.HBaseClient</code> 作为接口。</p><p>另外 YCSB 需要知道如何连接到 HBase 的 Zookeeper 服务，最简单的方法是将目标测试服务器上的 HBase 配置文件 <code>$HBASE_HOME/conf/hbase-site.xml</code> 复制到 <code>$YCSB/hbase12/conf</code> 中（低版本 HBase 需要复制到对应的 <code>hbase10</code> 等文件夹中）。</p><p>YCSB 也提供了一个 <code>com.yahoo.ycsb.BasicDB</code> 数据库接口层，这个接口层仅仅打印收到的数据库操作请求，可以用来调试。</p><p>可以用 <code>bin/yscb shell &lt;interface&gt;</code> 来测试数据库接口层配置是否正确，例如使用 <code>BasicDB</code> 层：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ./bin/ycsb shell basic</div><div class="line">&gt; <span class="built_in">help</span></div><div class="line">Commands:</div><div class="line">  <span class="built_in">read</span> key [field1 field2 ...] - Read a record</div><div class="line">  scan key recordcount [field1 field2 ...] - Scan starting at key</div><div class="line">  insert key name1=value1 [name2=value2 ...] - Insert a new record</div><div class="line">  update key name1=value1 [name2=value2 ...] - Update a record</div><div class="line">  delete key - Delete a record</div><div class="line">  table [tablename] - Get or [<span class="built_in">set</span>] the name of the table</div><div class="line">  quit - Quit</div></pre></td></tr></table></figure><h4 id="第三步：选择合适的-workload"><a href="#第三步：选择合适的-workload" class="headerlink" title="第三步：选择合适的 workload"></a>第三步：选择合适的 workload</h4><p>Workload 定义了如何向数据库中加载测试数据，包括两个部分：</p><ul><li>Workload Java 类（<code>com.yahoo.ycsb.Workload</code> 的子类）</li><li>配置文件（Java Properties 格式）</li></ul><p>YCSB 的 CoreWorkload 预置了一些标准测试数据，可以直接使用，包括 6 个不同的类型：</p><ul><li>Workload A：<ul><li>重更新，50% 读 50% 写，例如 session sotre</li></ul></li><li>Workload B：<ul><li>读多写少，95% 读 5% 写，例如 photo tagging</li></ul></li><li>Workload C：<ul><li>只读：100% 读，例如 user profile cache</li></ul></li><li>Workload D：<ul><li>读最近更新：这个 workload 会插入新纪录，越新的纪录读取概率越大，例如：user status updates</li></ul></li><li>Workload E：<ul><li>小范围查询：这个 workload 会查询小范围的纪录，而不是单个纪录，例如：threaded conversations</li></ul></li><li>Workload F：<ul><li>读取-修改-写入：这个 workload 会读取一个纪录，然后修改这个纪录，最后写回，例如：user database</li></ul></li></ul><p>可以根据测试需求选择合适的 workload，也可以新建一个新的 workload。</p><h4 id="第四步：选择合适的运行时参数"><a href="#第四步：选择合适的运行时参数" class="headerlink" title="第四步：选择合适的运行时参数"></a>第四步：选择合适的运行时参数</h4><p>除了在 workload 中配置参数外，YCSB 还支持这些运行时参数：</p><ul><li><code>-threads</code>：客户端线程数，默认为 1</li><li><code>-target</code>：每秒的目标操作数，默认为无限制（尽可能快地完成操作）。例如一个操作需要 100 ms，那么一个线程 1s 内可以完成 10 个操作，通过 <code>-target</code> 参数可以将操作放缓，控制在 10 个以下</li><li><code>-s</code>：每 10s 打印一次客户端状态，用于调试</li></ul><h4 id="第五步：装载数据"><a href="#第五步：装载数据" class="headerlink" title="第五步：装载数据"></a>第五步：装载数据</h4><p>Workload 包含两个阶段：装载阶段和事务阶段。在装载阶段向数据库中插入测试数据。对于 HBase 测试，可以使用下面的命令装载数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/ycsb load hbase12 -P workloads/workloada -p table=usertable -p columnfamily=cf -p recordcount=100000000 -p operationcount=100000000 -thread 50 -s</div></pre></td></tr></table></figure><p>各个参数的含义为：</p><ul><li><code>hbase12</code>：使用 HBase 1.2.x 版本的数据库连接层</li><li><code>-P</code> 指定 workload 配置文件路径，使用 Workload A 类型</li><li><code>-p</code> 指定单个配置（会覆盖之前文件中的配置）<ul><li><code>table=</code>，<code>columnfamily=</code>, 指定 HBase 表名和列族</li><li><code>recordcount=</code>，<code>operationcount=</code>，指定纪录数和操作数</li></ul></li><li><code>-thread</code> 指定客户端线程数</li><li><code>-s</code> 打印状态</li></ul><h4 id="第六步：运行测试"><a href="#第六步：运行测试" class="headerlink" title="第六步：运行测试"></a>第六步：运行测试</h4><p>当装载完测试数据后，就可以运行 workload 测试了。对于 HBase 测试命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/ycsb run hbase12 -P workloads/workloada -p table=usertable -p columnfamily=cf -p recordcount=100000000 -p operationcount=100000000 -thread 50 -s</div></pre></td></tr></table></figure><p>参数含义与装载数据时相同，区别在用 <code>run</code> 替代了 <code>load</code>。</p><p>运行结束后可以看到 YCSB 打印出了一些测试统计结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">[OVERALL], RunTime(ms), 11551.0</div><div class="line">[OVERALL], Throughput(ops/sec), 8657.259111765215</div><div class="line">[TOTAL_GCS_PS_Scavenge], Count, 12.0</div><div class="line">[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 66.0</div><div class="line">[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.5713791013765043</div><div class="line">[TOTAL_GCS_PS_MarkSweep], Count, 0.0</div><div class="line">[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 0.0</div><div class="line">[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0</div><div class="line">[TOTAL_GCs], Count, 12.0</div><div class="line">[TOTAL_GC_TIME], Time(ms), 66.0</div><div class="line">[TOTAL_GC_TIME_%], Time(%), 0.5713791013765043</div><div class="line">[READ], Operations, 50011.0</div><div class="line">[READ], AverageLatency(us), 4418.49443122513</div><div class="line">[READ], MinLatency(us), 1584.0</div><div class="line">[READ], MaxLatency(us), 208895.0</div><div class="line">[READ], 95thPercentileLatency(us), 8207.0</div><div class="line">[READ], 99thPercentileLatency(us), 11463.0</div><div class="line">[READ], Return=OK, 50011</div><div class="line">[CLEANUP], Operations, 100.0</div><div class="line">[CLEANUP], AverageLatency(us), 1393.0</div><div class="line">[CLEANUP], MinLatency(us), 1.0</div><div class="line">[CLEANUP], MaxLatency(us), 138623.0</div><div class="line">[CLEANUP], 95thPercentileLatency(us), 18.0</div><div class="line">[CLEANUP], 99thPercentileLatency(us), 258.0</div><div class="line">[UPDATE], Operations, 49989.0</div><div class="line">[UPDATE], AverageLatency(us), 6124.871431714977</div><div class="line">[UPDATE], MinLatency(us), 1947.0</div><div class="line">[UPDATE], MaxLatency(us), 429311.0</div><div class="line">[UPDATE], 95thPercentileLatency(us), 10087.0</div><div class="line">[UPDATE], 99thPercentileLatency(us), 15335.0</div><div class="line">[UPDATE], Return=OK, 49989</div></pre></td></tr></table></figure><p>各个参数的含义在结果解析中解释。</p><p>如果想获得直方图或者时间序列结果（参考测量参数），可以使用 <code>measurementtype=timeseries</code> 参数。客户端默认每 1s 纪录一次平均延迟，可以通过 <code>timeseries.granularity=2000</code> 参数（毫秒）来修改。此时测试报告为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">[READ], 0, 12064.403652090341</div><div class="line">[READ], 1000, 6515.2218055956155</div><div class="line">[READ], 2000, 5907.763636363637</div><div class="line">[READ], 3000, 4967.781086610593</div><div class="line">[READ], 4000, 4397.277823577906</div><div class="line">[READ], 5000, 5179.516736401673</div><div class="line">[READ], 6000, 4398.908602150537</div><div class="line">[READ], 7000, 4493.980899323517</div><div class="line">[READ], 8000, 4431.4615697437985</div><div class="line">[READ], 9000, 4365.6925873560895</div><div class="line">[READ], 10000, 5771.521574205784</div><div class="line">[READ], 11000, 4300.872277227722</div><div class="line">[READ], 12000, 3728.5879396984924</div><div class="line">...</div></pre></td></tr></table></figure><p>此时整个测试过程就结束了。</p><p>注意 YCSB 的延迟为端到端的延迟，在开始调用数据库接口层方法前开始计时，在方法返回时结束计时，也就是说延迟包括这几个部分：</p><ul><li>在接口层内代码的运行时间</li><li>客户端到数据库服务器的网络延迟</li><li>数据库的执行时间</li></ul><p>其中并不包括由 <code>-target</code> 节流参数引入的延迟。</p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><h4 id="YCSB-参数"><a href="#YCSB-参数" class="headerlink" title="YCSB 参数"></a>YCSB 参数</h4><p>所有的 workload 文件都可以使用以下参数：</p><ul><li><code>workload</code>：workload 类</li><li><code>db</code>：数据库接口层类，默认为 <code>com.yahoo.ycsb.BasicDB</code>，也可以通过命令行指定</li><li><code>exporter</code>：报告类，默认为 <code>com.yahoo.ycsb.measurements.exporter.TextMeasurementsExporter</code></li><li><code>exportfile</code>：报告输出路径，默认 <code>stdout</code></li><li><code>threadcount</code>：客户端线程数，默认 1</li><li><code>measurementtype</code>：测量类型，支持 <code>histogram</code> 和 <code>timeseries</code>，默认 <code>histogram</code></li></ul><h4 id="预置-Core-workload-包参数"><a href="#预置-Core-workload-包参数" class="headerlink" title="预置 Core workload 包参数"></a>预置 Core workload 包参数</h4><p>预置的 workload 支持以下参数：</p><ul><li><code>fieldcount</code>：每个纪录中字段的个数，默认：10</li><li><code>fieldlength</code>：每个字段的大小，默认：100</li><li><code>readallfields</code>：是否读取所有字段还是一个字段，默认：true（读取所有字段）</li><li><code>readproportion</code>：读取操作所占比例，默认 0.95</li><li><code>updateproportion</code>：更新操作所占比例，默认 0.05</li><li><code>insertproportion</code>：插入操作所占比例，默认 0</li><li><code>scanproportion</code>：扫描操作所占比例，默认 0</li><li><code>readmodifywriteproportion</code>：读-更新-写操作所占比例：默认 0</li><li><code>requestdistribution</code>：请求的概率分布类型，支持 <code>uniform</code>、<code>zipfian</code>、<code>latest</code>，默认 <code>uniform</code><ul><li><code>uniform</code>：均匀分布</li><li><code>zipfian</code>：<a href="https://www.wikiwand.com/zh/%E9%BD%8A%E5%A4%AB%E5%AE%9A%E5%BE%8B" target="_blank" rel="external">齐夫分布</a></li><li><code>latest</code>：数据越新访问概率越高</li></ul></li><li><code>maxscanlength</code>：扫描操作最长的范围，默认 1000</li><li><code>scanlengthdistribution</code>：扫描操作范围的概率分布类型（从 1 到 <code>scanlengthdistribution</code>），默认 <code>uniform</code></li><li><code>insertorder</code>：插入顺序<ul><li><code>ordered</code>：根据 key 排序插入</li><li><code>hashed</code>：根据 hash 结果排序插入</li></ul></li><li><code>operationcount</code>：操作数</li><li><code>maxexecutiontime</code>：最长总体执行时间（秒）</li><li><code>table</code>：数据库表名，默认 <code>usertable</code></li><li><code>recordcount</code>：纪录数，默认 0</li><li><code>core_workload_insertion_retry_limit</code>：插入失败重试次数，默认 0</li><li><code>core_workload_insertion_retry_interval</code>：重试间隔（秒），默认 3</li></ul><h4 id="测量参数"><a href="#测量参数" class="headerlink" title="测量参数"></a>测量参数</h4><ul><li><code>hdrhistogram</code> 生成 <code>hdrhistogram</code> 格式的报告，可以使用 <a href="http://hdrhistogram.github.io/HdrHistogram/plotFiles.html" target="_blank" rel="external">HdrHistogram Plotter</a> 展示图形结果<ul><li><code>hdrhistogram.percentiles</code>：测量百分位分区，用逗号隔开，默认 95,99（参考<a href="https://www.zhihu.com/question/20575291" target="_blank" rel="external">第95个百分位（95th percentile）是什么概念？</a>）</li><li><code>hdrhistogram.fileoutput=true|false</code>：是否输出到文件，文件地址由 <code>hdrhistogram.output.path</code> 指定</li></ul></li><li><code>histogram</code><ul><li><code>histogram.buckets</code>：直方图的分区数，默认 1000</li></ul></li><li><code>timeseries</code><ul><li><code>timeseries.granularity</code>：时间序列的粒度（毫秒），默认 1000</li></ul></li></ul><h3 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析"></a>结果解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[OVERALL], RunTime(ms), 16487.0</div><div class="line">[OVERALL], Throughput(ops/sec), 6065.384848668648</div></pre></td></tr></table></figure><ul><li><code>[OVERALL]</code> 区显示测试总体情况<ul><li><code>RunTime(ms)</code> 运行总时间</li><li><code>Throughput(ops/sec)</code> 吞吐量，每秒操作数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[TOTAL_GCS_PS_Scavenge], Count, 23.0</div><div class="line">[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 88.0</div><div class="line">[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.5337538666828411</div><div class="line">[TOTAL_GCS_PS_MarkSweep], Count, 0.0</div><div class="line">[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 0.0</div><div class="line">[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0</div><div class="line">[TOTAL_GCs], Count, 23.0</div><div class="line">[TOTAL_GC_TIME], Time(ms), 88.0</div><div class="line">[TOTAL_GC_TIME_%], Time(%), 0.5337538666828411</div></pre></td></tr></table></figure><ul><li><code>[TOTAL_GC*]</code> 区显示垃圾回收情况（<a href="http://www.jdon.com/idea/jvm-gc.html" target="_blank" rel="external">JVM有关垃圾回收机制的配置</a>）<ul><li><code>[TOTAL_GCS_PS_Scavenge], Count, 23.0</code> Parallel Scavenge 回收次数</li><li><code>[TOTAL_GC_TIME_PS_Scavenge], Time(ms), 88.0</code> Parallel Scavenge 回收时间</li><li><code>[TOTAL_GC_TIME_%_PS_Scavenge], Time(%), 0.5337538666828411</code> Parallel Scavenge 回收时间百分比</li><li><code>[TOTAL_GCS_PS_MarkSweep], Count, 0.0</code> PS MarkSweep 回收次数</li><li><code>[TOTAL_GC_TIME_PS_MarkSweep], Time(ms), 0.0</code> PS MarkSweep 回收时间</li><li><code>[TOTAL_GC_TIME_%_PS_MarkSweep], Time(%), 0.0</code> PS MarkSweep 回收时间百分比</li><li><code>[TOTAL_GCs], Count, 23.0</code> 全局 GC 次数</li><li><code>[TOTAL_GC_TIME], Time(ms), 88.0</code> 全局 GC 时间</li><li><code>[TOTAL_GC_TIME_%], Time(%), 0.5337538666828411</code> 全局 GC 时间百分比</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[READ], Operations, 50011.0</div><div class="line">[READ], AverageLatency(us), 4418.49443122513</div><div class="line">[READ], MinLatency(us), 1584.0</div><div class="line">[READ], MaxLatency(us), 208895.0</div><div class="line">[READ], 95thPercentileLatency(us), 8207.0</div><div class="line">[READ], 99thPercentileLatency(us), 11463.0</div><div class="line">[READ], Return=OK, 50011</div></pre></td></tr></table></figure><ul><li><code>[READ]</code> 区显示读取操作的统计结果<ul><li><code>Operations</code> 总操作数</li><li><code>AverageLatency(us)</code> 平均延迟（微秒）</li><li><code>MinLatency(us)</code> 最小延迟</li><li><code>MaxLatency(us)</code> 最大延迟</li><li><code>95thPercentileLatency(us)</code> 第 95 百分位延迟（<a href="https://www.zhihu.com/question/20575291" target="_blank" rel="external">第95个百分位（95th percentile）是什么概念？</a>）</li><li><code>99thPercentileLatency(us)</code> 第 99 百分位延迟</li><li><code>Return=OK, 50011</code> 结果（正确），总操作数</li></ul></li></ul><p><code>[CLEANUP]</code>（清理操作）、<code>[UPDATE]</code>（更新操作）等等和 <code>[READ]</code> 区类似，不再介绍。</p><h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h3><p>客户端默认会读取并操作所有的测试记录数据，在想多个客户端并行测试时这可能有些问题。可以用 <code>insertstart</code> 和 <code>insertcount</code> 两个参数来限制客户端操作测试纪录的范围，例如对于 4 个客户端测试 100000000 条纪录可以这样配置：</p><p>第一个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=0</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure><p>第二个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=25000000</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure><p>第三个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=50000000</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure><p>第四个客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insertstart=75000000</div><div class="line">insertcount=25000000</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/brianfrankcooper/YCSB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YCSB&lt;/a&gt;（Yahoo! Cloud Serving Benchmark）是雅虎开源的用于测试新式数据库（主要为 NoSQL）性能的框架，使用 Java 实现，可以测试 HBase、Cassandra、Infinispan、MongoDB 等等。&lt;/p&gt;
&lt;p&gt;YCSB 包括两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YCSB 客户端，一个可以扩展的 workload 生成器&lt;/li&gt;
&lt;li&gt;Core workloads，预先配置好的 workloads&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 拾遗 02 - Java 7 的异常处理</title>
    <link href="http://stormluke.me/about-java-02/"/>
    <id>http://stormluke.me/about-java-02/</id>
    <published>2016-08-03T12:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Multicatch"><a href="#Multicatch" class="headerlink" title="Multicatch"></a>Multicatch</h3><p>Java 7 新加了 multicatch 特性，一个 <code>catch</code> 语句中可以捕获多种异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  String fileText = getFile(fileName);</div><div class="line">  cfg = verifyConfig(parseConfig(fileText));</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException | ParseException | ConfigurationException e) &#123;</div><div class="line">  System.err.println(<span class="string">"Config file '"</span> + fileName + <span class="string">"' is missing or malformed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="final-重抛"><a href="#final-重抛" class="headerlink" title="final 重抛"></a>final 重抛</h3><p>Java 7 之前重抛异常时会被强制限制为 <code>catch</code> 到的异常类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  doSomethingWhichMightThrowIOException();</div><div class="line">  doSomethingElseWhichMightThrowSQLException();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">  <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码中的 <code>e</code> 可能为 <code>IOException</code> 或者 <code>SQLException</code> 类型，但是真实的类型被覆盖了。Java 7 中可以用 <code>final</code> 来修饰异常类型，这样重抛时的类型不会被改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  doSomethingWhichMightThrowIOException();</div><div class="line">  doSomethingElseWhichMightThrowSQLException();</div><div class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">  <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>Java 中关闭资源的时候很容易出错，比如关闭一个流要记得先检查 <code>null</code>，再 <code>try</code> <code>close()</code>，出现异常还要记得处理（一般什么也做不了）等等。Java 7 中加入了自动管理资源的特性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">     InputStream is = url.openStream()) &#123;</div><div class="line">  <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</div><div class="line">  <span class="keyword">int</span> len;</div><div class="line">  <span class="keyword">while</span> ((len = is.read(buf)) &gt; <span class="number">0</span>) &#123;</div><div class="line">    out.write(buf, <span class="number">0</span>, len);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码结束后会自动关闭资源。但是要小心，这样写是不对的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"someFile.bin"</span>))) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部的 <code>new FileInputStream(&quot;someFile.bin&quot;)</code> 如果失败并不会被关闭，正确的方法是为每个资源声明独立变量。</p><p>TWR 还有个好处是改善了异常堆栈，比如说会抑制异常堆栈中的 <code>NullPointerException</code> 等等。</p><p>TWR 依靠新接口 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html" target="_blank" rel="external"><code>AutoCloseable</code></a> 实现，Java 7 大部分的资源类都实现了这个接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Multicatch&quot;&gt;&lt;a href=&quot;#Multicatch&quot; class=&quot;headerlink&quot; title=&quot;Multicatch&quot;&gt;&lt;/a&gt;Multicatch&lt;/h3&gt;&lt;p&gt;Java 7 新加了 multicatch 特性，一个 &lt;code&gt;catch&lt;/code&gt; 语句中可以捕获多种异常：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  String fileText = getFile(fileName);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  cfg = verifyConfig(parseConfig(fileText));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (FileNotFoundException | ParseException | ConfigurationException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  System.err.println(&lt;span class=&quot;string&quot;&gt;&quot;Config file &#39;&quot;&lt;/span&gt; + fileName + &lt;span class=&quot;string&quot;&gt;&quot;&#39; is missing or malformed&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 拾遗 01 - Colleciton 基础</title>
    <link href="http://stormluke.me/about-java-01/"/>
    <id>http://stormluke.me/about-java-01/</id>
    <published>2016-08-03T00:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://docs.oracle.com/javase/tutorial/collections/index.html" target="_blank" rel="external">Oracle 的文档</a>中提到，Collection 是：</p><ul><li>接口</li><li>实现</li><li>算法</li></ul><a id="more"></a><p>的集合。Collection 的好处有：</p><ul><li>减少编程工作量</li><li>提高程序速度和质量</li><li>允许无关的API之间的互操作性</li><li>让学习和使用新 API 更省力</li><li>让设计新 API 更省力</li><li>促进软件重用</li></ul><p>Java 中的基础 Collection 接口有：</p><ul><li><code>Set</code> / <code>SortedSet</code></li><li><code>List</code><ul><li><code>Queue</code> / <code>Deque</code>（双端队列，Double Ended QUEue）</li></ul></li><li><code>Map</code> / <code>SortedMap</code></li></ul><p>Java 对这些接口提供了一些通用的实现：</p><ul><li><code>Set</code><ul><li><code>HashSet</code>，Java 1.2，无序，散列</li><li><code>TreeSet</code>，Java 1.2，升序，红黑树</li><li><code>LinkedHashSet</code>，Java 1.4，插入序，散列</li></ul></li><li><code>List</code><ul><li><code>ArrayList</code>，Java 1.2，数组</li><li><code>LinkedList</code>，Java 1.2，链表</li><li><code>ArrayDeque</code>，Java 1.6，数组</li></ul></li><li><code>Map</code><ul><li><code>HashMap</code>，Java 1.2，无序，散列</li><li><code>TreeMap</code>，Java 1.2，升序，红黑树</li><li><code>LinkedHashMap</code>，Java 1.4，插入序，散列</li></ul></li></ul><p>它们之间的关系如下：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1f6ghss8lpvj20z00zejw5.jpg" alt=""></p><p>值得注意的是 <code>Map</code> 不遵循 <code>Collection</code>，<code>Set</code> 的实现依赖于 <code>Map</code>。这些 Collection 均没有考虑线程安全。</p><p>某些面试题中问到 <code>Vector</code> 和 <code>ArrayList</code> 的区别，主要有以下几点：</p><ul><li><code>Vector</code> 在 Java 1.0 加入，<code>ArrayList</code> 在 Java 1.2 加入</li><li><code>Vector</code> 线程安全（由 <code>synchronized</code> 实现），<code>ArrayList</code> 没考虑线程安全，但有专门的易互转的 <code>CopyOnWriteArrayList</code> 等来应对多线程应用</li><li><code>Vector</code> 每次扩容一倍，<code>ArrayList</code> 扩容 50%</li><li>在<a href="https://dzone.com/articles/java-collection-performance" target="_blank" rel="external">这个 benchmark</a> 中 <code>Vector</code> 比 <code>ArrayList</code> 略慢</li></ul><p>所以 <code>Vector</code> 一般存在于面试题中。同样，<code>Hashtable</code>、<code>Dictionary</code>、<code>BitSet</code>、<code>Stack</code>、<code>Properties</code> 这些类也都是遗留的。</p><p>关于不同 Collection 的算法实现效率，可以参考 <a href="http://bigocheatsheet.com/" target="_blank" rel="external">Big-O Cheat Sheet（Java 无关）</a>／<a href="http://stackoverflow.com/a/559862" target="_blank" rel="external">big-o-summary-for-java-collections-framework-implementations（Java 相关）</a>。</p><p>更多关于 Collection 的参考：</p><ul><li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/collections/overview.html" target="_blank" rel="external">Collections Framework Overview</a></li><li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/collections/reference.html" target="_blank" rel="external">Annotated Outline of Collections Framework</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Oracle 的文档&lt;/a&gt;中提到，Collection 是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WWDC16 笔记——协议和值在 UIKit 中的应用</title>
    <link href="http://stormluke.me/wwdc-2016-session-419-note/"/>
    <id>http://stormluke.me/wwdc-2016-session-419-note/</id>
    <published>2016-07-05T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.040Z</updated>
    
    <content type="html"><![CDATA[<p>这个 <a href="http://asciiwwdc.com/2016/sessions/419" target="_blank" rel="external">Session</a> 通过一个 App 实例讲解了协议和值类型在 UIKit 中的应用。</p><h3 id="Local-Reasoning"><a href="#Local-Reasoning" class="headerlink" title="Local Reasoning"></a>Local Reasoning</h3><p>Local reasoning 是指，当看到面前的代码时，不必考虑其他代码是如何和它交互的。这让代码更容易维护，更容易编写，更容易测试。</p><p>下面通过一个实际的 App 来说明。这个 App 叫做 <a href="https://developer.apple.com/go/?id=lucid-dreams" target="_blank" rel="external">Lucid Dreams</a>，它用来记录程序员做过的白日梦。</p><a id="more"></a><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5ja7n5g1nj20qe0ssn03.jpg" alt=""></p><h3 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h3><p>一个梦的模型可能是这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dream</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> description: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> creature: <span class="type">Creature</span></div><div class="line">  <span class="keyword">var</span> effects: <span class="type">SetEffect</span>&gt;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但 <code>class</code> 型是引用语义，这会带来一个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dream1 = <span class="type">Dream</span>(...)</div><div class="line"><span class="keyword">var</span> dream2 = dream1</div><div class="line">dream2.description = <span class="string">"Unicorns all over"</span></div></pre></td></tr></table></figure><p>改变 <code>dream2</code> 会导致 <code>dream1</code> 一起变化：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jaj4vetoj20so0lwmyq.jpg" alt=""></p><p>不同的对象间关系复杂，<code>class</code> 的引用语义在这里会造成不小麻烦：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbjw1f5jaiuk123j219q0saads.jpg" alt=""></p><p>这不符合 local reasoning，可以用 <code>struct</code> 型来改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dream</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> description: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> creature: <span class="type">Creature</span></div><div class="line">  <span class="keyword">var</span> effects: <span class="type">SetEffect</span>&gt;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> dream1 = <span class="type">Dream</span>(...)</div><div class="line"><span class="keyword">var</span> dream2 = dream1</div></pre></td></tr></table></figure><p>此时两个 <code>dream</code> 是不同的：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jal1fignj20ju0r6myw.jpg" alt=""></p><h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p>这个 App 里有一个列表来显示做过的梦，它的 <code>UITableViewCell</code> 是这样的继承结构：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5japsvp5lj21ag0ne0vv.jpg" alt=""></p><p>这样做层次分明，但问题来了，在梦的详情页面里有个几乎一模一样的界面来展示梦的缩略图和标题，但它是个直接继承 <code>UIView</code> 的视图：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jase7k6bj21kw0kz42q.jpg" alt=""></p><p>仅仅是因为子类类型的区别，相同的视图代码重复写了两次。更严重的是，之后还想用 <code>SKNode</code> 来展示同样的界面，只是缩略图是动态的，难道还要再复制粘贴一份代码吗？当然不是，这些界面有相似之处，即布局相同，可以把它们的布局逻辑抽象成同一个对象来减少重复：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbjw1f5jaymru9gj21kw0ivta6.jpg" alt=""></p><p>把布局代码单独抽取出来作为 <code>DecoratingLayout</code>，它有一个只关心如何布局的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">UIView</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">UIView</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="comment">// Perform layout...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来布局逻辑和 <code>UITableViewCell</code> 解耦，可以用在 <code>UIView</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamCell</span> : <span class="title">UITableViewCell</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line">    decoratingLayout.layout(<span class="keyword">in</span>: bounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamDetailView</span> : <span class="title">UIView</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line">    decoratingLayout.layout(<span class="keyword">in</span>: bounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样做还有一个好处，就是测试代码更容易写，不需要创建 <code>UITableView</code> 就可以测试布局：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> child1 = <span class="type">UIView</span>()</div><div class="line">  <span class="keyword">let</span> child2 = <span class="type">UIView</span>()</div><div class="line">  <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)</div><div class="line">  layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(child1.frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>UIView</code> 和 <code>UITableViewCell</code> 的问题解决了，<code>SKNode</code> 的问题还没有。这主要是因为在 <code>DecoratingLayout</code> 里强制限定了 <code>UIView</code> 类型，把它换成一个 <code>protocol Layout</code> 即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span>: <span class="title">Layout</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Child</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="comment">// Perform layout...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> frame: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span> </span>&#123;&#125;</div></pre></td></tr></table></figure><p>现在又有一个新的视图，它和之前的布局相似，只是缩略图变成了层叠的：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5jbsrbw8sj21580eq0u5.jpg" alt=""></p><p>可以用组合 <code>UIView</code> 的方式解决这个问题，把视图分为两个部分，一个负责层叠的缩略图部分，一个负责整体的横向布局：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5jbtwihisj21340im3zc.jpg" alt=""></p><p>但是注意：</p><ul><li><code>class</code> 实例开销很大！</li><li><code>struct</code> 开销却很小</li><li>组合和值类型配合得更好</li></ul><p>所以说可以用组合 <code>struct</code> 来改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayoutChild</span> : <span class="title">Layout</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">var</span> children: [<span class="type">Child</span>]</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看起来不错，但 <code>CascadingLayout</code> 和 <code>DecoratingLayout</code> 都有 <code>layout</code> 方法，而且布局并不需要读写 <code>frame</code> 这么大的权限，因此可以用 <code>protocol Layout</code> 来泛化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>, ...&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayoutChild</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> decoration = <span class="type">CascadingLayout</span>(children: accessories)</div><div class="line"><span class="keyword">var</span> composedLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line"></div><div class="line">composedLayout.layout(<span class="keyword">in</span>: rect)</div></pre></td></tr></table></figure><p>还有个问题，层叠视图中的子视图具有先后的顺序关系，需要在 <code>protocol</code> 中体现它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Layout</span>] &#123; <span class="keyword">get</span> &#125; <span class="comment">// UIView and SKNode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但这样一来 <code>content</code> 的类型限制就没了。怎么办？用 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md" target="_blank" rel="external"><code>associatedtype</code></a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  associatedtype <span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Child</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>问题又来了，<code>content</code> 和 <code>decoration</code> 类型一致（<code>Child</code>），两个都是 <code>UIView</code> 时固然没错，但如果想如下布局该怎么办？</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5jcyc5n7nj20p60egmyb.jpg" alt=""></p><p>改类型，用约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>, <span class="title">Decoration</span> : <span class="title">Layout</span></span></div><div class="line"><span class="class">                        <span class="title">where</span> <span class="title">Child</span>.<span class="title">Content</span> == <span class="title">Decoration</span>.<span class="title">Content</span>&gt; : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Decoration</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>终于结束了。好处也是有的，测试时不必使用真正的 <code>UIView</code> 类型，随便换个遵循 <code>protocol Layout</code>的就可以了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> child1 = <span class="type">TestLayout</span>()</div><div class="line">  <span class="keyword">let</span> child2 = <span class="type">TestLayout</span>()</div><div class="line">  <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)</div><div class="line">  layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">0</span>].frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">1</span>].frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestLayout</span> : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> frame: <span class="type">CGRect</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="控制器层"><a href="#控制器层" class="headerlink" title="控制器层"></a>控制器层</h3><p>这个 App 还有一个功能：摇晃撤销上次修改。相关的代码是这样写的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]</div><div class="line">  <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>dreams</code> 和 <code>favoriteCreature</code> 都要支持撤销操作，它们均被撤销管理器管理：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5k0jbwx61j218a0lcq4q.jpg" alt=""></p><p>这就有问题了，每个属性都要写一份自己的撤销操作代码，如果之后有更多的属性，那就得写更多的重复代码。怎么办？可以把这些属性封装成一个整体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> model: <span class="type">Model</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span> : <span class="title">Equatable</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]</div><div class="line">  <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来每次撤销操作都操作一个整体模型，避免了把琐碎的撤销操作分散到不同的地方：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1f5k0pprxm1j21iw10q796.jpg" alt=""></p><p>整体容易撤销操作了，但具体的界面更新怎么办？根据模型变化部分更新：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">modelDidChange</span><span class="params">(old: Model, new: Model)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> old.favoriteCreature != new.favoriteCreature &#123;</div><div class="line">      <span class="comment">// Reload table view section for favorite creature.</span></div><div class="line">      tableView.reloadSections(...)</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    undoManager?.registerUndo(withTarget: <span class="keyword">self</span>, handler: &#123; target <span class="keyword">in</span></div><div class="line">      target.model = old</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个 App 还有三种不同的状态，浏览、选择、分享。这些状态的相关代码分成了好几个属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> isInViewingMode: <span class="type">Bool</span></div><div class="line">  <span class="keyword">var</span> sharingDreams: [<span class="type">Dream</span>]?</div><div class="line">  <span class="keyword">var</span> selectedRows: <span class="type">IndexSet</span>?</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这不好，因为改变其中一个属性的同时还要记得改变相关的属性。用一个 <code>struct</code> 模型来改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> state: <span class="type">State</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> viewing</div><div class="line">  <span class="keyword">case</span> sharing(dreams: [<span class="type">Dream</span>])</div><div class="line">  <span class="keyword">case</span> selecting(selectedRows: <span class="type">IndexSet</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最终整体的 MVC 结构如下：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5k5mxg7elj21kw0tmaea.jpg" alt=""></p><ul><li>通过组合来自定义</li><li>使用 <code>protocol</code> 来编写通用的、可重用的代码</li><li>多利用值语义的优点</li><li>Local reasoning</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个 &lt;a href=&quot;http://asciiwwdc.com/2016/sessions/419&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Session&lt;/a&gt; 通过一个 App 实例讲解了协议和值类型在 UIKit 中的应用。&lt;/p&gt;
&lt;h3 id=&quot;Local-Reasoning&quot;&gt;&lt;a href=&quot;#Local-Reasoning&quot; class=&quot;headerlink&quot; title=&quot;Local Reasoning&quot;&gt;&lt;/a&gt;Local Reasoning&lt;/h3&gt;&lt;p&gt;Local reasoning 是指，当看到面前的代码时，不必考虑其他代码是如何和它交互的。这让代码更容易维护，更容易编写，更容易测试。&lt;/p&gt;
&lt;p&gt;下面通过一个实际的 App 来说明。这个 App 叫做 &lt;a href=&quot;https://developer.apple.com/go/?id=lucid-dreams&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lucid Dreams&lt;/a&gt;，它用来记录程序员做过的白日梦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>东西@2016</title>
    <link href="http://stormluke.me/things-2016/"/>
    <id>http://stormluke.me/things-2016/</id>
    <published>2016-06-20T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.038Z</updated>
    
    <content type="html"><![CDATA[<ul><li><del>Synology DiskStation DS216j</del> (WD MyCloud)</li><li><del>Apple iPad mini 4 64GB</del> (Apple iPad Air 2 128GB)</li><li><del>Sandisk CZ88</del></li><li><del>NETGEAR R7000</del> (极路由 3)</li><li><del>Logi BASE Charging Stand with Smart Connector for iPad Pro</del></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;del&gt;Synology DiskStation DS216j&lt;/del&gt; (WD MyCloud)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Apple iPad mini 4 64GB&lt;/del&gt; (Apple iPad Air 2 128GB)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Sandisk CZ88&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;NETGEAR R7000&lt;/del&gt; (极路由 3)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Logi BASE Charging Stand with Smart Connector for iPad Pro&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大数据的哈希学习：入门教程 － 引子</title>
    <link href="http://stormluke.me/learning-to-hash-intro/"/>
    <id>http://stormluke.me/learning-to-hash-intro/</id>
    <published>2016-05-07T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.035Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://cs.nju.edu.cn/lwj/slides/L2H.pdf" target="_blank" rel="external">Learning to Hash for Big Data: A Tutorial</a>。</p><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><h4 id="大数据中的最近邻搜索"><a href="#大数据中的最近邻搜索" class="headerlink" title="大数据中的最近邻搜索"></a>大数据中的最近邻搜索</h4><p>最近邻搜索（Nearest Neighbor Search）：给定查询点 q，返回数据库中距离 q 最近（最相似）的点集。</p><ul><li>Facebook：7.5 亿用户</li><li>Flickr：6 千万照片</li><li>Wal-Mart: 每天 2.67 亿商品；4PB 数据仓库</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%B2%E9%9A%86%E6%95%B8%E4%BD%8D%E5%B7%A1%E5%A4%A9" target="_blank" rel="external">Sloan Digital Sky Survery</a>：新墨西哥州望远镜每天获取 200GB 图像数据</li></ul><a id="more"></a><p>大数据中的最近邻搜索挑战：</p><ul><li>维数灾难</li><li>存储</li><li>查询速度</li></ul><h4 id="Similarity-Preserving-Hashing（相似保留哈希）"><a href="#Similarity-Preserving-Hashing（相似保留哈希）" class="headerlink" title="Similarity Preserving Hashing（相似保留哈希）"></a>Similarity Preserving Hashing（相似保留哈希）</h4><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f60tbwescjj21gg0w6dug.jpg" alt=""></p><p>让无关图像对应的哈希编码尽可能不同，让相似图像的哈希编码尽可能相同。</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f60tbcewrvj211q0uun0o.jpg" alt=""></p><p>存储空间需求减少。</p><p>使用哈希编码来建立索引，可以达到常数或次线性查询时间复杂度。</p><p>某些情况下线性时间的全搜索也可以接受，因为二进制表示下的距离计算消耗很低。</p><h4 id="哈希函数学习的两个阶段"><a href="#哈希函数学习的两个阶段" class="headerlink" title="哈希函数学习的两个阶段"></a>哈希函数学习的两个阶段</h4><ul><li>第一类<ul><li>投影阶段（Projection Stage）（降维）<ul><li>用实值投影函数投影</li><li>给定点 x，每个投影维度 i 都和一个实值投影函数相关联 fi(x)（比如 fi(x)=Wi^T*x</li></ul></li><li>量化阶段（Quantization Stage）<ul><li>将实数转化为二进制（Turn real into binary）</li><li>度量学习（metric learning）和哈希学习（learning to hash）的本质区别</li></ul></li></ul></li><li>第二类<ul><li>二进制编码学习阶段</li><li>哈希函数学习阶段</li></ul></li></ul><h4 id="数据无关方法"><a href="#数据无关方法" class="headerlink" title="数据无关方法"></a>数据无关方法</h4><p>哈希函数的定义和训练数据集无关。</p><ul><li>Locality-sensitive hashing (LSH) 位置敏感哈希 (Gionis et al., 1999; Andoni and Indyk, 2008)<ul><li>和它的扩展 (Datar et al., 2004; Kulis and Grauman, 2009; Kulis et al., 2009)</li></ul></li><li>SIKH: 偏移不变核函数哈希（Shift invariant kernel hashing）(SIKH) (Raginsky and Lazebnik, 2009)</li><li>MinHash (Broder et al., 1998)<ul><li>和它的扩展 (Li and K ̈onig, 2011)</li></ul></li></ul><p>这些方法的哈希函数使用了<strong>随机投影</strong>或者是<strong>人工构造</strong>的，所以不属于哈希学习。</p><h4 id="数据相关方法"><a href="#数据相关方法" class="headerlink" title="数据相关方法"></a>数据相关方法</h4><p>哈希函数是从给定的训练数据集中学习得到。</p><p>和数据无关方法相比，数据相关方法（即哈希学习）可以在更短的二进制编码上获得相近甚至更好的精确度。</p><p>开创性论文：(Salakhutdinov and Hinton, 2007, 2009; Torralba et al., 2008; Weiss et al., 2008)</p><p>两个种类：</p><ul><li>单模态<ul><li>监督式方法：给定一些监督的（语义）信息，例如 pairwise 标签 s_ij, pointwise 标签 yi 或者 triplet 标签 (xi, xj, xk)</li><li>非监督式方法</li></ul></li><li>多模态<ul><li>监督式方法</li><li>非监督式方法</li></ul></li></ul><h4 id="单模态非监督方法"><a href="#单模态非监督方法" class="headerlink" title="单模态非监督方法"></a>单模态非监督方法</h4><p>没有指示训练点类别的标签。</p><ul><li>PCAH：主成分分析</li><li>SH：数据相似度图中计算出的<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%BE%B5%E5%87%BD%E6%95%B8" target="_blank" rel="external">本征函数（eigenfunctions）</a> (Weiss et al., 2008)</li><li>AGH：基于锚图（anchor graph）的哈希 (Liu et al., 2011)</li><li>ITQ：用<a href="https://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5" target="_blank" rel="external">正交旋转矩阵（orthogonal rotation matrix）</a>来改进由 PCA 学习到的初始影射矩阵 (Gong and Lazebnik, 2011)</li><li>IsoHash：使用<a href="https://zh.wikipedia.org/wiki/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5" target="_blank" rel="external">正交旋转矩阵（orthogonal rotation matrix）</a>来让不同方向的变化<a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7" target="_blank" rel="external">各向同性（isotropic）</a>（相等） (Kong and Li, 2012b)</li><li>DGH：直接学习离散二进制编码 (Liu et al., 2014)</li><li>SGH: 使用特征变换的可扩展的图哈希 (Jiang and Li, 2015)</li></ul><h4 id="单模态监督（半监督）方法"><a href="#单模态监督（半监督）方法" class="headerlink" title="单模态监督（半监督）方法"></a>单模态监督（半监督）方法</h4><p>具有类标签或者配对（pairwise）约束。</p><ul><li>SSH (SPLH)：半监督哈希，同时利用有标签和无标签数据 (Wang et al., 2010a,b)</li><li>MLH：基于隐式结构（latent structural）SVM 框架的最小化损失哈希 (Norouzi and Fleet, 2011)</li><li>LDAHash：基于线性区分分析（Linear discriminant analysis）的哈希 (Strecha et al., 2012)</li><li>KSH：基于核函数（Kernel）的监督式哈希 (Liu et al., 2012)</li><li>LFH：隐含因子模型的监督式哈希 (Zhang et al., 2014)</li><li>FastH：使用图割和决策树的监督式哈希 (Lin et al., 2014)</li><li>SDH：使用逐点（pointwise）标签的监督式离散哈希 (Shen et al., 2015)</li><li>COSDISH：使用 pairwise 监督的可扩展的离散哈希</li></ul><h4 id="基于排序的方法"><a href="#基于排序的方法" class="headerlink" title="基于排序的方法"></a>基于排序的方法</h4><p>监督信息是排序标签，例如三元组 (xi, xj, xk)。</p><ul><li>HDML：汉明距离度量学习（metric learning）(Norouzi et al., 2012)</li><li>OPH：顺序保留哈希，近似最近邻搜索 (Wang et al., 2013b)</li><li>RSH：用 listwise 监督式学习哈希编码 (Wang et al., 2013a)</li><li>RPH：排序保留哈希，快速相似度搜索 (Wang et al., 2015)</li></ul><h4 id="多媒体方法"><a href="#多媒体方法" class="headerlink" title="多媒体方法"></a>多媒体方法</h4><ul><li>多来源哈希（Multi-Source）</li><li>跨媒体哈希（Cross-Modal Hashing）</li></ul><h5 id="多来源方法"><a href="#多来源方法" class="headerlink" title="多来源方法"></a>多来源方法</h5><ul><li>目标是利用辅助视图（auxiliary views）来学习比单模态哈希更好的编码</li><li>假设查询提供了所有视图</li><li>MFH：多特征哈希 (Song et al., 2011)</li><li>CH：复合哈希 (Zhang et al., 2011)</li></ul><h5 id="跨媒体方法"><a href="#跨媒体方法" class="headerlink" title="跨媒体方法"></a>跨媒体方法</h5><p>给定包含图片或文字的查询，返回相关的图片或文字。</p><ul><li>CVH：跨视图哈希 (Kumar and Udupa, 2011)</li><li>MLBE：多模态隐含二进制嵌入 (Zhen and Yeung, 2012a)</li><li>CRH：同时正则化（Co-regularized）哈希 (Zhen and Yeung, 2012b)</li><li>IMH：媒体间哈希（Inter-media hashing）(Song et al., 2013)</li><li>RaHH：关系感知异构（Relation-aware heterogeneous）哈希 (Ou et al., 2013)</li><li>SCM：语义相关最大化（Semantic correlation maximization）(Zhang and Li, 2014)</li><li>CMFH：集体矩阵分解（Collective matrix factorization）哈希 (Ding et al., 2014)</li><li>QCH：量化相关哈希（Quantized correlation hashing）(Wu et al., 2015)</li><li>SePH：语义保留哈希 (Lin et al., 2015b)</li></ul><h4 id="深度哈希"><a href="#深度哈希" class="headerlink" title="深度哈希"></a>深度哈希</h4><p>使用深度学习的哈希。</p><ul><li>CNNH：通过图片表达学习的监督式哈希 (Xia et al., 2014)</li><li>NINH：用深度神经网络同时特征学习和哈希编码 (Lai et al., 2015)</li><li>DSRH：基于深度语义排序的哈希 (Zhao et al., 2015)</li><li>DRSCH：位可扩展（Bit-scalable）深度哈希 (Zhang et al., 2015)</li><li>DH：深度哈希，压缩二进制编码学习 (Liong et al., 2015)</li><li>二进制编码学习深度哈希 (Lin et al., 2015a)</li><li>DPSH：基于特征学习的使用 pairwise 标签的深度监督哈希 (Li et al., 2015)</li></ul><h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>量化阶段和投影阶段一样重要。</p><ul><li>DBQ：双位（Double-bit）量化 (Kong and Li, 2012a)</li><li>MQ：曼哈顿（Manhattan）量化 (Kong et al., 2012)</li><li>VBQ：可变位（Variable bit quantization）量化 (Moran et al., 2013)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;http://cs.nju.edu.cn/lwj/slides/L2H.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Learning to Hash for Big Data: A Tutorial&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h3&gt;&lt;h4 id=&quot;大数据中的最近邻搜索&quot;&gt;&lt;a href=&quot;#大数据中的最近邻搜索&quot; class=&quot;headerlink&quot; title=&quot;大数据中的最近邻搜索&quot;&gt;&lt;/a&gt;大数据中的最近邻搜索&lt;/h4&gt;&lt;p&gt;最近邻搜索（Nearest Neighbor Search）：给定查询点 q，返回数据库中距离 q 最近（最相似）的点集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facebook：7.5 亿用户&lt;/li&gt;
&lt;li&gt;Flickr：6 千万照片&lt;/li&gt;
&lt;li&gt;Wal-Mart: 每天 2.67 亿商品；4PB 数据仓库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%B2%E9%9A%86%E6%95%B8%E4%BD%8D%E5%B7%A1%E5%A4%A9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sloan Digital Sky Survery&lt;/a&gt;：新墨西哥州望远镜每天获取 200GB 图像数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa README 笔记</title>
    <link href="http://stormluke.me/reactive-cocoa-readme/"/>
    <id>http://stormluke.me/reactive-cocoa-readme/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md" target="_blank" rel="external">ReactiveCocoa/README.md</a></p><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">FRP</a></p><blockquote><p>事件流</p></blockquote><ul><li><code>Signal</code></li><li><code>SignalProducer</code></li></ul><a id="more"></a><p>用来统一这些模式：</p><ul><li>Delegate methods</li><li>Callback blocks</li><li><code>NSNotification</code>s</li><li>Control actions and responder chain events</li><li>Futures and promises</li><li>Key-value observing (KVO)</li></ul><h3 id="例子-在线搜索"><a href="#例子-在线搜索" class="headerlink" title="例子: 在线搜索"></a>例子: 在线搜索</h3><h4 id="观察文本的编辑"><a href="#观察文本的编辑" class="headerlink" title="观察文本的编辑"></a>观察文本的编辑</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchStrings = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div></pre></td></tr></table></figure><p>这样获取到一个发送 <code>String</code> 类型的 <code>SignalProducer</code>。为了支持 Objective-C 的 extension 方法，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2182" target="_blank" rel="external">目前 <code>as!</code> 是必须的</a>。</p><h4 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchResults = searchStrings</div><div class="line">    .flatMap(.<span class="type">Latest</span>) &#123; (query: <span class="type">String</span>) -&gt; <span class="type">SignalProducerNSData</span>, <span class="type">NSURLResponse</span>), <span class="type">NSError</span>&gt; <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> <span class="type">URLRequest</span> = <span class="keyword">self</span>.searchRequestWithEscapedQuery(query)</div><div class="line">        <span class="keyword">return</span> <span class="type">NSURLSession</span>.sharedSession().rac_dataWithRequest(<span class="type">URLRequest</span>)</div><div class="line">    &#125;</div><div class="line">    .<span class="built_in">map</span> &#123; (data, <span class="type">URLResponse</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> string = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)!</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.parseJSONResultsFromString(string)</div><div class="line">    &#125;</div><div class="line">    .observeOn(<span class="type">UIScheduler</span>())</div></pre></td></tr></table></figure><ul><li><code>observeOn(UIScheduler())</code> 在主线程上推送结果</li><li><code>flatMap(.Latest)</code> 保证只有最后一个网络请求是活动的</li></ul><h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>上面的代码并没有开始“运行”。直到下面这句话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">searchResults.startWithNext &#123; results <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"Search results: \(results)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>观察 <code>Next</code> 事件并处理。</p><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>在这个例子里，任何网络错误会生成 <code>Failed</code> 事件，并且会终止事件流。但上面的代码并没有处理。修复一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.flatMap(.<span class="type">Latest</span>) &#123; (query: <span class="type">String</span>) -&gt; <span class="type">SignalProducerNSData</span>, <span class="type">NSURLResponse</span>), <span class="type">NSError</span>&gt; <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> <span class="type">URLRequest</span> = <span class="keyword">self</span>.searchRequestWithEscapedQuery(query)</div><div class="line">    <span class="keyword">return</span> <span class="type">NSURLSession</span>.sharedSession()</div><div class="line">        .rac_dataWithRequest(<span class="type">URLRequest</span>)</div><div class="line">        .flatMapError &#123; error <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"Network error occurred: \(error)"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">SignalProducer</span>.empty</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>记录错误日志并且忽略错误。把错误换成了 <code>empty</code> 事件流。</p><p>如果出错则重试似乎更好，巧的是，确实有个 <code>retry</code> 算子。</p><h4 id="限流请求"><a href="#限流请求" class="headerlink" title="限流请求"></a>限流请求</h4><p>只想在用户停止输入后执行搜索以减少流量。ReactiveCocoa 有个 <code>throttle</code> 算子。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchStrings = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div></pre></td></tr></table></figure><h4 id="调试事件流"><a href="#调试事件流" class="headerlink" title="调试事件流"></a>调试事件流</h4><p>事件的栈轨迹会是一大坨，让调试很恶心。一种 navie 的调试方法是给流注入副作用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchString = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div><div class="line">    .on(event: &#123; <span class="built_in">print</span> ($<span class="number">0</span>) &#125;) <span class="comment">// the side effect</span></div></pre></td></tr></table></figure><p><code>SignalProducer</code> 和 <code>Signal</code> 提供 <code>logEvents</code> 算子来自动做这件事：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchString = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div><div class="line">    .logEvents()</div></pre></td></tr></table></figure><h3 id="Objective-C-和-Swift"><a href="#Objective-C-和-Swift" class="headerlink" title="Objective-C 和 Swift"></a>Objective-C 和 Swift</h3><p>3.0 版本后所有的重要特性开发都集中在 Swfit API。</p><p>Objective-C API 和 Swift API 完全是分离的，但有<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/ObjectiveCBridging.md" target="_blank" rel="external">桥接方法</a>。</p><h3 id="ReactiveCocoa-和-Rx-的关系？"><a href="#ReactiveCocoa-和-Rx-的关系？" class="headerlink" title="ReactiveCocoa 和 Rx 的关系？"></a>ReactiveCocoa 和 Rx 的关系？</h3><p>ReactiveCocoa <em>故意</em>不是 Rx 的直接移植版。</p><p>RAC 相比于 Rx 主要用于：</p><ul><li>建立更简单的 API</li><li>Address common sources of confusion</li><li>更符合 Cocoa 习惯</li></ul><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>在 Rx 的绝大多数版本里，流被叫做 <code>Observable</code>，是 .NET <code>Enumerable</code> 类型的并行版。另外，Rx.NET 的许多操作的名字来源于 LINQ，主要用于影射关系型数据库，比如 <code>Select</code>、<code>Where</code>。</p><p>RAC 则主要遵循 Swift 命名，比如 <code>map</code>、<code>filter</code>。其他命名的差异一般是来自 Haskell 或 Elm 中明显更好的名字。</p><h4 id="Singles-和-Signal-Producers-“hot”-和-“cold”-observables"><a href="#Singles-和-Signal-Producers-“hot”-和-“cold”-observables" class="headerlink" title="Singles 和 Signal Producers (“hot” 和 “cold” observables)"></a>Singles 和 Signal Producers (“hot” 和 “cold” observables)</h4><p>Rx 里难理解的部分中的一个就是 <a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html" target="_blank" rel="external">“hot”, “cold”, and “warm” observables</a>。</p><p>简单来说，只给出如下的函数声明</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">IObservable</span>&lt;string&gt; <span class="type">Search</span>(string query)</div></pre></td></tr></table></figure><p><strong>不可能</strong>看出订阅这个 <code>IObservable</code> 会不会引入副作用，如果它<em>确实</em>有副作用，也不能看出是否<em>每个订阅</em>会有副作用还是仅仅第一个订阅会有副作用。</p><p>这个例子展示了让 Rx（和 3.0 版前的 ReactiveCocoa）代码难一眼看懂的<strong>真实普遍的问题</strong>。</p><p>ReacitveCocoa 3.0 用 <code>Signal</code> 和 <code>SignalProducer</code> 来区分副作用。</p><p>换句话说，ReactiveCocoa 的改变<a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="external">简约不简单</a>。</p><h4 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h4><p>RAC 允许使用 <code>NoError</code> 来<em>静态保证</em>一个事件流不允许发出异常。<strong>这消除了许多由意外异常事件引发的 bug</strong>。</p><p>在 Rx 里没有错误类型。</p><h4 id="UI-编程"><a href="#UI-编程" class="headerlink" title="UI 编程"></a>UI 编程</h4><p>Rx 一般不知道它如何被使用，尽管用 Rx 来 UI 编程很常见。</p><p>RAC 受到很多来自 ReactiveUI 的启发，比如 <code>Action</code>。</p><p>和 ReactiveUI 不能直接改造 Rx 不同，RAC 为 UI 编程改进了很多次，即使这样会和 Rx 变得越来越不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReactiveCocoa/README.md&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_reactive_programming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FRP&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事件流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Signal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SignalProducer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>书单@2016</title>
    <link href="http://stormluke.me/book-list-2016/"/>
    <id>http://stormluke.me/book-list-2016/</id>
    <published>2016-01-22T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.032Z</updated>
    
    <content type="html"><![CDATA[<p>书堆的有点多&amp;基本上是专业书。。</p><a id="more"></a><ul><li><em>数学女孩</em></li><li><em>数学女孩 2</em></li><li><a href="https://book.douban.com/subject/26386810/" target="_blank" rel="external">Scala与Clojure函数式编程模式</a></li><li><em>Javascript函数式编程</em></li><li><em>无器械健身</em></li><li><em>大学之路</em></li><li><a href="https://book.douban.com/subject/26583236/" target="_blank" rel="external">七周七Web开发框架</a></li><li><em>硬派健身</em></li><li><em>写给大忙人看的Java SE 8</em></li><li><em>编写可测试的Javascript代码</em></li><li><em>图解机器学习</em></li><li><em>设计思考</em></li><li><em>图解TCP/IP</em></li><li><em>数据科学实战</em></li><li><em>Clojure编程</em></li><li><em>算法的乐趣</em></li><li><em>挑战程序设计竞赛</em></li><li><em>Vim实用技巧</em></li><li><em>Haskell函数式编程基础</em></li><li><em>Pattern Recongnition and Machine Learning</em></li><li><em>The Elements of Statistical Learning</em></li><li><em>算法导论</em></li><li><em>编译原理</em></li><li><em>Machine Learning</em></li><li><em>iOS Auto Layout开发秘籍</em></li><li><em>C++程序设计语言</em></li><li><em>大数据日知录</em></li><li><em>互联网大规模数据挖掘与分布式处理</em></li><li><em>Java虚拟机并发编程</em></li><li><em>超级漫画素描技法</em></li><li><em>编译器设计</em></li><li><em>CPU自制入门</em></li><li><em>数学桥</em></li><li><em>iOS编程实战</em></li><li><em>具体数学</em></li><li><em>OpenGL超级宝典</em></li><li><em>深入理解计算机系统</em></li><li><em>五天学会绘画</em></li><li><em>统计思维</em></li><li><em>概率导论</em></li><li><em>线性代数应该这样学</em></li><li><a href="https://book.douban.com/subject/26337939/" target="_blank" rel="external">七周七并发模型</a></li><li><em>禅与摩托车维修艺术</em></li><li><em>文明之光</em></li><li><em>Ruby元编程</em></li><li><em>设计中的设计</em></li><li><em>只是为了好玩</em></li><li><em>用AngularJS开发下一代Web应用</em></li><li><em>计算机程序的构造和解释</em></li><li><em>编程本色</em></li><li><em>HTTP权威指南</em></li><li><em>算法心得</em></li><li><em>30天学会绘画</em></li><li><em>GEB</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书堆的有点多&amp;amp;基本上是专业书。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蹦床（trampoline）原理</title>
    <link href="http://stormluke.me/trampoline-in-javascript/"/>
    <id>http://stormluke.me/trampoline-in-javascript/</id>
    <published>2015-12-21T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.039Z</updated>
    
    <content type="html"><![CDATA[<p>摘录自 <em>Functional JavaScript</em>。</p><p>来看一个相互递归的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">evenSteven</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> oddJohn(<span class="built_in">Math</span>.abs(n) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">oddJohn</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> evenSteven(<span class="built_in">Math</span>.abs(n) - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个函数相互回弹调用彼此，递减某个绝对值，直到一方到达零为止。这是一个相当优雅的解决方式。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">evenSteven(<span class="number">4</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">oddJohn(<span class="number">11</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>尽管技术上可以实现尾递归的优化，但目前 JavaScript 引擎并不支持。因此在调用以上函数时可能会遇到这个错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">evenSteven(<span class="number">100000</span>);</div><div class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded (or some variant)</span></div></pre></td></tr></table></figure><p>这种错误称为“blowing the stack”，是因为 <code>evenSteven</code> 和 <code>oddJohn</code> 互相调用过多造成了栈溢出。</p><p>可以是用蹦床（trampoline）原理的控制结构来消除这类错误。它的基本原理是，使用蹦床展平调用，而不是深度嵌套的递归调用。</p><p>首先看看如何来手动修复这两个函数使得递归不会溢出。一个方法是返回一个函数，它包装调用，而不是直接调用。可以使用 <code>partial1</code> 来实现这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial1</span>(<span class="params">fun, arg1</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> fun.bind(<span class="literal">undefined</span>, arg1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">这时对应的函数为：</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">` js</span></div><div class="line"><span class="string">function evenOline(n) &#123;</span></div><div class="line"><span class="string">  if (n === 0)</span></div><div class="line"><span class="string">    return true;</span></div><div class="line"><span class="string">  else</span></div><div class="line"><span class="string">    return partial1(oddOline, Math.abs(n) - 1);</span></div><div class="line"><span class="string">&#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">function oddOline(n) &#123;</span></div><div class="line"><span class="string">  if (n === 0)</span></div><div class="line"><span class="string">    return false;</span></div><div class="line"><span class="string">  else</span></div><div class="line"><span class="string">    return partial1(evenOline, Math.abs(n) - 1);</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure><p>这两个函数返回一个包装函数而不是直接进行 <code>evenOline</code> 和 <code>oddOline</code> 的互相调用。调用终止情况时都能正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">evenOline(<span class="number">0</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">oddOline(<span class="number">0</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>现在可以手动调用递归来展平：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">oddOline(<span class="number">3</span>);</div><div class="line"><span class="comment">//=&gt; function() &#123; return evenOline(Math.abs(n) - 1) &#125;</span></div><div class="line">oddOline(<span class="number">3</span>)();</div><div class="line"><span class="comment">//=&gt; function() &#123; return oddOline(Math.abs(n) - 1) &#125;</span></div><div class="line">oddOline(<span class="number">3</span>)()();</div><div class="line"><span class="comment">//=&gt; function() &#123; return evenOline(Math.abs(n) - 1) &#125;</span></div><div class="line">oddOline(<span class="number">3</span>)()()();</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">oddOline(<span class="number">200000001</span>)()()()(); <span class="comment">//... a bunch more ()s</span></div></pre></td></tr></table></figure><p>看起来能用了，但可以提供另外一个函数 <code>trampoline</code>，从程序执行来进行扁平化处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fun <span class="regexp">/*, args */</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = fun.apply(fun, _.rest(<span class="built_in">arguments</span>));</div><div class="line">  <span class="keyword">while</span> (_.isFunction(result)) &#123;</div><div class="line">    result = result();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>trampoline</code> 所做的是不断调用函数的返回值，直到它不再是一个函数。具体是这样工作的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">trampoline(oddOline, <span class="number">3</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">trampoline(evenOline, <span class="number">200000</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">trampoline(oddOline, <span class="number">300000</span>);</div><div class="line"><span class="comment">//=&gt; false</span></div><div class="line">trampoline(evenOline, <span class="number">200000000</span>);</div><div class="line"><span class="comment">// wait a few seconds</span></div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>由于调用链的间接性，使用蹦床增加了相互递归函数的一些开销。然而，慢总比溢出好。如果不想强迫用户使用 <code>trampoline</code>，只是为了避免堆栈溢出，其实也可以隐藏其外观：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEvenSafe</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> trampoline(partial1(oddOline, <span class="built_in">Math</span>.abs(n) - <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOddSafe</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> trampoline(partial1(evenOline, <span class="built_in">Math</span>.abs(n) - <span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>试试能否正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">isOddSafe(<span class="number">2000001</span>);</div><div class="line"><span class="comment">//=&gt; true</span></div><div class="line">idEvenSafe(<span class="number">2000001</span>);</div><div class="line"><span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘录自 &lt;em&gt;Functional JavaScript&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;来看一个相互递归的例子&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;evenSteven&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oddJohn(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.abs(n) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;oddJohn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; evenSteven(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.abs(n) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两个函数相互回弹调用彼此，递减某个绝对值，直到一方到达零为止。这是一个相当优雅的解决方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015.10.16</title>
    <link href="http://stormluke.me/2015-10-16/"/>
    <id>http://stormluke.me/2015-10-16/</id>
    <published>2015-10-15T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.030Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见。</p><p>读到老罗的<a href="http://weibo.com/p/1001603808740469043389" target="_blank" rel="external">骂街文章</a>，正文并没有什么意思，但结尾很棒：</p><a id="more"></a><blockquote><p>最后，我想用<a href="http://www.asa3.org/ASA/education/views/teresa.htm" target="_blank" rel="external">特蕾莎修女写在加尔各答孤儿院上的几句诗</a>和 OpenSSL 共勉：</p><p>“如果你友善，人们可能会说你自私自利，动机不良<br>无论如何，你还是要友善</p><p>如果你诚实坦率，人们可能会欺骗你<br>无论如何，你还是要诚实坦率</p><p>你多年建造的东西，可能被人一夜之间摧毁<br>无论如何，你还是要去建造</p><p>你今天做的善事，明天就会被人们忘记<br>无论如何，你还是要做善事</p><p>即使你把你最好的都给了这个世界，可能还是远远不够<br>无论如何，你还是要把你最好的给这个世界”</p></blockquote><p>愿你我的心一直柔软。纪念日快乐 &lt;3</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不见。&lt;/p&gt;
&lt;p&gt;读到老罗的&lt;a href=&quot;http://weibo.com/p/1001603808740469043389&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;骂街文章&lt;/a&gt;，正文并没有什么意思，但结尾很棒：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应式编程笔记 08</title>
    <link href="http://stormluke.me/reactive-programming-note-08/"/>
    <id>http://stormluke.me/reactive-programming-note-08/</id>
    <published>2015-05-07T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 <code>Observable</code></h2><p>所有的 <code>Observable</code> 工厂方法都是由下面这个派生而来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](s: <span class="type">Observer</span>[<span class="type">T</span>] 􏰀 <span class="type">Subscription</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epy87ziblyj20vw0a9jtb.jpg" alt="Observable.create"></p><p>首先是两个最简单的：<code>never</code> 和 <code>error</code></p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epy8canoq9j20x507zt8z.jpg" alt="never"></p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epy8ddjvggj20xd07q74o.jpg" alt="error"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">never</span></span>(): <span class="type">Observable</span>[<span class="type">Nothing</span>] = <span class="type">Observable</span>[<span class="type">Nothing</span>](observer =&gt;􏰀 &#123;</div><div class="line">  <span class="type">Subscription</span> &#123;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](error: <span class="type">Throwable</span>): <span class="type">Observable</span>[<span class="type">T</span>] =</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer 􏰀=&gt; &#123;</div><div class="line">    observer.onError(error)</div><div class="line">    <span class="type">Subscription</span> &#123;&#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>然后是 <code>startWith</code>，它能在流之前添加元素：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epy8gethuwj20t70dwwgo.jpg" alt="startWith"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">startWith</span></span>(ss: <span class="type">T</span>*): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer 􏰀=&gt; &#123;</div><div class="line">    <span class="keyword">for</span>(s &lt;- ss) observer.onNext(s)</div><div class="line">    subscribe(observer)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>filter</code>：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epy8j13td9j20q10d275n.jpg" alt="filter"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> 􏰀=&gt; <span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer 􏰀=&gt; &#123;</div><div class="line">    subscribe (</div><div class="line">      (t: <span class="type">T</span>) 􏰀=&gt; &#123; <span class="keyword">if</span>(p(t)) observer.onNext(t) &#125;,</div><div class="line">      (e: <span class="type">Throwable</span>) 􏰀=&gt; &#123; observer.onError(e) &#125;,</div><div class="line">      () 􏰀=&gt; &#123; observer.onCompleted() &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>map</code>：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epy8lchhfcj20qd0d0jt9.jpg" alt="map"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> 􏰀=&gt; <span class="type">S</span>): <span class="type">Observable</span>[<span class="type">S</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">S</span>](observer 􏰀=&gt; &#123;</div><div class="line">    subscribe (</div><div class="line">      (t: <span class="type">T</span>) =&gt; &#123; observer.onNext(f(t)) &#125;,</div><div class="line">      (e: <span class="type">Throwable</span>) =&gt; &#123; observer.onError(e) &#125;,</div><div class="line">      () =&gt; &#123; observer.onCompleted() &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和 <code>Iterable</code> 的 <code>map</code> 对比下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>): <span class="type">Iterable</span>[<span class="type">S</span>] = &#123;</div><div class="line">  <span class="keyword">new</span> <span class="type">Iterable</span>[<span class="type">S</span>] &#123;</div><div class="line">    <span class="keyword">val</span> it = <span class="keyword">this</span>.iterator()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>: <span class="type">Iterator</span>[<span class="type">S</span>] = <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">S</span>] &#123;</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = &#123; it.hasNext &#125;</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">S</span> = &#123; f(it.next()) &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a><code>Subject</code></h2><p>现在想将一个 <code>Future[T]</code> 转化成 <code>Observable[T]</code>：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epy8qf2k1xj20su0ep75a.jpg" alt="future-to-observable"></p><p>为了要达成这个目的，需要引入一个新类型：<code>Subject</code>。回顾下 <code>Promise</code> 是如何做的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">S</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">S</span>]()</div><div class="line">  onComplete &#123;</div><div class="line">    <span class="keyword">case</span> result =&gt; &#123;... p.complete(<span class="type">E</span>) ...&#125;</div><div class="line">  &#125;(executor)</div><div class="line">  p.future</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当在 <code>Promise</code> 上调用 <code>complete</code> 时，<code>Promise</code> 会调用内部的 <code>Future</code> 上的 <code>onComplete</code>：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epy8y1okjwj20yk0c2abn.jpg" alt="promise"></p><p><code>Subject[T]</code> 和 <code>Promise[T]</code> 所担任的角色类似，它同时包含 <code>Observer[T]</code> 和 <code>Observable[T]</code>，既可以在 <code>Observer[T]</code> 上调用 <code>onNext</code> 等方法，也能 <code>subscribe</code> 一个 <code>Observable[T]</code>。可以说 <code>Subject</code> 让 Cold Observable 变成了 Hot Observable：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epyagmpawdj20yi0gn41q.jpg" alt="subject"></p><p>来看几个不同类型的 <code>Subject</code> 的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = <span class="type">PublishSubject</span>[<span class="type">Int</span>]()</div><div class="line"><span class="keyword">val</span> a = channel.subscribe(x =&gt; println(<span class="string">"a: "</span>+x))</div><div class="line"><span class="keyword">val</span> b = channel.subscribe(x =&gt; println(<span class="string">"b: "</span>+x)) channel.onNext(<span class="number">42</span>)</div><div class="line">a.unsubscribe()</div><div class="line">channel.onNext(<span class="number">4711</span>)</div><div class="line">channel.onCompleted()</div><div class="line"><span class="keyword">val</span> c = channel.subscribe(x􏰀println(<span class="string">"c: "</span>+x))</div><div class="line">channel.onNext(<span class="number">13</span>)</div><div class="line"><span class="comment">// a: 42; b:42, 4711, !; c: !</span></div></pre></td></tr></table></figure><p><code>PublishSubject</code> 是基础行为的 <code>Subject</code>，当订阅一个已经停止的 <code>PublishSubject</code> 时，会直接收到 <code>onCompleted()</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = <span class="type">ReplaySubject</span>[<span class="type">Int</span>]()</div><div class="line"><span class="keyword">val</span> a = channel.subscribe(x =&gt; println(<span class="string">"a: "</span>+x))</div><div class="line"><span class="keyword">val</span> b = channel.subscribe(x =&gt; println(<span class="string">"b: "</span>+x))</div><div class="line">channel.onNext(<span class="number">42</span>)</div><div class="line">a.unsubscribe()</div><div class="line">channel.onNext(<span class="number">4711</span>)</div><div class="line">channel.onCompleted()</div><div class="line"><span class="keyword">val</span> c = channel.subscribe(x􏰀println(<span class="string">"c: "</span>+x))</div><div class="line">channel.onNext(<span class="number">13</span>)</div><div class="line"><span class="comment">// a: 42; b: 42, 4711, !; c: 42, 4711, !</span></div></pre></td></tr></table></figure><p><code>ReplaySubject</code> 会缓存所有元素，当订阅一个已经停止的 <code>ReplaySubject</code> 时，会收到所有的元素。</p><p>还用两种 <code>Subject</code>，一个是 <code>BehaviorSubject</code>，它会缓存最后一个元素，当订阅一个已经停止的 <code>BehaviorSubject</code> 时，会收到最后一个元素；另一个是 <code>AsyncSubject</code>，它也会缓存最后一个元素，但不论何时订阅，都只能收到最后一个元素。下面是它们的对比图：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epyavfalrgj20yq0gmdiy.jpg" alt="subjects"></p><p>练习：</p><p>下面这段代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> channel = <span class="type">AsyncSubject</span>[<span class="type">Int</span>]()</div><div class="line"><span class="keyword">val</span> a = channel.subscribe(x =&gt; println(<span class="string">"a: "</span>+x))</div><div class="line"><span class="keyword">val</span> b = channel.subscribe(x =&gt; println(<span class="string">"b: "</span>+x))</div><div class="line">channel.onNext(<span class="number">42</span>)</div><div class="line">a.unsubscribe()</div><div class="line">channel.onNext(<span class="number">4711</span>)</div><div class="line">channel.onCompleted()</div><div class="line"><span class="keyword">val</span> c = channel.subscribe(x􏰀println(<span class="string">"c: "</span>+x))</div><div class="line">channel.onNext(<span class="number">13</span>)</div></pre></td></tr></table></figure><p>哪个频道输出是正确的？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a: <span class="number">4711</span>, !</div><div class="line">b: <span class="number">42</span>, <span class="number">4711</span>, !</div><div class="line">b: <span class="number">4711</span>, !</div></pre></td></tr></table></figure><p>答案是 b 频道。</p><p>于是就可以这样来将 <code>Future[T]</code> 转化成 <code>Observable[T]</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](f: <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> subject = <span class="type">AsyncSubject</span>[<span class="type">T</span>]()</div><div class="line">    f onComplete &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Failure</span>(e) 􏰀 &#123; subject.onError(e) &#125;</div><div class="line">      <span class="keyword">case</span> <span class="type">Success</span>(c) 􏰀 &#123; subject.onNext(c); subject.onCompleted() &#125;</div><div class="line">    &#125;</div><div class="line">    subject</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a><code>Notification</code></h2><p>想显式处理流中的错误怎么办？可以用 <code>Notification</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Try</span>[+<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Success</span>[<span class="type">T</span>](<span class="params">elem: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Failure</span>(<span class="params">t: <span class="type">Throwable</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">abstract</span> <span class="title">class</span> <span class="title">Notification</span>[+<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">OnNext</span>[<span class="type">T</span>](<span class="params">elem: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">OnError</span>(<span class="params">t: <span class="type">Throwable</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">OnCompleted</span> <span class="keyword">extends</span> <span class="title">Notification</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">def</span> <span class="title">materialize</span></span>: <span class="type">Observable</span>[<span class="type">Notification</span>[<span class="type">T</span>]] = &#123; ... &#125;</div></pre></td></tr></table></figure><p>弹子图如下：</p><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epybkdyh2qj20r20dr0ub.jpg" alt="Notification"></p><h2 id="阻塞-Observable"><a href="#阻塞-Observable" class="headerlink" title="阻塞 Observable"></a>阻塞 <code>Observable</code></h2><p>可以通过 <code>Observable.toBlockingObservable()</code> 或者 <code>BlockingObservable.from()</code> 方法将非阻塞的 <code>Observable</code> 变为阻塞的。但应注意 Rx 中所有的操作都是非阻塞的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> second).take(<span class="number">5</span>)</div><div class="line"><span class="keyword">val</span> ys: <span class="type">List</span>[<span class="type">Long</span>] = xs.toBlockingObservable.toList</div><div class="line">println(ys)</div><div class="line">println(<span class="string">"bye"</span>)</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Long</span>] = xs.sum</div><div class="line"><span class="keyword">val</span> s: <span class="type">Long</span> = zs.toBlockingObservable.single</div></pre></td></tr></table></figure><h2 id="归约-Observable"><a href="#归约-Observable" class="headerlink" title="归约 Observable"></a>归约 <code>Observable</code></h2><p>可以使用 <code>reduce</code> 方法来创建标量 <code>Observable</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(f: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epyhpkrhd1j20rb0ec760.jpg" alt="reduce"></p><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a><code>Scheduler</code></h2><p>如何设计一个将 <code>Iterable</code> 转变成 <code>Observable</code> 的函数？这个 <code>from</code> 函数要支持无限流，并且能取消订阅：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1epzsukxgj6j20ty0exq51.jpg" alt="from"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>]) : <span class="type">Observable</span>[<span class="type">T</span>] = &#123; ... &#125;</div><div class="line"><span class="keyword">val</span> infinite: <span class="type">Iterable</span>[<span class="type">Int</span>] = nats()</div><div class="line"><span class="keyword">val</span> subscription = from(infinite). subscribe(x =&gt; println(x))</div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure><p>注意 <code>Iterable</code> 是懒求值的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nats</span></span>(): <span class="type">Iterable</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Iterable</span>[<span class="type">Int</span>] &#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">-1</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>: <span class="type">Iterator</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">Int</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = &#123; <span class="literal">true</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">Int</span> = &#123; i +=<span class="number">1</span>; i &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于流可能是无限的，直接用 <code>foreach</code> 不行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>]) : <span class="type">Observable</span>[<span class="type">T</span>] = &#123; <span class="type">Observable</span>(observer =&gt; &#123;</div><div class="line">seq.foreach(s =&gt; observer.onNext(s)) observer.onCompleted()</div><div class="line">  <span class="comment">// we never get here</span></div><div class="line">  <span class="type">Subscription</span>&#123;&#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> infinite: <span class="type">Iterable</span>[<span class="type">Integer</span>] = nats()</div><div class="line"><span class="keyword">val</span> subscription = from(infinite).subscribe(x =&gt; println(x))</div><div class="line"><span class="comment">// hence we never get here</span></div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure><p>必须在其他的线程中执行生成器，这时就需要 <code>Scheduler</code> 了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: =&gt;<span class="type">Unit</span>): <span class="type">Subscription</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> scheduler = <span class="type">Scheduler</span>.<span class="type">NewThreadScheduler</span></div><div class="line"><span class="keyword">val</span> subscription = scheduler.schedule &#123;</div><div class="line">  println(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <code>Scheduler</code> 中使用 <code>foreach</code> 虽然不会阻塞当前线程，但不能取消订阅：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer =&gt; &#123;</div><div class="line">    scheduler.schedule &#123;</div><div class="line">      seq.foreach(s ⇒ observer.onNext(s))</div><div class="line">      observer.onCompleted()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要演化出两个更精细的控制方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: =&gt;<span class="type">Unit</span>): <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: <span class="type">Scheduler</span>=&gt;<span class="type">Subscription</span>): <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: (=&gt;<span class="type">Unit</span>)=&gt;<span class="type">Unit</span>): <span class="type">Subscription</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这次就没问题了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>[<span class="type">T</span>](seq: <span class="type">Iterable</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="type">Observable</span>[<span class="type">T</span>](observer =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> it = seq.iterator()</div><div class="line">    scheduler.schedule(self =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (it.hasnext) &#123; observer.onNext(it.next()); self() &#125;</div><div class="line">      <span class="keyword">else</span> &#123; observer.onCompleted() &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (it.hasnext) &#123; observer.onNext(it.next()); self() &#125;</div></pre></td></tr></table></figure><p>的调用过程大概是这样：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1epzt8u4pkdj20vk0e2dim.jpg" alt="self-call"></p><p>那么 <code>schedule</code> 到底是如何定义的呢？如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: (=&gt;<span class="type">Unit</span>)=&gt;<span class="type">Unit</span>): <span class="type">Subscription</span> = &#123;</div><div class="line">  <span class="keyword">val</span> subscription = <span class="keyword">new</span> <span class="type">MultipleAssignmentSubscription</span>();</div><div class="line">  schedule(scheduler =&gt; &#123;</div><div class="line">    loop(scheduler, work, subscription);</div><div class="line">    subscription;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(s: <span class="type">Scheduler</span>, w: (=&gt;<span class="type">Unit</span>)=&gt;<span class="type">Unit</span>), m: <span class="type">MultipleAssignmentSubscription</span>): <span class="type">Unit</span> = &#123;</div><div class="line">   m.<span class="type">Subscription</span> = s.schedule &#123; w &#123; loop(s, w, m) &#125; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>把 <code>loop</code> 整理到 <code>schedule</code> 内部，就变成了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(work: (⇒<span class="type">Unit</span>)⇒<span class="type">Unit</span>): <span class="type">Subscription</span> = &#123;</div><div class="line">  <span class="keyword">val</span> subscription = <span class="keyword">new</span> <span class="type">MultipleAssignmentSubscription</span>()</div><div class="line">  schedule(scheduler =&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">      subscription.<span class="type">Subscription</span> = scheduler.schedule &#123;</div><div class="line">        work &#123; loop() &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    loop()</div><div class="line">    subscription</div><div class="line">   &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在想将 <code>Scheduler</code> 转化成 <code>Observable[Unit]</code>，实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>()(<span class="keyword">implicit</span> scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">Unit</span>] = &#123;</div><div class="line">    <span class="type">Observable</span>(observer =&gt; &#123;</div><div class="line">      scheduler.schedule(self =&gt; &#123;</div><div class="line">          observer.<span class="type">OnNext</span>(())</div><div class="line">          self()</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> scheduler = <span class="type">Scheduler</span>.<span class="type">NewThreadScheduler</span></div><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Unit</span>] = <span class="type">Observable</span>()</div></pre></td></tr></table></figure><h2 id="Rx-约定"><a href="#Rx-约定" class="headerlink" title="Rx 约定"></a>Rx 约定</h2><p><code>subscribe</code> 的实现可以概括成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">Observer</span>[<span class="type">T</span>]=&gt;<span class="type">Subscription</span>) = <span class="keyword">new</span> <span class="type">Observable</span>[<span class="type">T</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span></span>(o: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Subscription</span> = &#123; <span class="type">Magic</span>(s(o)) &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是说</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="type">Observable</span>(o=&gt;<span class="type">F</span>(o)).subscribe(observer)</div></pre></td></tr></table></figure><p>在概念上和</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="type">Magic</span>(<span class="type">F</span>(observer))</div></pre></td></tr></table></figure><p>相同。<code>Magic</code> 所做的工作是当在 <code>F</code> 中调用 <code>observer.onCompleted</code> 或 <code>observer.onError</code> 时，它会取消 <code>s</code> 的订阅。</p><p>就是说，流只能以多个 <code>onNext</code> 后接零个或多个 <code>onCompleted</code> 或 <code>onError</code> 构成。这是 Rx 的约定，表示为 <code>(onNext)*(onCompleted+onError)?</code>。</p><p>注意，绝不要自己实现 <code>Observable[T]</code> 或 <code>Observer[T]</code>，而应该始终使用 <code>Observable(...)</code> 和 <code>Observer(...)</code> 工厂方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建-Observable&quot;&gt;&lt;a href=&quot;#创建-Observable&quot; class=&quot;headerlink&quot; title=&quot;创建 Observable&quot;&gt;&lt;/a&gt;创建 &lt;code&gt;Observable&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;所有的 &lt;code&gt;Observable&lt;/code&gt; 工厂方法都是由下面这个派生而来：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Observable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;](s: &lt;span class=&quot;type&quot;&gt;Observer&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;] 􏰀 &lt;span class=&quot;type&quot;&gt;Subscription&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Observable&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应式编程笔记 07</title>
    <link href="http://stormluke.me/reactive-programming-note-07/"/>
    <id>http://stormluke.me/reactive-programming-note-07/</id>
    <published>2015-05-06T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Future-T-和-Try-T-是对偶（dual）"><a href="#Future-T-和-Try-T-是对偶（dual）" class="headerlink" title="Future[T] 和 Try[T] 是对偶（dual）"></a><code>Future[T]</code> 和 <code>Try[T]</code> 是<a href="http://en.wikipedia.org/wiki/Dual_%28category_theory%29" target="_blank" rel="external">对偶（dual）</a></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">OnComplete</span></span>[<span class="type">U</span>](func: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">U</span>)(<span class="keyword">implicit</span> ex: <span class="type">ExecutionContext</span>): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>对 <code>OnComplete</code> 方法的类型进行化简（<code>U</code> 化简为 <code>Unit</code>），得到</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p>翻转这个类型，得到</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Unit</span> =&gt; (<span class="type">Unit</span> =&gt; <span class="type">Try</span>[<span class="type">T</span>])</div></pre></td></tr></table></figure><p>继续简化，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; Try[T]) ≈ Try[T]</div></pre></td></tr></table></figure><p>可以看出，对方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span></span>(): <span class="type">Future</span>[<span class="type">T</span>] = &#123; ... &#125;</div></pre></td></tr></table></figure><p>传递回调（<code>Try[T] =&gt; Unit</code>）得到 <code>Try[T]</code>，而方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span></span>(): <span class="type">Try</span>[<span class="type">T</span>] = &#123; ... &#125;</div></pre></td></tr></table></figure><p>一直阻塞直到返回 <code>Try[T]</code>。</p><h3 id="同步数据流：Iterable-T"><a href="#同步数据流：Iterable-T" class="headerlink" title="同步数据流：Iterable[T]"></a>同步数据流：<code>Iterable[T]</code></h3><p>这是 Scala 所有集合类型的基 trait，它定义了一个迭代器方法来一个一个地遍历集合中的元素。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterable</span>[<span class="type">T</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(): <span class="type">Iterator</span>[<span class="type">T</span>] &#125;</div></pre></td></tr></table></figure><p>迭代器是用来遍历序列元素的数据结构。它有个 <code>hasNext</code> 方法来检测下一个元素是否存在，还有个 <code>next</code> 方法来返回下一个元素。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span>[<span class="type">T</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span>; <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span> &#125;</div></pre></td></tr></table></figure><p>画成图是这样：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx0gia2dkj20vu0ecdha.jpg" alt="Iterable"></p><p>操作 <code>Iterable[T]</code> 的高阶函数有这些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">Iterable</span>[<span class="type">B</span>]): <span class="type">Iterable</span>[<span class="type">B</span>] <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">Iterable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeWhile</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>(): <span class="type">List</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">B</span>](that: <span class="type">Iterable</span> [<span class="type">B</span>]): <span class="type">Iterable</span>[(<span class="type">A</span>, <span class="type">B</span>)]</div></pre></td></tr></table></figure><p>这是一个单子。</p><p>常常用弹子图（Marble Diagram）来描述这种类型。</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx0p5e16yj20t10ehach.jpg" alt="Marble Diagram"></p><p>如果将不同命令的执行时间放大到人类级别，将会是这样：</p><p><a href="http://norvig.com/21-days.html#answers" target="_blank" rel="external"><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx0y76ydrj20s90flq6y.jpg" alt="Timings on human scale"></a></p><p>这时用 <code>Iterator</code> 从磁盘中读取文件会让程序阻塞很长时间：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadLinesFromDisk</span></span>(path: <span class="type">String</span>): <span class="type">Iterator</span>[<span class="type">String</span>] = &#123;</div><div class="line">  <span class="type">Source</span>.fromFile(path).getLines()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> lines = <span class="type">ReadLinesFromDisk</span>(<span class="string">"\c:\tmp.txt"</span>)</div><div class="line"><span class="keyword">for</span> (line </div><div class="line">  ... <span class="type">DoWork</span>(line) ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 weeks per line.</span></div></pre></td></tr></table></figure><p>现在用之前的对偶化技巧将拉（pull）模型转化为推（push）模型。</p><p>第零步，化简。将之前的签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(): <span class="type">Iterator</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抽象出类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; <span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]])</div></pre></td></tr></table></figure><ul><li><code>() =&gt; ( ... )</code> 由 <code>iterator()</code> 而来，</li><li><code>() =&gt; Try[Option[T]]</code> 由 <code>next()</code> 而来，</li><li><code>Option</code> 表示了 <code>hasNext</code>，</li><li><code>Try</code> 显式化了错误。</li></ul><p>第一步，翻转。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; <span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]])</div></pre></td></tr></table></figure><p>翻转为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p>第二步，化简。将组合在一起的类型拆分为三个：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">( <span class="type">T</span> =&gt; <span class="type">Unit</span>,</div><div class="line">  <span class="type">Throwable</span> =&gt; <span class="type">Unit</span>,</div><div class="line">  () =&gt; <span class="type">Unit</span></div><div class="line">) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p>第三步，复杂化。得出对应的签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Subscribe</span></span>(observer: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Subscription</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observer</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onNext</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onError</span></span>(error: <span class="type">Throwable</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onCompleted</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过对比可发现 <code>Iterable[T]</code> 和 <code>Observable[T]</code> 是对偶。</p><h3 id="对比-Future-和-Observable"><a href="#对比-Future-和-Observable" class="headerlink" title="对比 Future 和 Observable"></a>对比 <code>Future</code> 和 <code>Observable</code></h3><p>首先看签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">Observable</span>[<span class="type">T</span>] = (<span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div><div class="line"><span class="type">Future</span>[<span class="type">T</span>]     = (<span class="type">Try</span>[      [<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure><p><code>Observable[T]</code> 多了 <code>Option</code>，这使其可以处理多次数据。</p><p>并发方面有什么不同呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt; <span class="type">T</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">observeOn</span></span>(scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Future</code> 只执行一次，仅需要当前线程相关的 <code>ExecutionContext</code>，而 <code>Observable</code> 执行多次，需要一个 <code>Scheduler</code> 来控制。</p><h3 id="Observable-基础"><a href="#Observable-基础" class="headerlink" title="Observable 基础"></a><code>Observable</code> 基础</h3><p>来看一个使用 <code>Observable</code> 的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> seconds)</div><div class="line"><span class="keyword">val</span> evens: <span class="type">Observable</span>[<span class="type">Long</span>] = ticks.filter(s=&gt;s%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line"><span class="keyword">val</span> bufs: <span class="type">Observable</span>[<span class="type">Seq</span>[<span class="type">Long</span>]] = ticks.buffer(<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> s = bufs.subscribe(b=&gt;printLn(b))</div><div class="line">readLine()</div><div class="line">s.unscubscribe()</div></pre></td></tr></table></figure><p>分步执行如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> seconds)</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx1vfkdbzj20qo02kwer.jpg" alt="Observable-eg-01"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> evens: <span class="type">Observable</span>[<span class="type">Long</span>] = ticks.filter(s=&gt;s%<span class="number">2</span>==<span class="number">0</span>)</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx1vrs8z6j20qi02kmxi.jpg" alt="Observable-eg-02"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bufs: <span class="type">Observable</span>[<span class="type">Seq</span>[<span class="type">Long</span>]] = ticks.buffer(<span class="number">2</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx1xgfogjj20qq02x3yx.jpg" alt="Observable-eg-03"></p><p>练习：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs = <span class="type">Observable</span>.range(<span class="number">1</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure><p>的弹子图如下：</p><p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epx205cuvoj20qq02maac.jpg" alt="range"></p><p>那么</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ys = xs.map(x =&gt; x + <span class="number">1</span>)</div></pre></td></tr></table></figure><p>的弹子图是什么？</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx20fkytoj20zp0asac4.jpg" alt="options"></p><p>答案是 B。</p><h3 id="Observable-上的组合子"><a href="#Observable-上的组合子" class="headerlink" title="Observable 上的组合子"></a><code>Observable</code> 上的组合子</h3><p>操作 <code>Observable[T]</code> 的高阶函数有这些：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">Observable</span>[<span class="type">B</span>]): <span class="type">Observable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">Observable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeWhile</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>(): <span class="type">List</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">B</span>](that: <span class="type">Observable</span>[<span class="type">B</span>]): <span class="type">Observable</span>[(<span class="type">A</span>, <span class="type">B</span>)]</div></pre></td></tr></table></figure><p>其中 <code>map</code> 的弹子图是：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx3yeqsnaj20th0ehdi5.jpg" alt="map"></p><p><code>flatMap</code> 定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(f: <span class="type">T</span>=&gt;<span class="type">Observable</span>[<span class="type">S</span>]): <span class="type">Observable</span>[<span class="type">S</span>] = &#123; map(f).flatten() &#125;</div></pre></td></tr></table></figure><p>其弹子图为：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx416dmvkj20zq0e6acj.jpg" alt="flatMap"></p><p>有两种扁平化叠套流的方法，一种是 <code>flatten</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Int</span>] = <span class="type">Observable</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> yss: <span class="type">Observable</span>[<span class="type">Observable</span>[<span class="type">Int</span>]] =</div><div class="line">   xs.map(x =&gt; <span class="type">Observable</span>.<span class="type">Interval</span>(x seconds).map(_=&gt;x).take(<span class="number">2</span>))</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Int</span>] = yss.flatten()</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx45oxj4rj20z80aigna.jpg" alt="flatten"></p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx478ezznj20t60htmzd.jpg" alt="merge"></p><p>另一种是 <code>concat</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Int</span>] = <span class="type">Observable</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> yss: <span class="type">Observable</span>[<span class="type">Observable</span>[<span class="type">Int</span>]] =</div><div class="line">   xs.map(x =&gt; <span class="type">Observable</span>.<span class="type">Interval</span>(x seconds).map(_=&gt;x).take(<span class="number">2</span>))</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Int</span>] = yss.concat()</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx492aeysj20ys0ah0uk.jpg" alt="concat-eg"></p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx49b2cuuj20t20hpdib.jpg" alt="concat"></p><p>下面通过一个处理地震通知的例子来展示如何映射和过滤异步的数据流。定义基本的结构如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">usgs</span></span>(): <span class="type">Observable</span>[<span class="type">EarthQuake</span>] = &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EarthQuake</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">magnitude</span></span>: <span class="type">Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">location</span></span>: <span class="type">GeoCoordinate</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Magnitude</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(magnitude: <span class="type">Double</span>): <span class="type">Magnitude</span> = &#123; ... &#125;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Magnitude</span> </span>= <span class="type">Value</span></div><div class="line">  <span class="keyword">val</span> <span class="type">Micro</span>, <span class="type">Minor</span>, <span class="type">Light</span>, <span class="type">Moderate</span>, <span class="type">Strong</span>, <span class="type">Major</span>, <span class="type">Great</span> = <span class="type">Value</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用起来大概是这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> quakes = usgs()</div><div class="line"><span class="keyword">val</span> major = quakes</div><div class="line">  .map(q=&gt;(q.<span class="type">Location</span>, <span class="type">Magnitude</span>(q.<span class="type">Magnitude</span>)))</div><div class="line">  .filter&#123; <span class="keyword">case</span> (loc,mag) =&gt; mag &gt;= <span class="type">Major</span> &#125;</div><div class="line">major.subscribe(&#123; <span class="keyword">case</span> (loc, mag) =&gt; &#123;</div><div class="line">  println($<span class="string">"Magnitude $&#123; mag &#125; quake at $&#123; loc &#125;"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>现在想通过网络将地震处的地理坐标转换为国家信息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseGeocode</span></span>(c: <span class="type">GeoCoordinate</span>): <span class="type">Future</span>[<span class="type">Country</span>] = &#123; ... &#125;</div><div class="line"><span class="keyword">val</span> withCountry: <span class="type">Observable</span>[<span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]] =</div><div class="line">  usgs().map(quake =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> country: <span class="type">Future</span>[<span class="type">Country</span>] = reverseGeocode(q.<span class="type">Location</span>)</div><div class="line">    <span class="type">Observable</span>(country.map(country=&gt;(quake,country)))</div><div class="line">  &#125;)</div><div class="line"><span class="comment">// This</span></div><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.flatten()</div><div class="line"><span class="comment">// Or this?</span></div><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.concat()</div></pre></td></tr></table></figure><p>那么问题来了，该用 <code>flatten</code> 还是 <code>concat</code>？如果用 <code>flatten</code>：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4ru2yr7j20vu0fvjtc.jpg" alt="geo-flatten"></p><p>最终收到地震消息的顺序会因为反向解析的延迟而出现错乱，而如果用 <code>concat</code> 则没问题：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4trgmxqj210v0eyq54.jpg" alt="geo-concat"></p><p>看一个新函数 <code>groupBy</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](keySelector: <span class="type">T</span>=&gt;<span class="type">K</span>): <span class="type">Observable</span>[(<span class="type">K</span>,<span class="type">Observable</span>[<span class="type">T</span>])]</div></pre></td></tr></table></figure><p>它的弹子图为：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4v4pqr0j20pp0f8dhn.jpg" alt="groupBy"></p><p>原序列元素根据形状分为了两组，最终产生了三个数据流。</p><p>现在想让收到的地震信息根据国家不同而分类，可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.flatten()</div><div class="line"><span class="keyword">val</span> byCountry: <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]] =</div><div class="line">  merged.groupBy&#123; <span class="keyword">case</span> (q,c) =&gt; c &#125;</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx4ylfq96j20xx0a3gmt.jpg" alt="group-eg"></p><p>练习：</p><p>若想统计不同国家发生地震的平均次数，部分代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> byCountry: <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runningAverage</span></span>(s : <span class="type">Observable</span>[<span class="type">Double</span>]): <span class="type">Observable</span>[<span class="type">Double</span>] = &#123;...&#125;</div><div class="line"><span class="keyword">val</span> runningAveragePerCountry : <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[<span class="type">Double</span>])]</div></pre></td></tr></table></figure><p>那么 <code>runningAveragePerCountry</code> 的实现应该是什么？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, quakes) =&gt; (country, runningAverage(quakes))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// b)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, quakes) =&gt; (country, runningAverage(quakes.map(_.<span class="type">Magnitude</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// c)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, cqs) =&gt; (country, runningAverage(cqs.map(_._1.<span class="type">Magnitude</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据类型匹配的原则可以得出答案为 C。</p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>如何取消订阅呢？这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> quakes: <span class="type">Observable</span>[<span class="type">EarthQuake</span>] = ...</div><div class="line"><span class="keyword">val</span> s: <span class="type">Subscription</span> = quakes.<span class="type">Subscribe</span>(...)</div><div class="line">s.unsubscribe()</div></pre></td></tr></table></figure><p><code>Observable</code> 可分为两种，一种称为 Hot Observable，所有的订阅者共享同样的源：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx6vvjgxqj20ih0hwq4k.jpg" alt="hot observable"></p><p>另一种称为 Cold Observable，每个订阅者都有自己的私有源：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx6w6gawnj20ji0hxgni.jpg" alt="cold observable"></p><p>注意取消订阅不等于终止源，因为可能还存在其他订阅者。</p><p><code>Subscription</code> 的基础定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(unsubscribe: =&gt; <span class="type">Unit</span>):<span class="type">Subscription</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Subscription</code> 家族中包含这些成员：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BooleanSubscription</span> <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUnsubscribed</span></span>: <span class="type">Boolean</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CompositeSubscription</span> <span class="keyword">extends</span> <span class="title">BooleanSubscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+=</span></span>(s: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">-=</span></span>(s: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MultipleAssignmentSubscription</span> <span class="keyword">extends</span> <span class="title">BooleanSubscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscription</span></span>: <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscription_=</span></span>(that: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面的代码中 <code>subscription</code> 被调用了两次：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> subscription = <span class="type">Subscription</span> &#123;</div><div class="line">   println(<span class="string">"bye, bye, I’m out fishing"</span>)</div><div class="line">&#125;</div><div class="line">subscription.unsubscribe()</div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure><p>结果是只有第一次会输出字符串。就是说，<code>unsubscribe</code> 可以被调用多次，它必须是<a href="http://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="external">幂等（idempotent）</a>的。</p><p><code>BooleanSubscription</code> 有一个 <code>isUnsubscribed</code> 方法，它能指示此订阅是否已被取消：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> subscription = <span class="type">BooleanSubscription</span> &#123;</div><div class="line">   println(<span class="string">"bye, bye, I’m out fishing"</span>)</div><div class="line">&#125;</div><div class="line">println(subscription.isUnsubscribed)</div><div class="line">subscription.unsubscribe()</div><div class="line">println(subscription.isUnsubscribed)</div></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7ctkstbj204q0f2glw.jpg" alt="BooleanSubscription"></p><p><code>CompositeSubscription</code> 可以包含许多订阅，当其被取消时所包含的订阅也会被取消：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">BooleanSubscription</span> &#123; println(<span class="string">"A"</span>) &#125;</div><div class="line"><span class="keyword">val</span> b = <span class="type">Subscription</span> &#123; println(<span class="string">"B"</span>) &#125;</div><div class="line"><span class="keyword">val</span> composite = <span class="type">CompositeSubscription</span>(a,b)</div><div class="line">println(composite.isUnsubscribed)</div><div class="line">composite.unsubscribe()</div><div class="line">println(composite.isUnsubscribed)</div><div class="line">println(a.isUnsubscribed)</div><div class="line">composite += <span class="type">Subscription</span>&#123; println (<span class="string">"C"</span>) &#125;</div></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx7dcsud4j20dr0ipgna.jpg" alt="CompositeSubscription-subscribe"></p><p>当新加入订阅时，若 <code>CompositeSubscription</code> 未被取消则新订阅状态不变，若 <code>CompositeSubscription</code> 已被取消则新订阅会被立刻取消：</p><p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx7e96l9tj210h0h0aec.jpg" alt="CompositeSubscription-add"></p><p><code>MultiAssignment</code> 只能包含一个子订阅，且它自身包含了一个隐式的订阅：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7hz7kt6j20zv0h5q7a.jpg" alt="MultiAssignment-subscribe"></p><p>新加入订阅时的行为和 <code>CompositeSubscription</code> 类似：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7kqh7uaj20za0gigpe.jpg" alt="MultiAssignment-add"></p><p>当子订阅被取消时，<code>MultiAssignment</code> 的隐式订阅并不会被取消：</p><p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7llgmrrj20yt0f2wh8.jpg" alt="MultiAssignment-unscribe"></p><p>练习：</p><p>有如下代码段：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">BooleanSubscription</span> &#123; println(<span class="string">"A"</span>) &#125;</div><div class="line"><span class="keyword">val</span> b = <span class="type">Subscription</span> &#123; println(<span class="string">"B"</span>) &#125;</div><div class="line"><span class="keyword">val</span> c = <span class="type">CompositeSubscription</span>(a,b)</div><div class="line"><span class="keyword">val</span> m = <span class="type">MultiAssignmentSubscription</span>()</div><div class="line">m.subscription = c</div><div class="line">c.unsubscribe</div></pre></td></tr></table></figure><p>下面哪个是正确的？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) b.isUnsubscribed == <span class="literal">true</span></div><div class="line">b) a.isUnsubscribed == <span class="literal">false</span></div><div class="line">c) m.isUnsubscribed == <span class="literal">true</span></div><div class="line">d) c.isUnsubscribed == <span class="literal">true</span></div></pre></td></tr></table></figure><p>答案是 D。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Future-T-和-Try-T-是对偶（dual）&quot;&gt;&lt;a href=&quot;#Future-T-和-Try-T-是对偶（dual）&quot; class=&quot;headerlink&quot; title=&quot;Future[T] 和 Try[T] 是对偶（dual）&quot;&gt;&lt;/a&gt;&lt;code&gt;Future[T]&lt;/code&gt; 和 &lt;code&gt;Try[T]&lt;/code&gt; 是&lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_%28category_theory%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;对偶（dual）&lt;/a&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Future&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;] &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OnComplete&lt;/span&gt;&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;U&lt;/span&gt;](func: &lt;span class=&quot;type&quot;&gt;Try&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;] =&amp;gt; &lt;span class=&quot;type&quot;&gt;U&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;implicit&lt;/span&gt; ex: &lt;span class=&quot;type&quot;&gt;ExecutionContext&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015.02.19</title>
    <link href="http://stormluke.me/2015-02-19/"/>
    <id>http://stormluke.me/2015-02-19/</id>
    <published>2015-02-18T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.030Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.pixiv.net/member_illust.php?illust_id=48751362&amp;mode=medium" target="_blank" rel="external"><img src="http://ww1.sinaimg.cn/large/6ad06ebbgy1fdulvs47uzj20jk0rs4lo.jpg" alt=""></a></p><a id="more"></a><p><a href="http://music.163.com/#/song?id=401632" target="_blank" rel="external">おひさま</a></p><p>晚安。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.pixiv.net/member_illust.php?illust_id=48751362&amp;amp;mode=medium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6ad06ebbgy1fdulvs47uzj20jk0rs4lo.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小阴谋家——一遍又一遍</title>
    <link href="http://stormluke.me/the-little-schemer-4th-edition-ch9/"/>
    <id>http://stormluke.me/the-little-schemer-4th-edition-ch9/</id>
    <published>2015-02-11T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.038Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://kysmykseka.net/koti/wizardry/Programming/Lisp/Scheme/The%20Little%20Schemer%204th%20Ed.pdf" target="_blank" rel="external"><em>The Little Schemer 4th Edition Ch9 - …and Again, and Again, and Again, …</em></a>。</p><p>（这篇文章提到了 Y combinator。）</p><a id="more"></a><p>A：你想吃<em>鱼子酱</em>吗？</p><p>B：那我们必须去<em>寻找</em>它。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(looking a lat)</code> 的结果是什么？</p><p>B：<code>#t</code>，很明显 <code>caviar</code> 在 <code>lat</code> 中。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 grits caviar 5 7 3)</code> 时 <code>(looking a lat)</code> 呢？</p><p>B：<code>#f</code>。</p><p>A：和你想的不一样？</p><p>B：是啊，<code>caviar</code> 仍在 <code>lat</code> 中。</p><p>A：确实，但 <code>lat</code> 的第一个数字是什么？</p><p>B：6。</p><p>A：那 <code>lat</code> 的第六个元素是什么？</p><p>B：7。</p><p>A：第七个元素呢？</p><p>B：3。</p><p>A：所以 <code>looking</code> 显然找不到 <code>caviar</code>。</p><p>B：确实，因为第三个元素是 <code>grits</code>，和 <code>caviar</code> 一点也不像。</p><p>A：这是 <code>looking</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> looking</div><div class="line">  (<span class="name">lambda</span> (<span class="name">a</span> lat)</div><div class="line">    (<span class="name">keep-looking</span> a (<span class="name">pick</span> <span class="number">1</span> lat) lat)))</div></pre></td></tr></table></figure><p>写出 <code>keep-looking</code>。</p><p>B：我们不期望你知道答案。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(looking a lat)</code> 呢？</p><p>B：<code>#t</code>，因为 <code>(keep-looking a 6 lat)</code> 和 <code>(keep-looking a (pick 1 lat) lat)</code> 结果相同。</p><p>A：当 <code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(pick 6 lat)</code> 的结果是什么？</p><p>B：7。</p><p>A：那我们该怎么办？</p><p>B：<code>(keep-looking a 7 lat)</code>，其中 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 。</p><p>A：当 <code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(pick 7 lat)</code> 的结果是什么？</p><p>B：3。</p><p>A：那么当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(6 2 4 caviar 5 7 3)</code> 时 <code>(keep-looking a 3 lat)</code> 的结果是什么？</p><p>B：和 <code>(keep-looking a 4 lat)</code> 一样。</p><p>A：那是？</p><p>B：<code>#t</code>。</p><p>A：写出 <code>keep-looking</code>。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> keep-looking</div><div class="line">  (<span class="name">lambda</span> (<span class="name">a</span> sorn lat)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">number</span>? sorn)</div><div class="line">       (<span class="name">keep-looking</span> a (<span class="name">pick</span> sorn lat) lat))</div><div class="line">      (<span class="name">else</span> (<span class="name">eq</span>? sorn a)))))</div></pre></td></tr></table></figure><p>A：你能猜出 <code>sorn</code> 代表啥吗？</p><p>B：符号或者数字。</p><p>A：<code>keep-looking</code> 有什么不寻常的地方？</p><p>B：它在 <code>lat</code> 某一部分上不递归。</p><p>A：我们把这叫做“非原始”递归（”unnatural” recursion）。</p><p>B：这确实很反常。</p><p>A：<code>keep-looking</code> 离其目标越来越近吗？</p><p>B：是的，从目前所有证据看来。</p><p>A：它始终和目标越来越近吗？</p><p>B：有时列表会既不包含 <code>caviar</code> 也不包含 <code>grits</code>。</p><p>A：嗯对。列表可能是元组（仅包含数字）。</p><p>B：嗯，如果我们在 <code>(7 2 4 7 5 6 3)</code> 上开始 <code>looking</code>，我们将永远不会停下来。</p><p>A：当 <code>a</code> 是 <code>caviar</code>，<code>lat</code> 是 <code>(7 1 2 caviar 5 6 3)</code> 时。<code>(looking a lat)</code> 的结果是什么？</p><p>B：这很奇怪！</p><p>A：确实奇怪。发生了啥？</p><p>B：我们不停地查询查询查询……</p><p>A：如同 <code>looking</code> 的函数叫做<a href="http://en.wikipedia.org/wiki/Partial_function" target="_blank" rel="external">偏函数（缺值函数 / partial function）</a>。你觉得我们到目前为止看到的函数叫什么？</p><p>B：它们叫做全函数（total function）。</p><p>A：你能定义一个给定某些参数时不能到达其目标的简短函数吗？</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> eternity</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">eternity</span> x)))</div></pre></td></tr></table></figure><p>A：有多少参数能让 <code>eternity</code> 到达其目标？</p><p>B：一个都没，这可能是最反常的递归了。</p><p>A：<code>eternity</code> 是偏的吗？</p><p>B：这是最偏的函数了。</p><p>A：当 <code>x</code> 是 <code>((a b) c)</code> 时 <code>(shift x)</code> 的结果是什么？</p><p>B：<code>(a (b c))</code>。</p><p>A：当 <code>x</code> 是 <code>((a b) (c d))</code> 时 <code>(shift x)</code> 的结果是什么？</p><p>B：<code>(a (b (c d)))</code>。</p><p>A：定义 <code>shift</code>。</p><p>B：这是平凡的；它甚至不递归！</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> shift</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pair</span>)</div><div class="line">    (<span class="name">build</span> (<span class="name">first</span> (<span class="name">first</span> pair))</div><div class="line">      (<span class="name">build</span> (<span class="name">second</span> (<span class="name">first</span> pair))</div><div class="line">        (<span class="name">second</span> pair)))))</div></pre></td></tr></table></figure><p>A：描述 <code>shift</code> 做了啥。</p><p>B：这是我们的陈述：“函数 <code>shift</code> 接受一个偶对，此偶对的第一部分也是一个偶对。该函数构造一个偶对，这个偶对是由参数偶对的第一部分的偶对的第二部分挪动到参数偶对的第二部分构成的。”</p><p>A：现在看看这个函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> align</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pora</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">atom</span>? pora) pora)</div><div class="line">      ((<span class="name">a-pair</span>? (<span class="name">first</span> pora))</div><div class="line">       (<span class="name">align</span> (<span class="name">shift</span> pora)))</div><div class="line">      (<span class="name">else</span> (<span class="name">build</span> (<span class="name">first</span> pora)</div><div class="line">              (<span class="name">align</span> (<span class="name">second</span> pora)))))))</div></pre></td></tr></table></figure><p>它和 <code>keep-looking</code> 有什么相似之处？</p><p>B：两个函数都改变了自身的参数以作递归用，但两个函数都不保证能到达其目标。</p><p>A：为什么我们不能保证 <code>align</code> 会有进展？</p><p>B：在 <code>cond</code> 的第二行 <code>shift</code> 为 <code>align</code> 创建的参数并不是原参数的一部分。</p><p>A：这违反了哪条戒律？</p><p>B：第七戒。</p><blockquote><p>第七戒<br>在子部分上的递归有同样的本质：<br>在列表的子列表上<br>在算术表达式的子表达式上</p></blockquote><p>A：新参数至少比原参数更小吗？</p><p>B：看起来不像。</p><p>A：为啥呢？</p><p>B：<code>shift</code> 函数仅仅重新排列了它得到的部分。</p><p>A：然后？</p><p>B：<code>shift</code> 的参数和结果有一样的原子个数。</p><p>A：你能写一个计算 <code>align</code> 参数中原子个数的函数吗？</p><p>B：没问题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> length *</div><div class="line">  (lambda (pora)</div><div class="line">    (cond</div><div class="line">      ((atom? pora) 1)</div><div class="line">      (else</div><div class="line">        (+ (length* (<span class="name">first</span> pora))</div><div class="line">           (length* (second pora)))))))</div></pre></td></tr></table></figure><p>A：<code>align</code> 是偏函数吗？</p><p>B：我们还不清楚。可能有某些参数使其一直做对齐操作。</p><p>A：<code>align</code> 的参数和其递归过程还有其他改变吗？</p><p>B：有的。偶对的第一部分变得更简单，同时第二部分变得更复杂。</p><p>A：第一部分怎么变得简单了？</p><p>B：它只是原来的第一部分。</p><p>A：这不就是说 <code>length*</code> 不能确定参数的长度？你能找出一个更好的函数吗？</p><p>B：更好的函数应该在第一部分上更加小心。</p><p>A：在第一部分上我们应该多小心？</p><p>B：至少两倍。</p><p>A：你是不是说类似于 <code>weight*</code> 这样的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> weight*</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pora</span>)</div><div class="line">   (<span class="name">cond</span></div><div class="line">     ((<span class="name">atom</span>? pora) <span class="number">1</span>)</div><div class="line">     (<span class="name">else</span></div><div class="line">       (<span class="name">+</span> (<span class="name">*</span> (<span class="name">weight*</span> (<span class="name">first</span> pora)) <span class="number">2</span>)</div><div class="line">          (<span class="name">weight*</span> (<span class="name">second</span> pora))))))</div></pre></td></tr></table></figure><p>B：看起来是。</p><p>A：当 <code>x</code> 是 <code>((a b) c)</code> 时 <code>(weight* x)</code> 的结果是什么？</p><p>B：7。</p><p>A：当 <code>x</code> 是 <code>(a (b c))</code> 时 <code>(weight* x)</code> 的结果是什么？</p><p>B：5。</p><p>A：这是不是意味着参数变简单了？</p><p>B：是的，<code>align</code> 参数的 <code>weight*</code> 值连续地变小。</p><p>A：<code>align</code> 是偏函数吗？</p><p>B：不，它对每个参数都能产生值。</p><p>A：这是 <code>shuffle</code>，它类似于 <code>align</code> 但用第七章中的 <code>revpair</code> 替换了 <code>shift</code>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> shuffle</div><div class="line">  (<span class="name">lambda</span> (<span class="name">pora</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">atom</span>? pora) pora)</div><div class="line">      ((<span class="name">a-pair</span>? (<span class="name">first</span> pora))</div><div class="line">       (<span class="name">shuffle</span> (<span class="name">revpair</span> pora)))</div><div class="line">      (<span class="name">else</span> (<span class="name">build</span> (<span class="name">first</span> pora)</div><div class="line">              (<span class="name">shuffle</span> (<span class="name">second</span> pora)))))))</div></pre></td></tr></table></figure><p>B：当偶对的第一部分是偶对时 <code>shuffle</code> 和 <code>revpair</code> 交换这两个部分。</p><p>A：这说明 <code>shuffle</code> 是完全的？</p><p>B：我们不知道。</p><p>A：让我们试试。当 <code>x</code> 是 <code>(a (b c))</code> 时 <code>(shuffle x)</code> 的结果是什么？</p><p>B：<code>(a (b c))</code>。</p><p>A：当 <code>x</code> 是 <code>(a b)</code> 时 <code>(shuffle x)</code> 呢？</p><p>B：<code>(a b)</code>。</p><p>A：好，让我们来点有趣的。当 <code>x</code> 是 <code>((a b) (c d))</code> 时 <code>(shuffle x)</code> 的结果是什么？</p><p>B：要确定结果，我们需要算出 <code>(shuffle (revpair pora))</code> 的值是什么。其中 <code>pora</code> 是 <code>((a b) (c d))</code>。</p><p>A：那我们该如何做呢？</p><p>B：我们应该确定 <code>(shuffle pora)</code> 的值。其中 <code>pora</code> 是 <code>((c d) (a b))</code>。</p><p>A：这不就是说我们需要知道当 <code>(revpair pora)</code> 是 <code>((a b) (c d))</code> 时 <code>(shuffle (revpair pora))</code> 的值？</p><p>B：是的。</p><p>A：所以？</p><p>B：<code>shuffle</code> 函数不是完全的，因为它现在再次交换了偶对的两部分，这说明我们重新来了一遍。</p><p>A：这个函数是完全的吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> C</div><div class="line">  (<span class="name">lambda</span> (<span class="name">n</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">one</span>? n) <span class="number">1</span></div><div class="line">      (<span class="name">else</span> cond</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">even</span>? n) (<span class="name">C</span> (<span class="name">/</span> (<span class="name">n</span> <span class="number">2</span>)))</div><div class="line">          (<span class="name">else</span> (<span class="name">C</span> (<span class="name">add1</span> (<span class="name">*</span> <span class="number">3</span> n)))))))))</div></pre></td></tr></table></figure><p>B：它不能产生 0，但除此之外没人知道为啥。谢谢你，<a href="http://en.wikipedia.org/wiki/Lothar_Collatz" target="_blank" rel="external">Lothar Collatz (1910-1990)</a>（<a href="http://zh.wikipedia.org/wiki/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3" target="_blank" rel="external">考拉兹猜想</a>）。</p><p>A：<code>(A 1 0)</code> 的值是什么？</p><p>B：2。</p><p>A：<code>(A 1 1)</code>？</p><p>B：3。</p><p>A：<code>(A 2 2)</code>？</p><p>B：7。</p><p>A：这是 <code>A</code> 的定义：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> A</div><div class="line">  (<span class="name">lambda</span> (<span class="name">n</span>, m)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">zero</span>? n) (<span class="name">add1</span> m))</div><div class="line">      ((<span class="name">zero</span>? m) (<span class="name">A</span> (<span class="name">sub1</span> n) <span class="number">1</span>))</div><div class="line">      (<span class="name">else</span> (<span class="name">A</span> (<span class="name">sub1</span> n)</div><div class="line">              (<span class="name">A</span> n (<span class="name">sub1</span> m)))))))</div></pre></td></tr></table></figure><p>B：谢谢你，<a href="http://en.wikipedia.org/wiki/Wilhelm_Ackermann" target="_blank" rel="external">Wilhelm Ackermann (1853-1946)</a>（<a href="http://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8" target="_blank" rel="external">阿克曼函数</a>）。</p><p>A：<code>A</code> 与 <code>shuffle</code> 和 <code>looking</code> 间有什么相同之处？</p><p>B：<code>A</code> 的参数像 <code>shuffle</code> 和 <code>looking</code> 的一样，不会随着递归必定降低。</p><p>A：举个例子？</p><p>B：这很容易：<code>(A 1 2)</code> 需要 <code>(A 0 (A 1 1))</code> 的值。而这又说明我们需要 <code>(A 0 3)</code> 的值。</p><p>A：<code>A</code> 总会给出解答吗？</p><p>B：是的，它是完全的。</p><p>A：那么 <code>(A 4 3)</code> 是多少？</p><p>B：对于实践情况来说，没有答案。</p><p>A：这什么意思？</p><p>B：在我们计算出 <code>(A 4 3)</code> 的结果之前你正在读的这页纸早就已经腐烂了。</p><blockquote><p>But answer came there none<br>And this was scarcely odd, because<br>They’d eaten every one.<br><em>The Walrus and The Carpenter</em><br><em>Lewis Carroll</em></p></blockquote><p>A：如果我们能写一个测定某函数能否对每个参数都有返回值的函数岂不是很棒？</p><p>B：确实会很棒。目前我们已经看到了不返回的函数和返回太慢的函数，我们确实应该有这样一种工具。</p><p>A：好的，让我们写写看。</p><p>B：这听起来很复杂。一个函数可以有许多不同的参数。</p><p>A：那么我们简化一下。作为一个热身练习，让我们只关注检查某函数对空列表是否停止的函数，这是最简单的参数了。</p><p>B：这会简化很多。</p><p>A：这是此函数的开头：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> will-stop?</div><div class="line">  (<span class="name">lambda</span> (<span class="name">f</span>)</div><div class="line">    ...))</div></pre></td></tr></table></figure><p>你能补全点吗？</p><p>B：它要干什么？</p><p>A：<code>will-stop?</code> 会对每个参数返回值吗？</p><p>B：这是最简单的部分：我们说它会返回 <code>#t</code> 或 <code>#f</code>，根据参数被应用上 <code>()</code> 时是否停止。</p><p>A：那么 <code>will-stop?</code> 是完全的吗？</p><p>B：是的。它始终返回 <code>#t</code> 或 <code>#f</code>。</p><p>A：那我们来举些例子。这是第一个。当 <code>f</code> 是 <code>length</code> 时 <code>(will-stop? f)</code> 的结果是什么？</p><p>B：我们知道当 <code>l</code> 是 <code>()</code> 时 <code>(length l)</code> 是 <code>0</code>。</p><p>A：所以？</p><p>B：所以 <code>(will-stop？ length)</code> 的值应当是 <code>#t</code>。</p><p>A：没错。换一个例子呢？ <code>(will-stop? eternity)</code> 的结果是什么？</p><p>B：<code>(eternity (quote ()))</code> 不会返回值。我们刚刚看到了。</p><p>A：这就是说 <code>(will-stop? eternity)</code> 是 <code>#f</code>？</p><p>B：嗯，是。</p><p>A：还需要更多的例子吗？</p><p>B：或许我们还需要另外一个例子。</p><p>A：好的，这个函数可能是 <code>will-stop?</code> 的一个有趣的参数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> last-try</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">and</span> (<span class="name">will-stop</span>? last-try)</div><div class="line">      (<span class="name">eternity</span> x))))</div></pre></td></tr></table></figure><p><code>(will-stop? last-try)</code> 的结果是什么？</p><p>B：它做了啥？</p><p>A：我们需要在 <code>()</code> 上测试它。</p><p>B：如果我们想知道 <code>(last-try (quote ()))</code> 的值，那我们必须确定</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">and</span> (<span class="name">will-stop</span>? last-try)</div><div class="line">  (<span class="name">eternity</span> (<span class="name">quote</span> ())))</div></pre></td></tr></table></figure><p>的值。</p><p>A：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">and</span> (<span class="name">will-stop</span>? last-try)</div><div class="line">  (<span class="name">eternity</span> (<span class="name">quote</span>())))</div></pre></td></tr></table></figure><p>的值是什么？</p><p>B：这取决于 <code>(will-stop? last-try)</code> 的值。</p><p>A：那这只有两种可能。我们假设 <code>(will-stop? last-try)</code> 是 <code>#f</code>。</p><p>B：好，那么 <code>(and #f (eternity (quote ())))</code> 是 <code>#f</code>， 因为 <code>(and #f ...)</code> 始终是 <code>#f</code>。</p><p>A：所以 <code>(last-try (quote ()))</code> 停止了，对吧？</p><p>B：确实停止了。</p><p>A：但刚刚 <code>will-stop</code> 不是说的正相反？</p><p>B：确实相反。我们假设 <code>(will-stop? last-try)</code> 的值是 <code>#f</code>，这说明 <code>last-try</code> 不会停止。</p><p>A：所以我们弄错了 <code>(will-stop? last-try)</code>。</p><p>B：是。它肯定返回 <code>#t</code>，因为 <code>will-stop?</code> 始终返回值。我们说过它是完全的。</p><p>A：很好。如果 <code>(will-stop? last-try)</code> 是 <code>#t</code>，那 <code>(last-try (quote ()))</code> 的值是什么？</p><p>B：现在我们只需确定 <code>(and #t (eternity (quote ())))</code> 的值，而这和 <code>(eternity (quote ()))</code> 的值一致。</p><p>A：<code>(eternity (quote ()))</code> 的值是什么？</p><p>B：它没有值。我们知道它不会停。</p><p>A：但这就意味着我们又错了！</p><p>B：是啊，因为这次我们假设 <code>(will-stop? last-try)</code> 是 <code>#t</code>。</p><p>A：你觉得这意味着什么？</p><p>B：这是我们的想法：“我们仔细检查了两种可能的情况。如果我们能<em>定义</em> <code>will-stop?</code>，那么 <code>(will-stop? last-try)</code> 肯定会产生 <code>#t</code> 或 <code>#f</code>。但是它不能——正是根据 <code>(will-stop?)</code> 被设想应做的那样。这肯定说明 <code>will-stop?</code> 不能被<em>定义</em>。”</p><p>A：这是特别的吗？</p><p>B：是的。这使得 <code>will-stop?</code> 是第一个我们能准确描述但不能在我们的语言中<em>定义</em>的函数。</p><p>A：有什么方法能解决这个问题吗？</p><p>B：没有。谢谢你，<a href="http://en.wikipedia.org/wiki/Alan_Turing" target="_blank" rel="external">Alan M Turing (1912-1954)</a> （<a href="http://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="external">停机问题</a>）和 <a href="http://en.wikipedia.org/wiki/Kurt_G%C3%B6del" target="_blank" rel="external">Kurt Gödel (1906-1978)</a>。</p><p>A：<code>(define ...)</code> 是什么？</p><p>B：这是个好问题。我们刚看到了 <code>(define ..)</code> 对 <code>will-stop?</code> 不管用。</p><p>A：所以啥是递归定义呢？</p><p>B：抓紧，深呼吸，准备好后向前冲。</p><p>A：这是 <code>length</code> 函数吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> length</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div></pre></td></tr></table></figure><p>B：必须是啊。</p><p>A：如果我们没有 <code>(define ...)</code> 该怎么办？我们还能定义 <code>length</code> 吗？</p><p>B：没有 <code>(define ...)</code>，就不能在 <code>length</code> 的定义体中引用到 <code>length</code>。</p><p>A：这个函数做了啥？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">eternity</span> (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>B：它确定空列表的长度，没了。</p><p>A：当我们在一个非空列表上用它时会怎样？</p><p>B：没答案。如果我们给 <code>eternity</code> 一个参数，它不会给出答案。</p><p>A：对于 <code>length</code> 这样的函数这说明什么？</p><p>B：对非空列表来说其不会给出任何答案。</p><p>A：假设我们可以命名这个新函数。啥名字好？</p><p>B：<code>length0</code>。因为这个函数只能确定空列表的长度。</p><p>A：你如何写一个确定包含一个或多个元素的列表的长度的函数？</p><p>B：呃，我们可以试试下面这个。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length0</span> (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>A：差不多，但 <code>(define ...)</code> 对 <code>length0</code> 不管用。</p><p>B：所以，替换 <code>length0</code> 为它的定义。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span></div><div class="line">      (<span class="name">add</span> <span class="number">1</span></div><div class="line">        ((<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">          (<span class="name">cond</span></div><div class="line">            ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">            (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                    (<span class="name">eternity</span> (<span class="name">cdr</span> l))))))</div><div class="line">          (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>A：那这个函数叫啥好呢？</p><p>B：很简单：<code>length≤1</code>。</p><p>A：这是能确定包含两个或更少项的列表长度的函数吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">  (<span class="name">cond</span></div><div class="line">    ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">    (<span class="name">else</span></div><div class="line">      (<span class="name">add1</span></div><div class="line">        ((<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">           (<span class="name">cond</span></div><div class="line">             ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">             (<span class="name">else</span></div><div class="line">               (<span class="name">add1</span></div><div class="line">                 ((<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">                   (<span class="name">cond</span></div><div class="line">                     ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">                     (<span class="name">else</span></div><div class="line">                       (<span class="name">add1</span></div><div class="line">                         (<span class="name">eternity</span></div><div class="line">                           (<span class="name">cdr</span> l))))))</div><div class="line">                   (<span class="name">cdr</span> l))))))</div><div class="line">          (<span class="name">cdr</span> l))))))</div></pre></td></tr></table></figure><p>B：是的，这就是 <code>length≤2</code>。我们仅把 <code>eternity</code> 换成了下一版的 <code>length</code>。</p><p>A：现在，你觉得递归是什么？</p><p>B：啥意思？</p><p>A：我们已经看到了如何确定空列表的长度、不多于一项列表的长度和不多于两项列表的长度等等。我们如何才能实现原先的 <code>length</code> 函数？</p><p>B：如果我们能写无穷多个函数，以 <code>length0</code>、<code>length≤1</code>、<code>length≤2</code>、……这样的形式，那我们就可以写出 <code>length∞</code>，这就可以确定我们能做出的所有列表的长度。</p><p>A：我们能做出多长的列表？</p><p>B：呃，列表可能是空的，或者包含一个元素，或者两个，或者三个，或者四个，……，或者 1001 个，……</p><p>A：但我们不能写出一个无穷的函数。</p><p>B：不能。</p><p>A：而且我们仍旧在这些函数里面有这些重复和模式。</p><p>B：是的。</p><p>A：这些模式像什么？</p><p>B：所有的这些程序包含一个像 <code>length</code> 的函数。或许我们应该抽象出这个函数：参见第九戒。</p><blockquote><p>第九戒<br>用新函数抽象通用模式</p></blockquote><p>A：让我们试试看！</p><p>B：我们需要一个看起来像 <code>length</code> 但由 <code>(lambda (length) ...)</code> 开头的函数。</p><p>A：你是说这个？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  eternity)</div></pre></td></tr></table></figure><p>B：嗯，可以。这创建了 <code>length0</code>。</p><p>A：用同样的方式重写 <code>length≤1</code>。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">f</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">f</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">g</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">g</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    eternity))</div></pre></td></tr></table></figure><p>A：我们必须用 <code>length</code> 来命名参数吗？</p><p>B：不用，我们只用了 <code>f</code> 和 <code>g</code>。只要我们保持一致，任何事都没问题。</p><p>A：那 <code>length≤2</code> 呢？</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      eternity)))</div></pre></td></tr></table></figure><p>A：快了，但现在仍有重复。</p><p>B：确实。让我们去掉它们。</p><p>A：我们从哪开始？</p><p>B：给这个以 <code>length</code> 作为参数返回另一个类似 <code>length</code> 函数的函数起个名字。</p><p>A：这个函数啥名字好？</p><p>B：<code>mk-length</code> 咋样？意思是 make length。</p><p>A：行，在 <code>length0</code> 上试试。</p><p>B：没问题。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> eternity))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：这是 <code>length≤1</code> 吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span></div><div class="line">    (<span class="name">mk-length</span> eternity)))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：当然。然后这是 <code>length≤2</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span></div><div class="line">    (<span class="name">mk-length</span></div><div class="line">      (<span class="name">mk-length</span> eternity))))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：你能以这种方法写出 <code>length≤3</code> 吗？</p><p>B：妥妥的。这就是。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span></div><div class="line">    (<span class="name">mk-length</span></div><div class="line">      (<span class="name">mk-length</span></div><div class="line">        (<span class="name">mk-length</span> eternity)))))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：递归像什么？</p><p>B：像一座对任意函数应用 <code>mk-length</code> 的无限高的塔。</p><p>A：我们真的需要一个无限高的塔吗？</p><p>B：当然不必要。每次使用 <code>length</code> 时我们只需要有限的数量，但是我们不知道是多少。</p><p>A：我们能猜出来需要多少吗？</p><p>B：可以，但我们有时候猜的不够大。</p><p>A：如果猜的不够大，什么时候我们才能知道？</p><p>B：当我们应用传递给最内层 <code>mk-length</code> 的 <code>eternity</code> 函数时。</p><p>A：如果此时我们能创建对 <code>mk-length</code> 应用 <code>eternity</code> 的另一个应用会发生什么？</p><p>B：这只会将问题推迟一点，另外，我们怎样才能做到这点呢？</p><p>A：因为没人关心我们给 <code>mk-length</code> 传递了什么函数，我们可以从一开始就传递 <code>mk-length</code>。</p><p>B：这是个好主意。然后我们在 <code>eternity</code> 上应用 <code>mk-length</code>，在 <code>cdr</code> 上应用其结果，这样我们就从塔上多得到了一层。</p><p>A：那么这仍旧是 <code>length0</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                (<span class="name">length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：是的，我们甚至能用 <code>mk-length</code> 替代 <code>length</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                (<span class="name">mk-length</span> (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：为什么我们想这样做？</p><p>B：所有名字都是平等的，但有些名字比其他名字更平等。</p><p>A：真理：只要我们一致地使用名字，我们就没问题。</p><p>B：<code>mk-length</code> 比 <code>length</code> 平等得多。如果我们用类似 <code>mk-length</code> 这样的名字，这就像一个提示，提示我们 <code>mk-length</code> 的第一个参数是 <code>mk-length</code>。</p><p>A：现在 <code>mk-length</code> 被传递给 <code>mk-length</code>， 我们能用参数来构建另一个递归调用吗？</p><p>B：能，当我们应用 <code>mk-length</code> 一次，我们得到 <code>length≤1</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                ((<span class="name">mk-length</span> eternity)</div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：当 <code>l</code> 是 <code>(apples)</code> 时</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                ((<span class="name">mk-length</span> eternity)</div><div class="line">                  (<span class="name">cdr</span> l))))))))</div><div class="line">  l)</div></pre></td></tr></table></figure><p>的结果是什么？</p><p>B：这是个好练习。不用纸笔解出它。</p><p>A：我们能这样做多于一次吗？</p><p>B：可以，不断把 <code>mk-length</code> 传递给自己就行，我们可以随时需要随时做！</p><p>A：你把这个函数叫做什么？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">                ((<span class="name">mk-length</span> mk-length)</div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：这是必须是 <code>length</code> 啊。</p><p>A：它是如何运作的？</p><p>B：它向自身传递 <code>mk-length</code> 来不断添加递归操作，就像它即将到期一样。</p><p>A：还剩一个问题：它不包含一个像 <code>length</code> 的函数了。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                ((<span class="name">mk-length</span> mk-length)</div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>你能改改这个吗？</p><p>B：我们可以把将 <code>mk-length</code> 应用到自身的这个过程抽取出来并称为 <code>length</code>。</p><p>A：为啥？</p><p>B：因为它确实实现了 <code>length</code> 这个功能。</p><p>A：这个怎样？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div></pre></td></tr></table></figure><p>B：看起来不错。</p><p>A：让我们看看它是否能行。</p><p>B：好。</p><p>A：当 <code>l</code> 是 <code>(apples)</code> 时</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div><div class="line">  l)</div></pre></td></tr></table></figure><p>的结果是什么？</p><p>B：应该是 <code>1</code>。</p><p>A：首先，我们需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div></pre></td></tr></table></figure><p>的值。</p><p>B：确实，因为这个表达式的值正是我们要应用 <code>l</code> 的函数，其中 <code>l</code> 是 <code>(apples)</code>。</p><p>A：所以我们其实需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    (<span class="name">mk-length</span> mk-length)))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length))))</div></pre></td></tr></table></figure><p>的值。</p><p>B：确实。</p><p>A：但之后我们其实需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">      (<span class="name">mk-length</span> mk-length)))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">        (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">          (<span class="name">cond</span></div><div class="line">            ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">            (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">        (<span class="name">mk-length</span> mk-length)))))</div></pre></td></tr></table></figure><p>的值。</p><p>B：是的，确实。这个的终点在哪？我们不还依旧需要</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">    (<span class="name">cond</span></div><div class="line">      ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">      (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">        (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">          (<span class="name">cond</span></div><div class="line">            ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">            (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">        (<span class="name">mk-length</span> mk-length)))</div><div class="line">      (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">        ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">          (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">            (<span class="name">cond</span></div><div class="line">              ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">              (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">          (<span class="name">mk-length</span> mk-length))))))</div></pre></td></tr></table></figure><p>的值？</p><p>A：是，这没个头啊。为啥呢？</p><p>B：因为我们只是一遍一遍地把 <code>mk-length</code> 应用到自己。</p><p>A：这很奇怪吧？</p><p>B：因为之前 <code>mk-length</code> 在我们应用一个参数时会返回一个函数。实际上，它不关心我们应用了什么。</p><p>A：但现在我们把 <code>(mk-length mk-length)</code> 从 <code>length</code> 函数中抽取了出来，它就不在返回函数了。</p><p>B：嗯是。所以该咋办？</p><p>A：把最后正确版本的 <code>mk-length</code> 转换成一个函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                ((<span class="name">mk-length</span> mk-length)</div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>B：咋弄？</p><p>A：有个不同的办法。如果 <code>f</code> 是个一元函数，那么 <code>(lambda (x) (f x))</code> 也是个一元函数吗？</p><p>B：是。</p><p>A：如果 <code>(mk-length mk-length)</code> 返回一个一元函数，那么</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">  ((<span class="name">mk-length</span> mk-length) x))</div></pre></td></tr></table></figure><p>也返回一个一元函数吗？</p><p>B：实际上，</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">  ((<span class="name">mk-length</span> mk-length) x))</div></pre></td></tr></table></figure><p>是一个函数！</p><p>A：很好，让我们处理下 <code>mk-length</code> 对自己的应用。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">add1</span></div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                ((<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">                  ((<span class="name">mk-length</span> mk-length) x))</div><div class="line">               <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">                  (<span class="name">cdr</span> l))))))))</div></pre></td></tr></table></figure><p>A：把新函数移出来我们就找回了 <code>length</code>。</p><p>B：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">  (<span class="name">mk-length</span> mk-length))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">    ((<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">      (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">        (<span class="name">cond</span></div><div class="line">          ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span></div><div class="line">            (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div><div class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></div><div class="line">      (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">        ((<span class="name">mk-length</span> mk-length) x)))))</div></pre></td></tr></table></figure><p>A：把函数移出来没问题吗？</p><p>B：我们只是做了把名字换成值正相反的事。这里我们抽取出值并给它一个名字。</p><p>A：我们能把方框里像 <code>length</code> 的那个函数抽取出来并命名吗？</p><p>B：可以，它根本不依赖于 <code>mk-length</code>！</p><p>A：这是正确的函数吗？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">((<span class="name">lambda</span> (<span class="name">le</span>)</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">mk-length</span> mk-length))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      (<span class="name">le</span> (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">            ((<span class="name">mk-length</span> mk-length) x)))))))</div><div class="line">  (<span class="name">lambda</span> (<span class="name">length</span>)</div><div class="line">    (<span class="name">lambda</span> (<span class="name">l</span>)</div><div class="line">      (<span class="name">cond</span></div><div class="line">        ((<span class="name">null</span>? l) <span class="number">0</span>)</div><div class="line">          (<span class="name">else</span> (<span class="name">add1</span> (<span class="name">length</span> (<span class="name">cdr</span> l)))))))</div></pre></td></tr></table></figure><p>B：对。</p><p>A：我们实际上得到了啥？</p><p>B：我们抽取出了原先的函数 <code>mk-length</code>。</p><p>A：让我们从像 <code>length</code> 的函数中分出创建 <code>length</code> 的函数。</p><p>B：这很简单。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">lambda</span> (<span class="name">le</span>)</div><div class="line">  ((<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">    (<span class="name">mk-length</span> mk-length))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">mk-length</span>)</div><div class="line">      (<span class="name">le</span> (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">            ((<span class="name">mk-length</span> mk-length) x))))))</div></pre></td></tr></table></figure><p>A：这个函数有名字吗？</p><p>B：有，这叫做<a href="http://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90" target="_blank" rel="external">应用序 Y 组合子（applicative-order Y combinator）</a>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> Y</div><div class="line">  (<span class="name">lambda</span> (<span class="name">le</span>)</div><div class="line">    ((<span class="name">lambda</span> (<span class="name">f</span>) (<span class="name">f</span> f))</div><div class="line">      (<span class="name">lambda</span> (<span class="name">f</span>)</div><div class="line">        (<span class="name">le</span> (<span class="name">lambda</span> (<span class="name">x</span>) ((<span class="name">f</span> f) x)))))))</div></pre></td></tr></table></figure><p>A：<code>(define ...)</code> 又能用了？</p><p>B：是，现在我们知道递归是什么了。</p><p>A：你知道为啥 <code>Y</code> 管用吗？</p><p>B：重新阅读本章你就懂了。</p><p>A：啥是 <code>(Y Y)</code>。</p><p>B：鬼知道，看起来很复杂。</p><p>A：你的帽子还合适不？</p><p>B：在如此一场头脑风暴之后很难说啊。</p><blockquote><p>Stop the World - I Want to Get Off.<br><em>Leslie Bricusse and Anthony Newley</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;http://kysmykseka.net/koti/wizardry/Programming/Lisp/Scheme/The%20Little%20Schemer%204th%20Ed.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;The Little Schemer 4th Edition Ch9 - …and Again, and Again, and Again, …&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;（这篇文章提到了 Y combinator。）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015 要做的事</title>
    <link href="http://stormluke.me/todos-2015/"/>
    <id>http://stormluke.me/todos-2015/</id>
    <published>2015-01-07T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.039Z</updated>
    
    <content type="html"><![CDATA[<ul><li>练习钢笔字</li><li>学习设计相关知识</li><li>实现一个编译器</li><li>了解机器学习相关知识</li><li>上架至少一个 iOS App</li><li>学习 OpenGL 相关知识</li><li>阅读计算机经典书籍</li><li>尝试绘画</li><li>至少翻译一本英文专业书籍或每月一篇文章</li><li>学习日本语</li><li>尽可能多地写博客</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;练习钢笔字&lt;/li&gt;
&lt;li&gt;学习设计相关知识&lt;/li&gt;
&lt;li&gt;实现一个编译器&lt;/li&gt;
&lt;li&gt;了解机器学习相关知识&lt;/li&gt;
&lt;li&gt;上架至少一个 iOS App&lt;/li&gt;
&lt;li&gt;学习 OpenGL 相关知识&lt;/li&gt;
&lt;li&gt;阅读计算机经典书籍&lt;/li&gt;
&lt;li&gt;尝试绘画&lt;/li&gt;
&lt;li&gt;至少翻译一本英文专业书籍或每月一篇文章&lt;/li&gt;
&lt;li&gt;学习日本语&lt;/li&gt;
&lt;li&gt;尽可能多地写博客&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Merry X&#39;mas</title>
    <link href="http://stormluke.me/merry-xmas/"/>
    <id>http://stormluke.me/merry-xmas/</id>
    <published>2014-12-23T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://music.163.com/#/song?id=4949087" target="_blank" rel="external">ホーリーナイト</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://music.163.com/#/song?id=4949087&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ホーリーナイト&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AnimeList@2014</title>
    <link href="http://stormluke.me/my-anime-list/"/>
    <id>http://stormluke.me/my-anime-list/</id>
    <published>2014-12-22T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一旦接受了这种设定……其实还是蛮带感的……</p></blockquote><a id="more"></a><ul><li><a href="http://zh.moegirl.org/%E6%9F%90%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B6%85%E7%94%B5%E7%A3%81%E7%82%AE" target="_blank" rel="external">《某科学的超电磁炮》</a> / <a href="http://music.163.com/#/song?id=725692" target="_blank" rel="external">only my railgun</a> / <a href="http://music.163.com/#/song?id=725619" target="_blank" rel="external">Tokyo Hot</a> / <a href="http://zh.moegirl.org/%E4%BD%90%E5%A4%A9%E6%B3%AA%E5%AD%90" target="_blank" rel="external">掀裙狂魔</a>。不知道为啥就选了这个入门，那时候还不知道全球最大的同性交友网站。一切都是命运石之门的选择吧。</li><li><a href="http://zh.moegirl.org/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA" target="_blank" rel="external">《进击的巨人》</a> / <a href="http://music.163.com/#/song?id=26608719" target="_blank" rel="external">红莲の弓矢</a>。应该是第一个追着看的动漫。那时候刚开始减肥，也刚开始有考研的念头。</li><li><a href="http://zh.moegirl.org/%E6%88%91%E7%9A%84%E5%A6%B9%E5%A6%B9%E5%93%AA%E6%9C%89%E8%BF%99%E4%B9%88%E5%8F%AF%E7%88%B1" target="_blank" rel="external">《我的妹妹不可能那么可爱》</a> / <a href="http://zh.moegirl.org/%E6%96%B0%E5%9E%A3%E7%BB%AB%E6%BF%91" target="_blank" rel="external">小天使</a> / <a href="http://www.bilibili.com/video/av1327818/" target="_blank" rel="external">梅露露</a> / <a href="http://zh.moegirl.org/%E5%BE%B7%E5%9B%BD%E9%AA%A8%E7%A7%91" target="_blank" rel="external">德国骨科</a>。标题吸引了我。结局是什么鬼！！！害我去玩了 PSP 游戏。第一次听到兵库北。</li><li><a href="http://zh.moegirl.org/%E5%B0%B1%E7%AE%97%E6%98%AF%E5%93%A5%E5%93%A5%E6%9C%89%E7%88%B1%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98%E4%BA%86%E5%AF%B9%E5%90%A7" target="_blank" rel="external">《就算是哥哥有爱就没问题了对吧》</a>。看完《俺妹》后夜不能寐，怒找类似作品。只看标题是不靠谱的……已忘剧情。</li><li><a href="http://zh.moegirl.org/%E6%88%91%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%BE%88%E5%B0%91" target="_blank" rel="external">《我的朋友很少》</a> / <a href="http://zh.moegirl.org/%E7%BE%BD%E6%BF%91%E5%B7%9D%E5%B0%8F%E9%B8%A0" target="_blank" rel="external">羽濑川小鸠</a>。同上。《俺妹》印象太深，很长一段时间对人设画风要求“过高”，现在看还是可以接受的。</li><li><a href="http://zh.moegirl.org/%E6%88%91%E5%A5%B3%E5%8F%8B%E4%B8%8E%E9%9D%92%E6%A2%85%E7%AB%B9%E9%A9%AC%E7%9A%84%E6%83%A8%E7%83%88%E4%BF%AE%E7%BD%97%E5%9C%BA" target="_blank" rel="external">《我女友与青梅竹马的惨烈修罗场》</a>。同上。已忘剧情，人物也忘了……</li><li><a href="http://zh.moegirl.org/%E5%91%BD%E8%BF%90%E7%9F%B3%E4%B9%8B%E9%97%A8" target="_blank" rel="external">《命运石之门》❤</a> / <a href="http://zh.moegirl.org/%E7%89%A7%E6%BF%91%E7%BA%A2%E8%8E%89%E6%A0%96" target="_blank" rel="external">牧濑红莉栖</a> / <a href="http://www.bilibili.com/video/av78287/" target="_blank" rel="external">嘟嘟噜</a> / <a href="http://www.amazon.cn/s?field-keywords=Dr+Pepper" target="_blank" rel="external">Dr.Pepper</a>。一天看完 TV 和 OVA。真是神作！助手赛高！香菜的笑容由我来守护！</li><li><a href="http://zh.moegirl.org/%E4%B8%AD%E4%BA%8C%E7%97%85%E4%B9%9F%E8%A6%81%E8%B0%88%E6%81%8B%E7%88%B1" target="_blank" rel="external">《中二病也要谈恋爱》</a> / <a href="http://zh.moegirl.org/%E4%B8%B9%E7%94%9F%E8%B0%B7%E6%A3%AE%E5%A4%8F" target="_blank" rel="external">《黑暗圣典》作者 Mori Summer</a> / <a href="http://zh.moegirl.org/%E4%BA%AC%E9%83%BD%E5%8A%A8%E7%94%BB" target="_blank" rel="external">京都动画</a>。第一季比第二季好太多。<del>校园无厘头恋爱中二幻想动作打斗大片。</del></li><li><a href="http://zh.moegirl.org/%E4%BC%AA%E6%81%8B" target="_blank" rel="external">《伪恋》</a> / <a href="http://zh.moegirl.org/ClariS" target="_blank" rel="external">ClariS</a>。如果监督里没有新房昭之该多好……</li><li><a href="http://zh.moegirl.org/%E5%B1%9E%E6%80%A7%E5%90%8C%E5%A5%BD%E4%BC%9A" target="_blank" rel="external">《属性同好会 D-FRAGMENTS》</a>。欢乐！</li><li><a href="http://zh.moegirl.org/%E6%9C%80%E8%BF%91%E6%88%91%E7%9A%84%E5%A6%B9%E5%A6%B9%E6%9C%89%E7%82%B9%E6%80%AA" target="_blank" rel="external">《最近我的妹妹有点怪》</a>。<del>B 站看里番指日可待。</del>千万别看<a href="http://www.bilibili.com/video/av1045024/" target="_blank" rel="external">真人版</a>。</li><li><a href="http://zh.moegirl.org/%E8%BE%B2%E6%9E%97" target="_blank" rel="external">《农林》</a> / <a href="http://zh.moegirl.org/%E6%9C%A8%E4%B8%8B%E6%9E%97%E6%AA%8E" target="_blank" rel="external">宇宙第一可爱的苹果酱</a>。卖肉卖得清新脱俗~</li><li><a href="http://zh.moegirl.org/%E5%A6%84%E6%83%B3%E5%AD%A6%E7%94%9F%E4%BC%9A" target="_blank" rel="external">《妄想学生会》</a>。黄段子学生会。吐槽神作，刷新下限。</li><li><a href="http://zh.moegirl.org/%E9%87%8E%E8%89%AF%E7%A5%9E" target="_blank" rel="external">《野良神》</a> / 帅不过三秒。正常的动漫。</li><li><a href="http://zh.moegirl.org/%E6%9C%AA%E7%A1%AE%E8%AE%A4%E8%BF%9B%E8%A1%8C%E5%BC%8F" target="_blank" rel="external">《未确认进行式》</a>。<a href="http://www.bilibili.com/video/av910683/" target="_blank" rel="external">OP</a> <del>乳摇</del>实在太萌。</li><li><a href="http://zh.moegirl.org/%E6%81%8B%E7%88%B1%E9%9A%8F%E6%84%8F%E9%93%BE%E6%8E%A5" target="_blank" rel="external">《恋爱随意链接》❤</a> / <a href="http://zh.moegirl.org/%E7%A8%BB%E5%8F%B6%E5%A7%AC%E5%AD%90" target="_blank" rel="external">“其实我也曾把你当做我的自慰对象。”</a> / <a href="http://zh.moegirl.org/%E6%B0%B8%E6%BF%91%E4%BC%8A%E7%BB%87" target="_blank" rel="external">永濑伊织</a>。研究生面试前一天呆在宾馆补完。非常喜欢。稻叶儿太棒。</li><li><a href="http://zh.moegirl.org/%E6%88%91%E4%BB%AC%E4%BB%8D%E6%9C%AA%E7%9F%A5%E9%81%93%E9%82%A3%E5%A4%A9%E6%89%80%E7%9C%8B%E8%A7%81%E7%9A%84%E8%8A%B1%E7%9A%84%E5%90%8D%E5%AD%97" target="_blank" rel="external">《我们仍未知道那天所看见的花的名字》❤</a> / <a href="http://music.163.com/#/song?id=736081" target="_blank" rel="external">青い栞</a>。动漫竟能承载这么多的东西。</li><li><a href="http://zh.moegirl.org/%E9%BE%99%E4%B8%8E%E8%99%8E" target="_blank" rel="external">《龙与虎》</a> / <a href="http://music.163.com/#/song?id=4949087" target="_blank" rel="external">ホーリーナイト</a>。《那朵花》三人组的首作。</li><li><a href="http://zh.moegirl.org/%E6%9F%90%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B6%85%E7%94%B5%E7%A3%81%E7%82%AES" target="_blank" rel="external">《某科学的超电磁炮S》</a> / <a href="http://music.163.com/#/song?id=26341140" target="_blank" rel="external">Sister’s Noise</a>。第二季根本不治愈啊！！</li><li><a href="http://zh.moegirl.org/%E9%AD%94%E6%B3%95%E7%A6%81%E4%B9%A6%E7%9B%AE%E5%BD%95" target="_blank" rel="external">《魔法禁书目录》</a> / <a href="http://zh.moegirl.org/%E4%B8%8A%E6%9D%A1%E5%BD%93%E9%BA%BB" target="_blank" rel="external">Imagine Breaker</a>。《INDEX碳》才是正片吧。</li><li><a href="http://zh.moegirl.org/%E7%BA%A6%E4%BC%9A%E5%A4%A7%E4%BD%9C%E6%88%98" target="_blank" rel="external">《约会大作战》</a>。</li><li><a href="http://zh.moegirl.org/Love_Live!" target="_blank" rel="external">《Love Live!》</a>。邪教。</li><li><a href="http://zh.moegirl.org/%E6%BC%86%E9%BB%91%E7%9A%84%E5%AD%90%E5%BC%B9" target="_blank" rel="external">《漆黑的子弹》</a> / <a href="http://zh.moegirl.org/%E8%93%9D%E5%8E%9F%E5%BB%B6%E7%8F%A0" target="_blank" rel="external">蓝原延珠</a>。身为萝莉控真是太好了。</li><li><a href="http://zh.moegirl.org/%E6%9E%81%E9%BB%91%E7%9A%84%E5%B8%83%E4%BC%A6%E5%B8%8C%E5%B0%94%E7%89%B9" target="_blank" rel="external">《极黑的布伦希尔特》</a> / <a href="http://zh.moegirl.org/%E9%BB%91%E7%BE%BD%E5%AE%81%E5%AD%90" target="_blank" rel="external">我一点都不在乎</a>。烂！尾！了！漫画还是不错的。</li><li><a href="http://zh.wikipedia.org/wiki/%E6%BC%AB%E7%95%AB%E5%AE%B6%E8%88%87%E5%8A%A9%E6%89%8B" target="_blank" rel="external">《漫画家与助手》</a>。<del>长相平常、喜爱内裤的漫画家</del>「愛與勇氣的漫畫家」。</li><li><a href="http://zh.moegirl.org/%E6%88%91%E7%9A%84%E8%84%91%E5%86%85%E6%81%8B%E7%A2%8D%E9%80%89%E9%A1%B9" target="_blank" rel="external">《我的脑内恋碍选项》</a>。</li><li><a href="http://zh.moegirl.org/No_Game_No_Life_%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F" target="_blank" rel="external">《No Game No Life 游戏人生》</a>。</li><li><a href="http://zh.moegirl.org/%E6%88%91%E4%BB%AC%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%B2%B3%E5%90%88%E5%BA%84" target="_blank" rel="external">《我们大家的河合庄》</a>。抖 M 真可怕。</li><li><a href="http://zh.moegirl.org/%E4%B8%80%E5%91%A8%E7%9A%84%E6%9C%8B%E5%8F%8B" target="_blank" rel="external">《一周的朋友 》</a> / <a href="http://zh.wikipedia.org/zh/%E8%91%89%E6%9C%88%E6%8A%B9%E8%8C%B6" target="_blank" rel="external">叶月抹茶</a> / <a href="http://zh.wikipedia.org/wiki/%E9%9B%A8%E5%AE%AB%E5%A4%A9" target="_blank" rel="external">雨宫天</a> / <a href="http://music.163.com/#/song?id=28563201" target="_blank" rel="external">奏 (かなで)</a>。画风清新。</li><li><a href="http://zh.moegirl.org/%E5%88%80%E5%89%91%E7%A5%9E%E5%9F%9F" target="_blank" rel="external">《刀剑神域》</a> / <a href="http://zh.moegirl.org/%E4%BA%9A%E4%B8%9D%E5%A8%9C" target="_blank" rel="external">本子娜</a> / <a href="http://zh.moegirl.org/%E6%9C%9D%E7%94%B0%E8%AF%97%E4%B9%83" target="_blank" rel="external">朝田诗乃</a>。</li><li><a href="http://zh.moegirl.org/%E4%B8%9C%E4%BA%AC%E9%A3%9F%E5%B0%B8%E9%AC%BC" target="_blank" rel="external">《东京食尸鬼》</a>。</li><li><a href="http://zh.moegirl.org/%E6%9C%88%E5%88%8A%E5%B0%91%E5%A5%B3%E9%87%8E%E5%B4%8E%E5%90%9B" target="_blank" rel="external">《月刊少女野崎君》❤</a> / <a href="http://zh.moegirl.org/%E6%B4%BE%E6%8B%89%E6%96%AF%E5%A8%98" target="_blank" rel="external">派拉斯</a>。哈哈哈哈哈哈哈哈</li><li><a href="http://zh.moegirl.org/%E6%81%90%E6%80%96%E6%AE%8B%E5%93%8D" target="_blank" rel="external">《恐怖残响》</a>。好像想表达点啥，但是我没看懂啊！</li><li><a href="http://zh.wikipedia.org/zh/%E6%AD%A1%E8%BF%8E%E5%8A%A0%E5%85%A5NHK%EF%BC%81" target="_blank" rel="external">《欢迎加入NHK》❤</a> 。说是脱宅神作，但是看得郁闷，越看越宅。驾校、暑假、烈日。达哥推荐。</li><li><a href="http://zh.moegirl.org/%E6%AD%BB%E4%BA%A1%E7%AC%94%E8%AE%B0" target="_blank" rel="external">《死亡笔记》</a>。L 死了还看个屁啊。</li><li><a href="http://zh.moegirl.org/EVA" target="_blank" rel="external">《新世纪福音战士》❤</a> / <a href="http://music.163.com/#/song?id=657666" target="_blank" rel="external">残酷な天使のテーゼ</a> / <a href="http://zh.moegirl.org/%E8%91%9B%E5%9F%8E%E7%BE%8E%E9%87%8C" target="_blank" rel="external">葛城美里</a>。震撼。“我要你到这里来，就是要你画巨神兵的。”“可是巨神兵这种东西我怎么可能画的好啊！我才来你什么都不说就让我画原画吗！”“画不好就滚回去，我们不需要你这样的废物！”</li><li><a href="http://zh.moegirl.org/%E6%97%A5%E5%B8%B8" target="_blank" rel="external">《日常》❤</a>。我们所度过的每个平凡的日常，也许就是连续发生的奇迹。<a href="http://www.bilibili.com/video/av80686/" target="_blank" rel="external">MAD</a> 高质高量。这部动漫的制作者们是真正的热爱生活吧。</li><li><a href="http://zh.moegirl.org/%E7%94%B7%E5%AD%90%E9%AB%98%E4%B8%AD%E7%94%9F%E7%9A%84%E6%97%A5%E5%B8%B8" target="_blank" rel="external">《男子高中生的日常》❤</a> / <a href="http://zh.moegirl.org/%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A3%8E%E5%84%BF%E5%A5%BD%E5%96%A7%E5%9A%A3%E5%95%8A" target="_blank" rel="external">今天的风儿好喧嚣啊</a> / <a href="http://www.bilibili.com/video/av197039/" target="_blank" rel="external">隔壁超市薯片半价了，快去买</a>。很喜欢 <a href="http://music.163.com/#/song?id=401632" target="_blank" rel="external">ED おひさま</a>。</li><li><a href="http://zh.moegirl.org/%E7%AC%A8%E8%9B%8B%E6%B5%8B%E9%AA%8C%E5%8F%AC%E5%94%A4%E5%85%BD" target="_blank" rel="external">《笨蛋、测验、召唤兽》</a> / <a href="http://zh.moegirl.org/FFF" target="_blank" rel="external">FFF</a>。</li><li><a href="http://zh.moegirl.org/%E6%BD%9C%E8%A1%8C%E5%90%A7!%E5%A5%88%E4%BA%9A%E5%AD%90" target="_blank" rel="external">《潜行吧！奈亚子》</a> / <a href="http://music.163.com/#/song?id=26219464" target="_blank" rel="external">快来搞死那激萌的萝莉</a>。</li><li><a href="http://zh.moegirl.org/%E6%9C%BA%E5%B7%A7%E5%B0%91%E5%A5%B3%E4%B8%8D%E4%BC%9A%E5%8F%97%E4%BC%A4" target="_blank" rel="external">《机巧少女不会受伤》</a> / <a href="http://zh.moegirl.org/%E6%97%A5%E6%97%A5%E5%A4%9C%E5%A4%9C" target="_blank" rel="external">日日夜夜</a>。</li><li><a href="http://zh.wikipedia.org/zh-hant/%E5%85%83%E6%B0%A3%E5%9B%9D%E4%BB%94" target="_blank" rel="external">《元气囝仔》❤</a> / <a href="http://music.163.com/#/song?id=29357698" target="_blank" rel="external">らしさ</a>。治愈！<a href="http://music.163.com/#/mv?id=325006" target="_blank" rel="external">ED</a> 也不错。</li><li><a href="http://zh.moegirl.org/%E8%BF%B7%E8%8C%AB%E7%AE%A1%E5%AE%B6%E4%B8%8E%E6%87%A6%E5%BC%B1%E7%9A%84%E6%88%91" target="_blank" rel="external">《迷茫管家与懦弱的我》</a>。</li><li><a href="http://zh.moegirl.org/Another" target="_blank" rel="external">《Another》</a>。</li><li><a href="http://zh.moegirl.org/%E5%8F%AA%E6%9C%89%E7%A5%9E%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C" target="_blank" rel="external">《只有神知道的世界》</a> / <a href="http://zh.moegirl.org/%E5%B0%8F%E9%98%AA%E5%8D%83%E5%AF%BB" target="_blank" rel="external">小坂千寻</a>。一本正经地胡说八道。</li><li><a href="http://zh.moegirl.org/Angel_Beats!" target="_blank" rel="external">《Angel Beats!》</a> / <a href="http://music.163.com/#/song?id=28699611" target="_blank" rel="external">Brave Song</a>。知道的最早补的最晚。</li><li><a href="http://zh.moegirl.org/%E6%97%A0%E5%A4%B4%E9%AA%91%E5%A3%AB%E5%BC%82%E9%97%BB%E5%BD%95" target="_blank" rel="external">《无头骑士异闻录》</a>。<a href="http://zh.wikipedia.org/wiki/%E6%88%90%E7%94%B0%E8%89%AF%E6%82%9F" target="_blank" rel="external">成田良悟</a>。有趣的叙述方式，有趣的人。</li><li><a href="http://zh.wikipedia.org/wiki/Baccano!" target="_blank" rel="external">《永生之酒》❤</a>。同上。</li><li><a href="http://zh.moegirl.org/%E5%A2%83%E7%95%8C%E7%9A%84%E5%BD%BC%E6%96%B9" target="_blank" rel="external">《境界的彼方》</a> / <a href="http://zh.moegirl.org/%E6%A0%97%E5%B1%B1%E6%9C%AA%E6%9D%A5" target="_blank" rel="external">栗山未来</a>。</li><li><a href="http://zh.moegirl.org/%E4%B8%A7%E5%A5%B3" target="_blank" rel="external">《我不受欢迎，怎么想都是你们的错！》</a>。</li><li><a href="http://zh.moegirl.org/%E5%9C%A8%E7%9B%9B%E5%A4%8F%E7%AD%89%E5%BE%85" target="_blank" rel="external">《在盛夏等待》</a>。</li><li><a href="http://zh.moegirl.org/%E7%9C%9F%E5%AE%9E%E4%B9%8B%E6%B3%AA" target="_blank" rel="external">《真实之泪》❤</a> / <a href="http://baike.baidu.com/view/1665213.htm" target="_blank" rel="external">汤浅比吕美</a>。很糟糕，但是莫名吸引我<del>（韩剧的力量）</del>。养女穿着长裤美翻了！</li><li><a href="http://zh.wikipedia.org/zh/%E6%8B%9C%E8%A8%97%E4%BA%86%E2%98%86%E9%9B%99%E5%AD%90%E6%98%9F" target="_blank" rel="external">《拜托了☆双子星》</a>。起点<del>纯情后宫</del>小说动漫化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一旦接受了这种设定……其实还是蛮带感的……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>垃圾邮件的一种应对方法</title>
    <link href="http://stormluke.me/a-plan-for-spam/"/>
    <id>http://stormluke.me/a-plan-for-spam/</id>
    <published>2014-12-16T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.031Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="http://www.paulgraham.com/spam.html" target="_blank" rel="external">A Plan for Spam</a>。</p><p>（这篇文章描述了应用在 <a href="http://www.paulgraham.com/arc.html" target="_blank" rel="external">Arc 语言</a>的练习作品——防垃圾在线邮件阅读器中的垃圾过滤技术。改进后的算法在<a href="http://www.paulgraham.com/better.html" target="_blank" rel="external">《更好的贝叶斯过滤》</a>中描述。）</p><a id="more"></a><p>我认为阻止垃圾邮件是可能的，并且基于内容的过滤器是一种方法。垃圾邮件制作者的阿喀琉斯之踵正是他们的信息。他们可以绕过你设置的任何其他障碍。至少到目前为止他们已经做到了。但他们必须要递送他们的信息，不论这信息是什么。如果我们可以写一个能识别他们信息的软件，那他们就没有任何办法避开了。</p><hr><p>对接收者来说，垃圾邮件很容易识别。如果你雇某人来阅读你的邮件并挑出垃圾邮件，他可能不会遇到什么困难。那么在不用人工智能的情况下，我们需要做多少工作来自动化这个过程？</p><p>我认为我们可以用一个相当简单的算法来解决这个问题。实际上我发现你可以仅仅用单词的垃圾概率的一个贝叶斯组合就可以对现今（2002 年）的垃圾邮件过滤得不错。使用一个稍微调整过的（如下面描述）贝叶斯过滤器，我们现在在每 1000 封垃圾邮件中漏过滤少于 5 封，并且误判为 0。</p><p>人们开始写垃圾过滤器时常常并不会一开始就尝试统计的方法。许多黑客的直觉是试着写一个能识别垃圾邮件的独特属性的软件。你看着垃圾邮件并且想，这些无耻的家伙试着给我发送一些由“亲爱的朋友”开头或者主题完全由大写字母组成并且以八个感叹号结尾的邮件。我用一行代码就可以过滤掉这些东西。</p><p>然后你就这么做了，并且刚开始时它确实管用。一点简单的规则就能过滤掉不少垃圾邮件。在我的垃圾邮件语料里，仅仅用“click”这个单词就能过滤出 79.7%，而且只有 1.2% 的误报率。</p><p>在尝试统计方法之前我用了大概六个月来写识别独立的垃圾邮件特征的软件。我发现识别剩下的那一点垃圾邮件非常困难，当把过滤器调整得更严格之后会产生更多的误报。</p><p>误报是指清白的邮件被错误地判断为垃圾邮件。对大多数用户来说，错过正常邮件比收到垃圾邮件严重得多，一个过滤器产生误判就像痤疮药可能致死一样。</p><p>用户收到的垃圾邮件越多，他就越不容易注意到垃圾邮件箱里的无辜邮件。并且怪异的的是，你的过滤器越好，误判的危害就越大，因为当过滤器足够好时，用户会更加倾向于忽略所有被过滤的邮件。</p><p>我不知道为啥我这么长时间都避免去使用统计方法。我觉得是因为我太沉醉于亲自挑出垃圾邮件的特征，就像在跟垃圾邮件发送者玩着什么竞技游戏一样。（非黑客常常并不会注意到这点，但大多数的黑客是非常争强好胜的。）当我尝试统计分析时，我发现这比我原先的做法聪明得多。它发现了，其实是显而易见的，诸如“virtumundo”和“teens”这样的词是垃圾邮件的好指示器。但是它也发现了“per”、“FL”和“ff0000”也是好的特征。实际上“ff0000”（html 中代表红色）对垃圾邮件分辨程度和其他色情词语差不多。</p><p>下面是我如何做统计过滤的一个概述。我以一个垃圾邮件语料库和一个正常邮件语料库开始。当时每个里面都有大约 4000 封邮件。我扫描检查了每个语料库的整个文本，包括头部和嵌入的 html 和 javascript。我目前把字母数字组成的单词、连接号、撇号和美元符号作为词法元素，剩下的其他符号作为词法元素的分隔符。（这里可能有提高的空间。）我忽略了全部由数字组成的词法元素，并且我也忽略了 html 注释，甚至不把其看做分隔符。</p><p>我计算了每个词（目前忽略大小写）在每个语料库里出现的次数。在这个阶段我得到了两个大哈希表，每个语料库一个，从单词映射到它们出现的次数。</p><p>之后我创建了第三个哈希表，这次从每个单词映射到当一个邮件包含它们时为垃圾邮件的概率，计算方法如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">let</span> ((<span class="name">g</span> (<span class="name">*</span> <span class="number">2</span> (<span class="name">or</span> (<span class="name">gethash</span> word good) <span class="number">0</span>)))</div><div class="line">      (<span class="name">b</span> (<span class="name">or</span> (<span class="name">gethash</span> word bad) <span class="number">0</span>)))</div><div class="line">  (<span class="name">unless</span> ( (<span class="name">+</span> g b) <span class="number">5</span>)</div><div class="line">    (<span class="name">max</span> .<span class="number">01</span></div><div class="line">         (<span class="name">min</span> .<span class="number">99</span> (<span class="name">float</span> (<span class="name">/</span> (<span class="name">min</span> <span class="number">1</span> (<span class="name">/</span> b nbad))</div><div class="line">                            (<span class="name">+</span> (<span class="name">min</span> <span class="number">1</span> (<span class="name">/</span> g ngood))</div><div class="line">                               (<span class="name">min</span> <span class="number">1</span> (<span class="name">/</span> b nbad)))))))))</div></pre></td></tr></table></figure><p>其中 <code>word</code> 是我们正计算的单词的概率，<code>good</code> 和 <code>bad</code> 是我在第一步中创建的哈希表，<code>ngood</code> 和 <code>nbad</code> 是正常邮件和垃圾邮件对应的个数。</p><p>我用代码来解释是为了展示一些重要的细节。我想轻微地让概率偏向于避免误判，通过试错我发现把 <code>good</code> 中的计数翻倍是个好方法。这有助于区分偶尔在正常邮件中出现而几乎从不在垃圾邮件中出现的单词。我只考虑出现总数超过 5 次的单词（实际上因为翻倍，在正常邮件中出现 3 次就够了）。然后是应该给只在一个语料库中出现的单词什么概率的问题。同样通过试错我选择了 0.01 和 0.99。此处应该还有很多的调整空间，不过随着语料库增长这种调整会自动发生。</p><p>特别善于观察的会发现我在把每个语料库当做一个长文本流来计算单词出现次数时，我使用每个语料库的邮件个数，而不是它们的总和，来作为计算垃圾邮件概率的分母。这轻微地偏向于减少误判。</p><p>当新的邮件到达时，它会被扫描分成单词，然后取其中最有趣的 15 个单词——这里有趣度由它们的垃圾邮件概率和原始 0.5 的差距衡量——来计算这个邮件是垃圾邮件的概率。如果 <code>probs</code> 是这 15 个单词概率的一个列表，你可以这样计算<a href="http://www.paulgraham.com/naivebayes.html" target="_blank" rel="external">组合</a>概率：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">let</span> ((<span class="name">prod</span> (<span class="name">apply</span> #'* probs)))</div><div class="line">  (<span class="name">/</span> prod (<span class="name">+</span> prod (<span class="name">apply</span> #'* (<span class="name">mapcar</span> #'(lambda (x)</div><div class="line">                                         (- <span class="number">1</span> x))</div><div class="line">                                     probs)))))</div></pre></td></tr></table></figure><p>实际应用中会有一个问题是如何给一个从未见过的单词赋以概率，比如一个在单词概率哈希表中没出现过的单词。我发现，依旧通过试错，0.4 是一个不错的值。如果你从未见过一个单词，那它很可能是无辜的；垃圾邮件的单词一般很相似。</p><p>在结尾的附录中有这个算法应用于实际邮件的例子。</p><p>我把此算法给出的概率大于 0.9 的邮件当做垃圾邮件。不过在实践中这个阈值的具体位置似乎影响不大，因为最终没几个概率在范围中间。</p><hr><p>统计方法的一个重要的优势是你不用再去阅读那么多垃圾邮件了。在过去的 6 个月里，我逐字阅读了上千封垃圾邮件，这确实让人恶心。Norbert Wiener 说过如果你和奴隶竞争你就会变成一个奴隶，和垃圾邮件发送者竞争也是如此。为了识别出独立的垃圾邮件特点你必须设法理解垃圾邮件发送者的想法，但坦率地说我想在垃圾邮件发送者的想法上花的时间越少越好。</p><p>但是贝叶斯方法的真正优势，显而易见的，是你知道你在测量什么。如 SpamAssassin 这种特点识别过滤器赋予邮件一个垃圾“分数”。贝叶斯方法则赋予一个实际的概率。“分数”的问题在于没人知道它的含义。用户不知道它的含义，更糟的是，过滤器开发者也不知道。一个包含单词“sex”的邮件应该得到多少<em>分</em>？一个概率可能是错误的，但它的含义或者如何结合证据来计算却没有多大歧义。基于我的语料库，“sex”指出包含它的邮件有 0.97 的概率为垃圾邮件，同时“sexy”有 0.99 的概率。贝叶斯法则，同样无歧义，指出同时包含这两个单词的邮件，在没有其他证据的情况下（不太可能），有 99.97% 的可能是垃圾邮件。</p><p>理想中，每个用户的概率应该独立计算。我有许多包含“Lisp”这个单词的正常邮件，并且没有一封垃圾邮件包含这个。所以像这样的单词确实是一个给我发送邮件的密码。在我之前的垃圾邮件过滤软件中，用户可以建立一个这样的单词列表，如果有邮件包含它们则就会自动通过过滤器。在我的列表中我放入了如“Lisp”这样的单词和我的邮编，这样（可能有点像垃圾邮件的）在线订单的收据就能通过。我曾认为我这样很聪明，但我发现贝叶斯过滤器为我做了同样的事，此外还发现了更多的我想不到的单词。</p><p>我之前说的我们的过滤器在 1000 封邮件中漏过滤少于 5 封并且没有误判，这是指在我的语料库上过滤我的邮件。但这些数字并没有误导，因为这是我所支持的方法：根据各个用户的正常邮件和垃圾邮件的语料库来过滤它们自己的邮件。本质上，每个用户应该有两个删除按钮，普通的删除和作为垃圾邮件的删除。每个被作为垃圾邮件删除的进入垃圾邮件语料库，而所有其他的进入正常邮件语料库。</p><p>你可以让用户以一个种子过滤器开始，但最终每个用户都会拥有自己的基于他实际收到的邮件的单词概率。这（a）让过滤器更有效，（b）让每个用户决定自己关于垃圾邮件的精确定义，并且（c）可能最好的是让垃圾邮件发送者很难调整邮件来通过过滤器。如果很多的过滤器智慧是在个人独立的数据库中，他们仅仅调整垃圾邮件来通过种子过滤器并不会保证他们能够通过独立用户的多样化的并经过更多训练的过滤器。</p><p>基于内容的垃圾邮件过滤器通常会搭配一个白名单，这个名单包含可以不过滤而直接通过的发送者。一种建立这种白名单的方法是维护一个用户曾发送过邮件的目标地址。如果一个邮件阅读者有一个作为垃圾删除按钮，那你可以把用户以普通删除的每封邮件的地址添加到其中。</p><p>我是一个白名单的支持者，但是作为节约计算的一种方法而不是提升过滤能力。我曾经认为白名单能让过滤更容易，因为你只用过滤那些来自不认识的人的邮件，并且第一次给你发邮件的人被按惯例地限制为他们能对你说的话。某些你已经认识的人可能会给你发关于性的邮件，但第一次给你发邮件的人一般不会这么做。问题是，人们可以有多于一个的邮箱地址，所以一个新的发件地址并不能保证发送者是第一次给你写信。一个老朋友突然用一个新的邮件地址给你写信并不常见（特别是如果他是一个黑客的话），你不能承担因严格过滤未知邮件地址而带来的误报率。</p><p>从某种意义上说，我的过滤器确实包含了一种白名单（和黑名单），因为它们基于整个信息，包括头部。所以它们“知道”信任的发送者的邮件地址，甚至是发送给我的邮件所通过的路由。它们也知道有关垃圾邮件的这些信息，包括服务器地址、客户端版本和协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自：&lt;a href=&quot;http://www.paulgraham.com/spam.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Plan for Spam&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;（这篇文章描述了应用在 &lt;a href=&quot;http://www.paulgraham.com/arc.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Arc 语言&lt;/a&gt;的练习作品——防垃圾在线邮件阅读器中的垃圾过滤技术。改进后的算法在&lt;a href=&quot;http://www.paulgraham.com/better.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《更好的贝叶斯过滤》&lt;/a&gt;中描述。）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应式编程笔记 06</title>
    <link href="http://stormluke.me/reactive-programming-note-06/"/>
    <id>http://stormluke.me/reactive-programming-note-06/</id>
    <published>2014-06-19T16:00:00.000Z</published>
    <updated>2018-04-21T06:53:32.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单子和副作用（Effects）"><a href="#单子和副作用（Effects）" class="headerlink" title="单子和副作用（Effects）"></a>单子和副作用（Effects）</h3><p>编程中四种基本的副作用为：</p><table><thead><tr><th>分类</th><th>一个</th><th>多个</th></tr></thead><tbody><tr><td>同步</td><td><code>T / Try[T]</code></td><td><code>Iterable[T]</code></td></tr><tr><td>异步</td><td><code>Future[T]</code></td><td><code>Observable[T]</code></td></tr></tbody></table><a id="more"></a><h4 id="异常作为副作用（Exception-as-an-Effect）"><a href="#异常作为副作用（Exception-as-an-Effect）" class="headerlink" title="异常作为副作用（Exception as an Effect）"></a>异常作为副作用（Exception as an Effect）</h4><p>以一个游戏为例，在这个游戏中玩家收集金币然后买东西：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Adventure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collectCoins</span></span>(): <span class="type">List</span>[<span class="type">Coin</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyTreasure</span></span>(coins: <span class="type">List</span>[<span class="type">Coin</span>]): <span class="type">Treasure</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>收集金币和买东西的过程中都可能产生异常，比如被怪物吃掉或者钱不够：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectCoins</span></span>(): <span class="type">List</span>[<span class="type">Coin</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (eatenByMonster(<span class="keyword">this</span>))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">GameOverException</span>(<span class="string">"Ooops"</span>)</div><div class="line">  <span class="type">List</span>(<span class="type">Gold</span>, <span class="type">Gold</span>, <span class="type">Silver</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buyTreasure</span></span>(coins: <span class="type">List</span>[<span class="type">Coin</span>]): <span class="type">Treasure</span> = &#123;</div><div class="line">  <span class="keyword">if</span> (coins.sumBy(_.value) </div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">GameOverException</span>(<span class="string">"Nice try!"</span>)</div><div class="line">  <span class="type">Diamond</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>游戏执行的过程中可能因为一个异常没有被处理而不能继续：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> adventure = <span class="type">Adventure</span>()</div><div class="line"><span class="keyword">val</span> coins = adventure.collectCoins()</div><div class="line"><span class="comment">// 只有无异常才会继续执行</span></div><div class="line"><span class="keyword">val</span> treasure = adventure.buyTreasure(coins)</div><div class="line"><span class="comment">// 只有无异常才会继续执行</span></div></pre></td></tr></table></figure><p>通过引入 <code>Try</code> 这个类可以让异常由隐式的变为显式的（materialize），从而更加好处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Success</span>[<span class="type">T</span>](<span class="params">elem: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Failure</span>(<span class="params">t: <span class="type">Throwable</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">trait</span> <span class="title">Adventure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collectCoins</span></span>(): <span class="type">Try</span>[<span class="type">List</span>[<span class="type">Coin</span>]]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyTreasure</span></span>(coins: <span class="type">List</span>[<span class="type">Coin</span>]): <span class="type">Try</span>[<span class="type">Treasure</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> adventure = <span class="type">Adventure</span>()</div><div class="line"><span class="keyword">val</span> coins: <span class="type">Try</span>[<span class="type">List</span>[<span class="type">Coin</span>]] = adventure.collectCoins()</div><div class="line"><span class="keyword">val</span> treasure: <span class="type">Try</span>[<span class="type">Treasure</span>] = coins <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(cs) =&gt; adventure.buyTreasure(cs)</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实 <code>Try</code> 是单子，被设计用来处理异常，其上定义好了许多函数式编程的基础方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">U</span> <span class="type">Try</span>[<span class="type">T</span>]]: <span class="type">Try</span>[<span class="type">U</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">S</span>): <span class="type">Try</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span>=&gt;<span class="type">Boolean</span>): <span class="type">Try</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverWith</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>, <span class="type">Try</span>[<span class="type">T</span>]]): <span class="type">Try</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure><p>因此上面的程序也可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> treasure: <span class="type">Try</span>[<span class="type">Treasure</span>] = adventure.collectCoins().flatMap(coins =&gt; &#123;</div><div class="line">  adventure.buyTreasure(coins)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果用 <code>for</code> 表达式就更简洁了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> treasure: <span class="type">Try</span>[<span class="type">Treasure</span>] = <span class="keyword">for</span> &#123;</div><div class="line">  coins </div><div class="line">  treasure </div><div class="line">&#125; <span class="keyword">yield</span> treasure</div></pre></td></tr></table></figure><p><code>Try</code> 是单子，它的 <code>map</code> 和 <code>apply</code> 方法大概实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">S</span>): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(value) =&gt; <span class="type">Try</span>(f(value))</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Try</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](r: =&gt;<span class="type">T</span>): <span class="type">Try</span>[<span class="type">T</span>] = &#123;</div><div class="line">    <span class="keyword">try</span> &#123; <span class="type">Success</span>(r) &#125;</div><div class="line">    <span class="keyword">catch</span> &#123; <span class="keyword">case</span> t =&gt; <span class="type">Failure</span>(t) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>练习：下面哪个函数是正确的 <code>Try</code> 的 <code>flatMap</code> 实现？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Success</span>(values) =&gt; f(value)</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// b</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Success</span>(value) =&gt; <span class="type">Try</span>(f(value))</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// c</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Success</span>(value) =&gt;</div><div class="line">  <span class="keyword">try</span> &#123; f(value) &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> t =&gt; <span class="type">Failure</span>(t) &#125; <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>答案是 c。a 中调用 <code>f</code> 时没有处理异常，b 中返回值类型为 <code>Try[Try[T]]</code>。</p><h4 id="延迟作为副作用（Latency-as-an-Effect）"><a href="#延迟作为副作用（Latency-as-an-Effect）" class="headerlink" title="延迟作为副作用（Latency as an Effect）"></a>延迟作为副作用（Latency as an Effect）</h4><p>以套接字为例，从内存读取和通过网络发送数据都会产生延迟：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Socket</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">readFromMemory</span></span>(): <span class="type">Array</span>[<span class="type">Byte</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendToEurope</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Array</span>[<span class="type">Byte</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> packet = socket.readFromMemory()</div><div class="line"><span class="comment">// 阻塞 50000 ns，不产生异常时才会继续执行</span></div><div class="line"><span class="keyword">val</span> confirmation = socket.sendToEurope(packet)</div><div class="line"><span class="comment">// 阻塞 150000000 ns，不产生异常时才会继续执行</span></div></pre></td></tr></table></figure><p><code>Future</code> 这个单子用来处理延迟和异常：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.concurrent._</div><div class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(callback: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Unit</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Unit</span></div><div class="line">  <span class="comment">// alternative designs</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(success: <span class="type">T</span> =&gt; <span class="type">Unit</span>, failed: <span class="type">Throwable</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(callback: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// alternative designs</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observer</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onNext</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onError</span></span>(error: <span class="type">Throwable</span>): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>implicit</code> 表示隐式参数。<code>Future</code> 一般在另外的线程中运行，因此回调函数 <code>onComplete</code> 会提供一个运行环境参数 <code>executor</code> 来指示运行时所使用的线程环境。</p><p><code>Future</code> 在使用形式上可能会遇到些问题，比如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> packet: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.readFromMemory()</div><div class="line"><span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = packet onComplete &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(p) =&gt; socket.sendToEurope(p)</div><div class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个程序是错的，<code>confirmation</code> 的类型并不是 <code>Future[Array[Byte]]</code>。但如果这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">packet onComplete &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(p) =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.sendToEurope(p)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当延迟任务变多时程序结构会变得很混乱。</p><p>暂时先不管 <code>Future</code> 的使用形式问题，来看看如何创建一个 <code>Future</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(body: =&gt;<span class="type">T</span>)(<span class="keyword">implicit</span> context: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>练习：假设有以下代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</div><div class="line"><span class="keyword">import</span> akka.serializer._</div><div class="line"><span class="keyword">val</span> memory = <span class="type">Queue</span>[<span class="type">EMailMessage</span>](</div><div class="line">  <span class="type">EMailMessage</span>(from = <span class="string">"Erik"</span>, to = <span class="string">"Roland"</span>),</div><div class="line">  <span class="type">EMailMessage</span>(from = <span class="string">"Martin"</span>, to = <span class="string">"Erik"</span>),</div><div class="line">  <span class="type">EMailMessage</span>(from = <span class="string">"Roland"</span>, to = <span class="string">"Martin"</span>))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readFromMemory</span></span>(): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = <span class="type">Future</span> &#123;</div><div class="line">  <span class="keyword">val</span> email = queue.dequeue()</div><div class="line">  <span class="keyword">val</span> serializer = serialization.findSerializerFor(email)</div><div class="line">  serializer.toBinary(email)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> packet: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.readFromMemory()</div><div class="line">packet onSuccess &#123;</div><div class="line">  <span class="keyword">case</span> bs =&gt; socket.sendToEurope(p)</div><div class="line">&#125;</div><div class="line">packet onSuccess &#123;</div><div class="line">  <span class="keyword">case</span> bs =&gt; socket.sendToEurope(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当其执行完时 <code>email</code> 队列中还剩几封邮件？</p><p>答案是 2 封。尽管调用了两次 <code>onSuccess</code>，但是 <code>Future</code> 对象会缓存执行完的结果，两个 <code>onSuccess</code>都使用了同一封邮件。</p><h4 id="Future-上的组合子"><a href="#Future-上的组合子" class="headerlink" title="Future 上的组合子"></a>Future 上的组合子</h4><p>Scala 中的 <code>Future</code> 大概是这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Awaitable</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123;</div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">ready</span></span>(atMost: <span class="type">Duration</span>): <span class="type">Unit</span></div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>(atMost: <span class="type">Duration</span>): <span class="type">T</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Awaitable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">Future</span>[<span class="type">S</span>]): <span class="type">Future</span>[<span class="type">U</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>): <span class="type">Future</span>[<span class="type">S</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">recoverWith</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>, <span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt; <span class="type">T</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>假设有一个 <code>Http</code> 对象用来发送网络请求，现在想向欧洲和美国均发一封邮件，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Http</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(url: <span class="type">URL</span>, req: <span class="type">Request</span>): <span class="type">Future</span>[<span class="type">Response</span>] =</div><div class="line">    &#123;... runs the http request asynchronously ...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendTo</span></span>(url: <span class="type">URL</span>, packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] =</div><div class="line">  <span class="type">Http</span>(url, <span class="type">Request</span>(packet)).filter(response =&gt; response.isOK).map(response =&gt; response.toByteArray)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToAndBackup</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[(<span class="type">Array</span>[<span class="type">Byte</span>], <span class="type">Array</span>[<span class="type">Byte</span>])] = &#123;</div><div class="line">  <span class="keyword">val</span> europeConfirm = sendTo(mailServer.europe, packet)</div><div class="line">  <span class="keyword">val</span> usaConfirm = sendTo(mailServer.usa, packet)</div><div class="line">  europeConfirm.zip(usaConfirm)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这些方法依旧可能产生异常，程序并没有处理好这些潜在的错误。</p><p>实际上 <code>Future</code> 提供了两个用来从错误中恢复的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>,<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverWith</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>,<span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure><p><code>recover</code> 用一个同步的过程来恢复，而 <code>recoverWith</code> 则可以使用一个异步的过程。</p><p>现在将程序改为先向欧洲发送，若失败再向美国发送：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToSafe</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] =</div><div class="line">  sendTo(mailServer.europe, packet) recoverWith &#123;</div><div class="line">    <span class="keyword">case</span> europeError =&gt; sendTo(mailServer.usa, packet) recover &#123;</div><div class="line">      <span class="keyword">case</span> usaError =&gt; usaError.getMessage.toByteArray</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>虽然过程上正确，但当两个网络请求都失败时返回的异常是 <code>usaError</code>，并不是想要的 <code>europeError</code>。因此想增加一个 <code>fallbackTo</code> 函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToSafe</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] =</div><div class="line">  sendTo(mailServer.europe, packet) fallbackTo &#123;</div><div class="line">    sendTo(mailServer.usa, packet)</div><div class="line">  &#125; recover &#123;</div><div class="line">    <span class="keyword">case</span> europeError =&gt; europeError.getMessage.toByteArray</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fallbackTo</span></span>(that: =&gt; <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">this</span> recoverWith &#123;</div><div class="line">    <span class="keyword">case</span> _ =&gt; that recoverWith &#123; <span class="keyword">case</span> _ =&gt; <span class="keyword">this</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时程序就是正确并鲁棒的了，而且 <code>fallbackTo</code> 的加入让程序变得更加直观。</p><p>练习：现在想定义一个支持 <code>Future</code> 的 <code>Try</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Try</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">Try</span>[<span class="type">T</span>]] = &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它的 <code>apply</code> 方法该如何实现？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a</span></div><div class="line">f onComplete &#123; x =&gt; x &#125;</div><div class="line"></div><div class="line"><span class="comment">// b</span></div><div class="line">f recoverWith &#123; <span class="keyword">case</span> t =&gt; <span class="type">Future</span>.failed(t) &#125;</div><div class="line"></div><div class="line"><span class="comment">// c</span></div><div class="line">f.map(x =&gt; <span class="type">Try</span>(x))</div><div class="line"></div><div class="line"><span class="comment">// d</span></div><div class="line">f.map(s =&gt; <span class="type">Success</span>(s)) recover &#123; <span class="keyword">case</span> t =&gt; <span class="type">Failure</span>(t) &#125;</div></pre></td></tr></table></figure><p>答案为 d。a 中返回值为 <code>Unit</code>，b 和 c 都只考虑了 <code>Try</code> 的一个 case。</p><p>之前看到 <code>Future</code> 继承了 <code>Awaitable</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Awaitable</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123;</div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">ready</span></span>(atMost: <span class="type">Duration</span>): <span class="type">Unit</span></div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>(atMost: <span class="type">Duration</span>): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>应当注意这两个函数都是同步阻塞的，用来延迟执行或等待结果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> packet: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.readFromMemory()</div><div class="line"><span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = packet.flatMap(socket.sendToSafe(_))</div><div class="line"><span class="keyword">val</span> c = <span class="type">Await</span>.result(confirmation, <span class="number">2</span> seconds)</div><div class="line">println(c.toText)</div></pre></td></tr></table></figure><h4 id="Future-的应用"><a href="#Future-的应用" class="headerlink" title="Future 的应用"></a>Future 的应用</h4><p>因为 <code>Future</code> 是单子，所以可以使用 <code>for</code> 表达式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = <span class="keyword">for</span> &#123;</div><div class="line">  packet       </div><div class="line">  confirmation </div><div class="line">&#125; <span class="keyword">yield</span> confirmation</div></pre></td></tr></table></figure><p>现在想定义一个不断尝试执行 <code>Future</code> 最多 n 次直至成功的函数，一个可行的实现是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt; <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (noTimes == <span class="number">0</span>) &#123;</div><div class="line">    <span class="type">Future</span>.failed(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"Sorry"</span>))</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    block fallbackTo &#123;</div><div class="line">      retry(noTimes–<span class="number">1</span>) &#123; block &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是一个人曾说过：</p><blockquote><p>Recursion is the GOTO of Functional Programming - ErikMeijer</p></blockquote><p>这个人其实就是本课的老师……另外一个方法就是使用 <code>foldRight</code> 或 <code>foldLeft</code> 来实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foldLeft</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt;<span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> ns: <span class="type">Iterator</span>[<span class="type">Int</span>] = (<span class="number">1</span> to noTimes).iterator</div><div class="line">  <span class="keyword">val</span> attempts: <span class="type">Iterator</span>[<span class="type">Future</span>[<span class="type">T</span>]] = ns.map(_=&gt; ()=&gt;block)</div><div class="line">  <span class="keyword">val</span> failed = <span class="type">Future</span>.failed(<span class="keyword">new</span> <span class="type">Exception</span>)</div><div class="line">  attempts.foldLeft(failed)((a,block) =&gt; a recoverWith &#123; block() &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// foldRight</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt;<span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> ns: <span class="type">Iterator</span>[<span class="type">Int</span>] = (<span class="number">1</span> to noTimes).iterator</div><div class="line">  <span class="keyword">val</span> attempts: <span class="type">Iterator</span>[<span class="type">Future</span>[<span class="type">T</span>]] = ns.map(_=&gt; ()=&gt;block) <span class="keyword">val</span> failed = <span class="type">Future</span>.failed(<span class="keyword">new</span> <span class="type">Exception</span>)</div><div class="line">  attempts.foldRight(() =&gt; failed)</div><div class="line">  ((block, a) =&gt; () =&gt; &#123; block() fallbackTo &#123; a() &#125; &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在觉得显式的副作用并不方便，能不能将其变成隐式的呢？比如 <code>Future</code>，能否将 <code>T =&gt; Future[S]</code>变为 <code>T =&gt; S</code>？答案是可以的，Scala 提供了 <code>async { ... await{ ... } ... }</code> 这种语法结构：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.async.<span class="type">Async</span>._</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">async</span></span>[<span class="type">T</span>](body: =&gt;<span class="type">T</span>)(<span class="keyword">implicit</span> context: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">await</span></span>[<span class="type">T</span>](future: <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">T</span></div></pre></td></tr></table></figure><p><code>await</code> 会将异步非阻塞的代码变成同步阻塞的，外部的 <code>async</code> 依旧返回异步非阻塞的 <code>Future</code>。</p><p><code>await</code> 需要编译器的支持，因此需要注意以下几个方面：</p><ul><li><code>await</code> 外部的 <code>async</code> 必须是直接包裹的</li><li><code>await</code> 不能用在 by-name 参数中</li><li><code>await</code> 不能用在短路布尔表达式中</li><li><code>async</code> 不能包含 <code>return</code> 表达式</li><li><code>await</code> 不能包含在 <code>try-catch</code> 中</li></ul><p>使用了 <code>await</code> 后，代码会简洁很多：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt;<span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = async &#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> result: <span class="type">Try</span>[<span class="type">T</span>] = <span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"sorry man!"</span>))</div><div class="line">  <span class="keyword">while</span> (i </div><div class="line">    result = await &#123; <span class="type">Try</span>(block) &#125;</div><div class="line">    i += <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  result.get</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 <code>await</code> 重写 <code>filter</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">T</span>] = async &#123;</div><div class="line">  <span class="keyword">val</span> x = await &#123; <span class="keyword">this</span> &#125;</div><div class="line">  <span class="keyword">if</span> (!p(x)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>()</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    x</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>练习：如何用 <code>await</code> 实现 <code>flatMap</code>？答案如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">Future</span>[<span class="type">S</span>]): <span class="type">Future</span>[<span class="type">S</span>] =</div><div class="line">  async &#123; await &#123; f( await &#123; <span class="keyword">this</span> &#125; ) &#125; &#125;</div></pre></td></tr></table></figure><p>如果不用 <code>await</code>，可以使用 <code>Promise</code> 实现 <code>filter</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(pred: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">T</span>]()</div><div class="line">  <span class="keyword">this</span> onComplete &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt;</div><div class="line">      p.failure(e)</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</div><div class="line">      <span class="keyword">if</span> (!pred(x)) p.failure(<span class="keyword">new</span> <span class="type">NoSuchElementException</span>)</div><div class="line">      <span class="keyword">else</span> p.success(x)</div><div class="line">  &#125;</div><div class="line">  p.future</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code> 包含一个 <code>Future</code>，当调用 <code>Promise</code> 的 <code>complete</code> 方法时 <code>Promise</code> 会调用自身 <code>Future</code> 上的回调函数。<code>tryComplete</code> 和 <code>complete</code> 方法类似，只是当该 <code>Promise</code> 已经完成后 <code>tryComplete</code> 会返回 <code>false</code>。<code>success</code> 和 <code>failure</code> 是两个简化方法，用来表示成功执行或发生异常。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Promise</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">future</span></span>: <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">complete</span></span>(result: <span class="type">Try</span>[<span class="type">T</span>]): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tryComplete</span></span>(result: <span class="type">Try</span>[<span class="type">T</span>]): <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">success</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span> = <span class="keyword">this</span>.complete(<span class="type">Success</span>(value))</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">failure</span></span>(t: <span class="type">Throwable</span>): <span class="type">Unit</span> = <span class="keyword">this</span>.complete(<span class="type">Failure</span>(t))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之前的 <code>zip</code> 方法可以这样实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">S</span>, <span class="type">R</span>](that: <span class="type">Future</span>[<span class="type">S</span>], f: (<span class="type">T</span>, <span class="type">S</span>) =&gt; <span class="type">R</span>): <span class="type">Future</span>[<span class="type">R</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">R</span>]()</div><div class="line">  <span class="keyword">this</span> onComplete &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; p.failure(e)</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt; that onComplete &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; p.failure(e)</div><div class="line">      <span class="keyword">case</span> <span class="type">Success</span>(y) =&gt; p.success(f(x, y))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  p.future</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果用 <code>await</code> 来实现的话会特别简洁：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">S</span>, <span class="type">R</span>](p: <span class="type">Future</span>[<span class="type">S</span>], f: (<span class="type">T</span>, <span class="type">S</span>) =&gt; <span class="type">R</span>): <span class="type">Future</span>[<span class="type">R</span>] = async &#123;</div><div class="line">  f(await &#123; <span class="keyword">this</span> &#125;, await &#123; that &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在用 <code>await</code> 定义一个队列函数，它会依次执行队列中的 <code>Future</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence</span></span>[<span class="type">T</span>](fs: <span class="type">List</span>[<span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">List</span>[<span class="type">T</span>]] = async &#123;</div><div class="line">  <span class="keyword">var</span> _fs = fs</div><div class="line">  <span class="keyword">val</span> r = <span class="type">ListBuffer</span>[<span class="type">T</span>]()</div><div class="line">  <span class="keyword">while</span> (_fs != <span class="type">Nil</span>) &#123;</div><div class="line">    r += await &#123; _fs.head &#125;</div><div class="line">    _fs = _fs.tail</div><div class="line">  &#125;</div><div class="line">  f.result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果用 <code>Promise</code> 来定义的话是这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence</span></span>[<span class="type">T</span>](fs: <span class="type">List</span>[<span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">List</span>[<span class="type">T</span>]] = &#123;</div><div class="line">  <span class="keyword">val</span> successful = <span class="type">Promise</span>[<span class="type">List</span>[<span class="type">T</span>]]()</div><div class="line">  successful.success(<span class="type">Nil</span>)</div><div class="line">  fs.foldRight(successful.future) &#123;</div><div class="line">    (f, acc) =&gt; <span class="keyword">for</span> &#123; x <span class="keyword">yield</span> x :: xs</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单子和副作用（Effects）&quot;&gt;&lt;a href=&quot;#单子和副作用（Effects）&quot; class=&quot;headerlink&quot; title=&quot;单子和副作用（Effects）&quot;&gt;&lt;/a&gt;单子和副作用（Effects）&lt;/h3&gt;&lt;p&gt;编程中四种基本的副作用为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;一个&lt;/th&gt;
&lt;th&gt;多个&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T / Try[T]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Iterable[T]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Future[T]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Observable[T]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
