<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 响应式编程笔记 07 · Preferences</title><meta name="description" content="响应式编程笔记 07 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">响应式编程笔记 07</h1><div class="post-info">May 7, 2015</div><div class="post-content"><h3 id="Future-T-和-Try-T-是对偶（dual）"><a href="#Future-T-和-Try-T-是对偶（dual）" class="headerlink" title="Future[T] 和 Try[T] 是对偶（dual）"></a><code>Future[T]</code> 和 <code>Try[T]</code> 是<a href="http://en.wikipedia.org/wiki/Dual_%28category_theory%29" target="_blank" rel="external">对偶（dual）</a></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">OnComplete</span></span>[<span class="type">U</span>](func: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">U</span>)(<span class="keyword">implicit</span> ex: <span class="type">ExecutionContext</span>): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>对 <code>OnComplete</code> 方法的类型进行化简（<code>U</code> 化简为 <code>Unit</code>），得到</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>翻转这个类型，得到</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Unit</span> =&gt; (<span class="type">Unit</span> =&gt; <span class="type">Try</span>[<span class="type">T</span>])</div></pre></td></tr></table></figure>
<p>继续简化，得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; Try[T]) ≈ Try[T]</div></pre></td></tr></table></figure>
<p>可以看出，对方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span></span>(): <span class="type">Future</span>[<span class="type">T</span>] = &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>传递回调（<code>Try[T] =&gt; Unit</code>）得到 <code>Try[T]</code>，而方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span></span>(): <span class="type">Try</span>[<span class="type">T</span>] = &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>一直阻塞直到返回 <code>Try[T]</code>。</p>
<h3 id="同步数据流：Iterable-T"><a href="#同步数据流：Iterable-T" class="headerlink" title="同步数据流：Iterable[T]"></a>同步数据流：<code>Iterable[T]</code></h3><p>这是 Scala 所有集合类型的基 trait，它定义了一个迭代器方法来一个一个地遍历集合中的元素。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterable</span>[<span class="type">T</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(): <span class="type">Iterator</span>[<span class="type">T</span>] &#125;</div></pre></td></tr></table></figure>
<p>迭代器是用来遍历序列元素的数据结构。它有个 <code>hasNext</code> 方法来检测下一个元素是否存在，还有个 <code>next</code> 方法来返回下一个元素。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span>[<span class="type">T</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span>; <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span> &#125;</div></pre></td></tr></table></figure>
<p>画成图是这样：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx0gia2dkj20vu0ecdha.jpg" alt="Iterable"></p>
<p>操作 <code>Iterable[T]</code> 的高阶函数有这些：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">Iterable</span>[<span class="type">B</span>]): <span class="type">Iterable</span>[<span class="type">B</span>] <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">Iterable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeWhile</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Iterable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>(): <span class="type">List</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">B</span>](that: <span class="type">Iterable</span> [<span class="type">B</span>]): <span class="type">Iterable</span>[(<span class="type">A</span>, <span class="type">B</span>)]</div></pre></td></tr></table></figure>
<p>这是一个单子。</p>
<p>常常用弹子图（Marble Diagram）来描述这种类型。</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx0p5e16yj20t10ehach.jpg" alt="Marble Diagram"></p>
<p>如果将不同命令的执行时间放大到人类级别，将会是这样：</p>
<p><a href="http://norvig.com/21-days.html#answers" target="_blank" rel="external"><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx0y76ydrj20s90flq6y.jpg" alt="Timings on human scale"></a></p>
<p>这时用 <code>Iterator</code> 从磁盘中读取文件会让程序阻塞很长时间：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadLinesFromDisk</span></span>(path: <span class="type">String</span>): <span class="type">Iterator</span>[<span class="type">String</span>] = &#123;</div><div class="line">  <span class="type">Source</span>.fromFile(path).getLines()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> lines = <span class="type">ReadLinesFromDisk</span>(<span class="string">"\c:\tmp.txt"</span>)</div><div class="line"><span class="keyword">for</span> (line </div><div class="line">  ... <span class="type">DoWork</span>(line) ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 weeks per line.</span></div></pre></td></tr></table></figure>
<p>现在用之前的对偶化技巧将拉（pull）模型转化为推（push）模型。</p>
<p>第零步，化简。将之前的签名：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(): <span class="type">Iterator</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象出类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; <span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]])</div></pre></td></tr></table></figure>
<ul>
<li><code>() =&gt; ( ... )</code> 由 <code>iterator()</code> 而来，</li>
<li><code>() =&gt; Try[Option[T]]</code> 由 <code>next()</code> 而来，</li>
<li><code>Option</code> 表示了 <code>hasNext</code>，</li>
<li><code>Try</code> 显式化了错误。</li>
</ul>
<p>第一步，翻转。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; (() =&gt; <span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]])</div></pre></td></tr></table></figure>
<p>翻转为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>第二步，化简。将组合在一起的类型拆分为三个：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">( <span class="type">T</span> =&gt; <span class="type">Unit</span>,</div><div class="line">  <span class="type">Throwable</span> =&gt; <span class="type">Unit</span>,</div><div class="line">  () =&gt; <span class="type">Unit</span></div><div class="line">) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>第三步，复杂化。得出对应的签名：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Subscribe</span></span>(observer: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Subscription</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observer</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onNext</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onError</span></span>(error: <span class="type">Throwable</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onCompleted</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对比可发现 <code>Iterable[T]</code> 和 <code>Observable[T]</code> 是对偶。</p>
<h3 id="对比-Future-和-Observable"><a href="#对比-Future-和-Observable" class="headerlink" title="对比 Future 和 Observable"></a>对比 <code>Future</code> 和 <code>Observable</code></h3><p>首先看签名：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">Observable</span>[<span class="type">T</span>] = (<span class="type">Try</span>[<span class="type">Option</span>[<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div><div class="line"><span class="type">Future</span>[<span class="type">T</span>]     = (<span class="type">Try</span>[      [<span class="type">T</span>]] =&gt; <span class="type">Unit</span>) =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p><code>Observable[T]</code> 多了 <code>Option</code>，这使其可以处理多次数据。</p>
<p>并发方面有什么不同呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt; <span class="type">T</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">observeOn</span></span>(scheduler: <span class="type">Scheduler</span>): <span class="type">Observable</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Future</code> 只执行一次，仅需要当前线程相关的 <code>ExecutionContext</code>，而 <code>Observable</code> 执行多次，需要一个 <code>Scheduler</code> 来控制。</p>
<h3 id="Observable-基础"><a href="#Observable-基础" class="headerlink" title="Observable 基础"></a><code>Observable</code> 基础</h3><p>来看一个使用 <code>Observable</code> 的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> seconds)</div><div class="line"><span class="keyword">val</span> evens: <span class="type">Observable</span>[<span class="type">Long</span>] = ticks.filter(s=&gt;s%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line"><span class="keyword">val</span> bufs: <span class="type">Observable</span>[<span class="type">Seq</span>[<span class="type">Long</span>]] = ticks.buffer(<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> s = bufs.subscribe(b=&gt;printLn(b))</div><div class="line">readLine()</div><div class="line">s.unscubscribe()</div></pre></td></tr></table></figure>
<p>分步执行如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ticks: <span class="type">Observable</span>[<span class="type">Long</span>] = <span class="type">Observable</span>.interval(<span class="number">1</span> seconds)</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx1vfkdbzj20qo02kwer.jpg" alt="Observable-eg-01"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> evens: <span class="type">Observable</span>[<span class="type">Long</span>] = ticks.filter(s=&gt;s%<span class="number">2</span>==<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx1vrs8z6j20qi02kmxi.jpg" alt="Observable-eg-02"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bufs: <span class="type">Observable</span>[<span class="type">Seq</span>[<span class="type">Long</span>]] = ticks.buffer(<span class="number">2</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx1xgfogjj20qq02x3yx.jpg" alt="Observable-eg-03"></p>
<p>练习：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs = <span class="type">Observable</span>.range(<span class="number">1</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>的弹子图如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/6ad06ebbgw1epx205cuvoj20qq02maac.jpg" alt="range"></p>
<p>那么</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ys = xs.map(x =&gt; x + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>的弹子图是什么？</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx20fkytoj20zp0asac4.jpg" alt="options"></p>
<p>答案是 B。</p>
<h3 id="Observable-上的组合子"><a href="#Observable-上的组合子" class="headerlink" title="Observable 上的组合子"></a><code>Observable</code> 上的组合子</h3><p>操作 <code>Observable[T]</code> 的高阶函数有这些：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">Observable</span>[<span class="type">B</span>]): <span class="type">Observable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">Observable</span>[<span class="type">B</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeWhile</span></span>(p: <span class="type">A</span>=&gt;<span class="type">Boolean</span>): <span class="type">Observable</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>(): <span class="type">List</span>[<span class="type">A</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">B</span>](that: <span class="type">Observable</span>[<span class="type">B</span>]): <span class="type">Observable</span>[(<span class="type">A</span>, <span class="type">B</span>)]</div></pre></td></tr></table></figure>
<p>其中 <code>map</code> 的弹子图是：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx3yeqsnaj20th0ehdi5.jpg" alt="map"></p>
<p><code>flatMap</code> 定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(f: <span class="type">T</span>=&gt;<span class="type">Observable</span>[<span class="type">S</span>]): <span class="type">Observable</span>[<span class="type">S</span>] = &#123; map(f).flatten() &#125;</div></pre></td></tr></table></figure>
<p>其弹子图为：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx416dmvkj20zq0e6acj.jpg" alt="flatMap"></p>
<p>有两种扁平化叠套流的方法，一种是 <code>flatten</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Int</span>] = <span class="type">Observable</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> yss: <span class="type">Observable</span>[<span class="type">Observable</span>[<span class="type">Int</span>]] =</div><div class="line">   xs.map(x =&gt; <span class="type">Observable</span>.<span class="type">Interval</span>(x seconds).map(_=&gt;x).take(<span class="number">2</span>))</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Int</span>] = yss.flatten()</div></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx45oxj4rj20z80aigna.jpg" alt="flatten"></p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx478ezznj20t60htmzd.jpg" alt="merge"></p>
<p>另一种是 <code>concat</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs: <span class="type">Observable</span>[<span class="type">Int</span>] = <span class="type">Observable</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> yss: <span class="type">Observable</span>[<span class="type">Observable</span>[<span class="type">Int</span>]] =</div><div class="line">   xs.map(x =&gt; <span class="type">Observable</span>.<span class="type">Interval</span>(x seconds).map(_=&gt;x).take(<span class="number">2</span>))</div><div class="line"><span class="keyword">val</span> zs: <span class="type">Observable</span>[<span class="type">Int</span>] = yss.concat()</div></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx492aeysj20ys0ah0uk.jpg" alt="concat-eg"></p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx49b2cuuj20t20hpdib.jpg" alt="concat"></p>
<p>下面通过一个处理地震通知的例子来展示如何映射和过滤异步的数据流。定义基本的结构如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">usgs</span></span>(): <span class="type">Observable</span>[<span class="type">EarthQuake</span>] = &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EarthQuake</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">magnitude</span></span>: <span class="type">Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">location</span></span>: <span class="type">GeoCoordinate</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Magnitude</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(magnitude: <span class="type">Double</span>): <span class="type">Magnitude</span> = &#123; ... &#125;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Magnitude</span> </span>= <span class="type">Value</span></div><div class="line">  <span class="keyword">val</span> <span class="type">Micro</span>, <span class="type">Minor</span>, <span class="type">Light</span>, <span class="type">Moderate</span>, <span class="type">Strong</span>, <span class="type">Major</span>, <span class="type">Great</span> = <span class="type">Value</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用起来大概是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> quakes = usgs()</div><div class="line"><span class="keyword">val</span> major = quakes</div><div class="line">  .map(q=&gt;(q.<span class="type">Location</span>, <span class="type">Magnitude</span>(q.<span class="type">Magnitude</span>)))</div><div class="line">  .filter&#123; <span class="keyword">case</span> (loc,mag) =&gt; mag &gt;= <span class="type">Major</span> &#125;</div><div class="line">major.subscribe(&#123; <span class="keyword">case</span> (loc, mag) =&gt; &#123;</div><div class="line">  println($<span class="string">"Magnitude $&#123; mag &#125; quake at $&#123; loc &#125;"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>现在想通过网络将地震处的地理坐标转换为国家信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseGeocode</span></span>(c: <span class="type">GeoCoordinate</span>): <span class="type">Future</span>[<span class="type">Country</span>] = &#123; ... &#125;</div><div class="line"><span class="keyword">val</span> withCountry: <span class="type">Observable</span>[<span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]] =</div><div class="line">  usgs().map(quake =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> country: <span class="type">Future</span>[<span class="type">Country</span>] = reverseGeocode(q.<span class="type">Location</span>)</div><div class="line">    <span class="type">Observable</span>(country.map(country=&gt;(quake,country)))</div><div class="line">  &#125;)</div><div class="line"><span class="comment">// This</span></div><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.flatten()</div><div class="line"><span class="comment">// Or this?</span></div><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.concat()</div></pre></td></tr></table></figure>
<p>那么问题来了，该用 <code>flatten</code> 还是 <code>concat</code>？如果用 <code>flatten</code>：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4ru2yr7j20vu0fvjtc.jpg" alt="geo-flatten"></p>
<p>最终收到地震消息的顺序会因为反向解析的延迟而出现错乱，而如果用 <code>concat</code> 则没问题：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4trgmxqj210v0eyq54.jpg" alt="geo-concat"></p>
<p>看一个新函数 <code>groupBy</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](keySelector: <span class="type">T</span>=&gt;<span class="type">K</span>): <span class="type">Observable</span>[(<span class="type">K</span>,<span class="type">Observable</span>[<span class="type">T</span>])]</div></pre></td></tr></table></figure>
<p>它的弹子图为：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx4v4pqr0j20pp0f8dhn.jpg" alt="groupBy"></p>
<p>原序列元素根据形状分为了两组，最终产生了三个数据流。</p>
<p>现在想让收到的地震信息根据国家不同而分类，可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> merged: <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)] = withCountry.flatten()</div><div class="line"><span class="keyword">val</span> byCountry: <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]] =</div><div class="line">  merged.groupBy&#123; <span class="keyword">case</span> (q,c) =&gt; c &#125;</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx4ylfq96j20xx0a3gmt.jpg" alt="group-eg"></p>
<p>练习：</p>
<p>若想统计不同国家发生地震的平均次数，部分代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> byCountry: <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[(<span class="type">EarthQuake</span>, <span class="type">Country</span>)]]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runningAverage</span></span>(s : <span class="type">Observable</span>[<span class="type">Double</span>]): <span class="type">Observable</span>[<span class="type">Double</span>] = &#123;...&#125;</div><div class="line"><span class="keyword">val</span> runningAveragePerCountry : <span class="type">Observable</span>[(<span class="type">Country</span>, <span class="type">Observable</span>[<span class="type">Double</span>])]</div></pre></td></tr></table></figure>
<p>那么 <code>runningAveragePerCountry</code> 的实现应该是什么？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, quakes) =&gt; (country, runningAverage(quakes))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// b)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, quakes) =&gt; (country, runningAverage(quakes.map(_.<span class="type">Magnitude</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// c)</span></div><div class="line"><span class="keyword">val</span> runningAveragePerCountry = byCountry.map&#123;</div><div class="line">  <span class="keyword">case</span> (country, cqs) =&gt; (country, runningAverage(cqs.map(_._1.<span class="type">Magnitude</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据类型匹配的原则可以得出答案为 C。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>如何取消订阅呢？这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> quakes: <span class="type">Observable</span>[<span class="type">EarthQuake</span>] = ...</div><div class="line"><span class="keyword">val</span> s: <span class="type">Subscription</span> = quakes.<span class="type">Subscribe</span>(...)</div><div class="line">s.unsubscribe()</div></pre></td></tr></table></figure>
<p><code>Observable</code> 可分为两种，一种称为 Hot Observable，所有的订阅者共享同样的源：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx6vvjgxqj20ih0hwq4k.jpg" alt="hot observable"></p>
<p>另一种称为 Cold Observable，每个订阅者都有自己的私有源：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx6w6gawnj20ji0hxgni.jpg" alt="cold observable"></p>
<p>注意取消订阅不等于终止源，因为可能还存在其他订阅者。</p>
<p><code>Subscription</code> 的基础定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(unsubscribe: =&gt; <span class="type">Unit</span>):<span class="type">Subscription</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Subscription</code> 家族中包含这些成员：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BooleanSubscription</span> <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isUnsubscribed</span></span>: <span class="type">Boolean</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CompositeSubscription</span> <span class="keyword">extends</span> <span class="title">BooleanSubscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+=</span></span>(s: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">-=</span></span>(s: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MultipleAssignmentSubscription</span> <span class="keyword">extends</span> <span class="title">BooleanSubscription</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscription</span></span>: <span class="type">Subscription</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subscription_=</span></span>(that: <span class="type">Subscription</span>): <span class="keyword">this</span>.<span class="keyword">type</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的代码中 <code>subscription</code> 被调用了两次：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> subscription = <span class="type">Subscription</span> &#123;</div><div class="line">   println(<span class="string">"bye, bye, I’m out fishing"</span>)</div><div class="line">&#125;</div><div class="line">subscription.unsubscribe()</div><div class="line">subscription.unsubscribe()</div></pre></td></tr></table></figure>
<p>结果是只有第一次会输出字符串。就是说，<code>unsubscribe</code> 可以被调用多次，它必须是<a href="http://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="external">幂等（idempotent）</a>的。</p>
<p><code>BooleanSubscription</code> 有一个 <code>isUnsubscribed</code> 方法，它能指示此订阅是否已被取消：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> subscription = <span class="type">BooleanSubscription</span> &#123;</div><div class="line">   println(<span class="string">"bye, bye, I’m out fishing"</span>)</div><div class="line">&#125;</div><div class="line">println(subscription.isUnsubscribed)</div><div class="line">subscription.unsubscribe()</div><div class="line">println(subscription.isUnsubscribed)</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7ctkstbj204q0f2glw.jpg" alt="BooleanSubscription"></p>
<p><code>CompositeSubscription</code> 可以包含许多订阅，当其被取消时所包含的订阅也会被取消：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">BooleanSubscription</span> &#123; println(<span class="string">"A"</span>) &#125;</div><div class="line"><span class="keyword">val</span> b = <span class="type">Subscription</span> &#123; println(<span class="string">"B"</span>) &#125;</div><div class="line"><span class="keyword">val</span> composite = <span class="type">CompositeSubscription</span>(a,b)</div><div class="line">println(composite.isUnsubscribed)</div><div class="line">composite.unsubscribe()</div><div class="line">println(composite.isUnsubscribed)</div><div class="line">println(a.isUnsubscribed)</div><div class="line">composite += <span class="type">Subscription</span>&#123; println (<span class="string">"C"</span>) &#125;</div></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1epx7dcsud4j20dr0ipgna.jpg" alt="CompositeSubscription-subscribe"></p>
<p>当新加入订阅时，若 <code>CompositeSubscription</code> 未被取消则新订阅状态不变，若 <code>CompositeSubscription</code> 已被取消则新订阅会被立刻取消：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1epx7e96l9tj210h0h0aec.jpg" alt="CompositeSubscription-add"></p>
<p><code>MultiAssignment</code> 只能包含一个子订阅，且它自身包含了一个隐式的订阅：</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7hz7kt6j20zv0h5q7a.jpg" alt="MultiAssignment-subscribe"></p>
<p>新加入订阅时的行为和 <code>CompositeSubscription</code> 类似：</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7kqh7uaj20za0gigpe.jpg" alt="MultiAssignment-add"></p>
<p>当子订阅被取消时，<code>MultiAssignment</code> 的隐式订阅并不会被取消：</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1epx7llgmrrj20yt0f2wh8.jpg" alt="MultiAssignment-unscribe"></p>
<p>练习：</p>
<p>有如下代码段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">BooleanSubscription</span> &#123; println(<span class="string">"A"</span>) &#125;</div><div class="line"><span class="keyword">val</span> b = <span class="type">Subscription</span> &#123; println(<span class="string">"B"</span>) &#125;</div><div class="line"><span class="keyword">val</span> c = <span class="type">CompositeSubscription</span>(a,b)</div><div class="line"><span class="keyword">val</span> m = <span class="type">MultiAssignmentSubscription</span>()</div><div class="line">m.subscription = c</div><div class="line">c.unsubscribe</div></pre></td></tr></table></figure>
<p>下面哪个是正确的？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) b.isUnsubscribed == <span class="literal">true</span></div><div class="line">b) a.isUnsubscribed == <span class="literal">false</span></div><div class="line">c) m.isUnsubscribed == <span class="literal">true</span></div><div class="line">d) c.isUnsubscribed == <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>答案是 D。</p>
</div></article></div></main><footer><div class="paginator"><a href="/reactive-programming-note-08/" class="prev">PREV</a><a href="/2015-02-19/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>