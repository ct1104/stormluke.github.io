<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Pandas 数据类型概览 · Preferences</title><meta name="description" content="Pandas 数据类型概览 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Pandas 数据类型概览</h1><div class="post-info">Apr 10, 2018</div><div class="post-content"><blockquote>
<p>翻译自：<a href="http://pbpython.com/pandas_dtypes.html" target="_blank" rel="external">Overview of Pandas Data Types</a></p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/10/162adb65a757dd0a?w=700&amp;h=526&amp;f=png&amp;s=152073" alt="article header image"></p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在进行数据分析时，确保使用正确的数据类型非常重要，否则可能会得到意想不到的结果或错误。对 Pandas 而言，它会在很多情况下正确地作出数据类型推断，你可以继续进行分析工作，而无需深入思考该主题。</p>
<p>尽管 Pandas 工作得很好，但在数据分析过程中的某个时刻，你可能需要将数据从一种类型显式转换为另一种类型。本文将讨论 Pandas 的基本数据类型（即 <code>dtypes</code>），它们如何映射到 python 和 numpy 数据类型，以及从一种 Pandas 类型转换为另一种类型的几个方式。</p>
<h2 id="Pandas-的数据类型"><a href="#Pandas-的数据类型" class="headerlink" title="Pandas 的数据类型"></a>Pandas 的数据类型</h2><p>数据类型本质上是编程语言用来理解如何存储和操作数据的内部结构。例如，一个程序需要理解你可以将两个数字加起来，比如 5 + 10 得到 15。或者，如果是两个字符串，比如「cat」和「hat」，你可以将它们连接（加）起来得到「cathat」。</p>
<p>有关 Pandas 数据类型的一个可能令人困惑的地方是，Pandas、Python 和 numpy 的数据类型之间有一些重叠。下表总结了关键点：</p>
<p>Pandas <code>dtype</code> 映射：</p>
<table>
<thead>
<tr>
<th>Pandas dtype</th>
<th>Python 类型</th>
<th>NumPy 类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>str</td>
<td>string<em>, unicode</em></td>
<td>文本</td>
</tr>
<tr>
<td>int64</td>
<td>int</td>
<td>int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64</td>
<td>整数</td>
</tr>
<tr>
<td>float64</td>
<td>float</td>
<td>float_, float16, float32, float64</td>
<td>浮点数</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td>bool_</td>
<td>布尔值</td>
</tr>
<tr>
<td>datetime64</td>
<td>NA</td>
<td>NA</td>
<td>日期时间</td>
</tr>
<tr>
<td>timedelta[ns]</td>
<td>NA</td>
<td>NA</td>
<td>时间差</td>
</tr>
<tr>
<td>category</td>
<td>NA</td>
<td>NA</td>
<td>有限长度的文本值列表</td>
</tr>
</tbody>
</table>
<p>大多数情况下，你不必担心是否应该明确地将熊猫类型强制转换为对应的 NumPy 类型。一般来说使用 Pandas 的默认 <code>int64</code> 和 <code>float64</code> 就可以。我列出此表的唯一原因是，有时你可能会在代码行间或自己的分析过程中看到 Numpy 的类型。</p>
<p>对于本文，我将重点关注以下 Pandas 类型：</p>
<ul>
<li><code>object</code></li>
<li><code>int64</code></li>
<li><code>float64</code></li>
<li><code>datetime64</code></li>
<li><code>bool</code></li>
</ul>
<p>如果你有兴趣，我会再写一篇文章来专门介绍 <code>category</code> 和 <code>timedelta</code> 类型。不过本文中概述的基本方法也适用于这些类型。</p>
<h2 id="我们为什么关心类型？"><a href="#我们为什么关心类型？" class="headerlink" title="我们为什么关心类型？"></a>我们为什么关心类型？</h2><p>数据类型是在你遇到错误或意外结果之前并不会关心的事情之一。不过当你将新数据加载到 Pandas 进行进一步分析时，这也是你应该检查的第一件事情。</p>
<p>我将使用一个非常简单的 <a href="https://github.com/chris1610/pbpython/blob/master/data/sales_data_types.csv" target="_blank" rel="external">CSV文件</a> 来说明在 Pandas 中可能会遇到的一些常见的由数据类型导致的错误。另外，在 github 上也一个示例 <a href="https://github.com/chris1610/pbpython/blob/master/notebooks/Pandas_Data_Types.ipynb" target="_blank" rel="external">notbook</a>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">"sales_data_types.csv"</span>)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>Customer Number</th>
<th>Customer Name</th>
<th>2016</th>
<th>2017</th>
<th>Percent Growth</th>
<th>Jan Units</th>
<th>Month</th>
<th>Day</th>
<th>Year</th>
<th>Active</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10002.0</td>
<td>Quest Industries</td>
<td>$125,000.00</td>
<td>$162500.00</td>
<td>30.00%</td>
<td>500</td>
<td>1</td>
<td>10</td>
<td>2015</td>
<td>Y</td>
</tr>
<tr>
<td>1</td>
<td>552278.0</td>
<td>Smith Plumbing</td>
<td>$920,000.00</td>
<td>$101,2000.00</td>
<td>10.00%</td>
<td>700</td>
<td>6</td>
<td>15</td>
<td>2014</td>
<td>Y</td>
</tr>
<tr>
<td>2</td>
<td>23477.0</td>
<td><span class="caps">ACME</span> Industrial</td>
<td>$50,000.00</td>
<td>$62500.00</td>
<td>25.00%</td>
<td>125</td>
<td>3</td>
<td>29</td>
<td>2016</td>
<td>Y</td>
</tr>
<tr>
<td>3</td>
<td>24900.0</td>
<td>Brekke <span class="caps">LTD</span></td>
<td>$350,000.00</td>
<td>$490000.00</td>
<td>4.00%</td>
<td>75</td>
<td>10</td>
<td>27</td>
<td>2015</td>
<td>Y</td>
</tr>
<tr>
<td>4</td>
<td>651029.0</td>
<td>Harbor Co</td>
<td>$15,000.00</td>
<td>$12750.00</td>
<td>-15.00%</td>
<td>Closed</td>
<td>2</td>
<td>2</td>
<td>2014</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>乍一看，数据没什么问题，所以我们可以尝试做一些操作来分析数据。我们来试一下把 2016 和 2017 年的销售额加起来：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>] + df[<span class="string">'2017'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>      $<span class="number">125</span>,<span class="number">000.00</span>$<span class="number">162500.00</span></div><div class="line"><span class="number">1</span>    $<span class="number">920</span>,<span class="number">000.00</span>$<span class="number">101</span>,<span class="number">2000.00</span></div><div class="line"><span class="number">2</span>        $<span class="number">50</span>,<span class="number">000.00</span>$<span class="number">62500.00</span></div><div class="line"><span class="number">3</span>      $<span class="number">350</span>,<span class="number">000.00</span>$<span class="number">490000.00</span></div><div class="line"><span class="number">4</span>        $<span class="number">15</span>,<span class="number">000.00</span>$<span class="number">12750.00</span></div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<p>这看起来就不对了。我们希望将总计加在一起，但 Pandas 只是将这两个值连接在一起创建了一个长字符串。这个问题的一个线索是 <code>dtype：object</code>。<code>object</code> 在 Pandas 代表字符串，所以它执行的是字符串操作而不是数学操作。</p>
<p>如果我们想查看 dataframe 中的所有数据类型，使用 <code>df.dtypes</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number    float64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>                object</div><div class="line"><span class="number">2017</span>                object</div><div class="line">Percent Growth      object</div><div class="line">Jan Units           object</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active              object</div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<p>此外，<code>df.info（）</code> 函数可以显示更有用的信息。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.info()</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></div><div class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">5</span> entries, <span class="number">0</span> to <span class="number">4</span></div><div class="line">Data columns (total <span class="number">10</span> columns):</div><div class="line">Customer Number    <span class="number">5</span> non-null float64</div><div class="line">Customer Name      <span class="number">5</span> non-null object</div><div class="line"><span class="number">2016</span>               <span class="number">5</span> non-null object</div><div class="line"><span class="number">2017</span>               <span class="number">5</span> non-null object</div><div class="line">Percent Growth     <span class="number">5</span> non-null object</div><div class="line">Jan Units          <span class="number">5</span> non-null object</div><div class="line">Month              <span class="number">5</span> non-null int64</div><div class="line">Day                <span class="number">5</span> non-null int64</div><div class="line">Year               <span class="number">5</span> non-null int64</div><div class="line">Active             <span class="number">5</span> non-null object</div><div class="line">dtypes: float64(<span class="number">1</span>), int64(<span class="number">3</span>), object(<span class="number">6</span>)</div><div class="line">memory usage: <span class="number">480.0</span>+ bytes</div></pre></td></tr></table></figure>
<p>查看自动分配的数据类型后，有几个问题：</p>
<ul>
<li><code>Customer Number</code> 被归为 <code>float64</code> 但它应该是 <code>int64</code></li>
<li><code>2016</code> 和 <code>2017</code> 这两列被存储为 <code>object</code>，但应该是 <code>float64</code> 或 <code>int64</code> 这样的数值类型</li>
<li><code>Percent Growth</code> 和 <code>Jan Units</code> 也被存储为 <code>object</code> 而不是数值类型</li>
<li><code>Month</code>、<code>Day</code> 和 <code>Year</code> 这三列应该被转换为 <code>datetime64</code></li>
<li><code>Active</code> 列应该是布尔型</li>
</ul>
<p>在我们清洗这些数据类型之前，要对这些数据做更多的附加分析是非常困难的。</p>
<p>为了在 Pandas 中转换数据类型，有三个基本选项：</p>
<ul>
<li>使用 <code>astype()</code> 来强制转换到合适的 <code>dtype</code></li>
<li>创建一个自定义函数来转换数据</li>
<li>使用 Pandas 的函数，例如 <code>to_numeric()</code> 或 <code>to_datetime()</code></li>
</ul>
<h2 id="使用-astype-函数"><a href="#使用-astype-函数" class="headerlink" title="使用 astype() 函数"></a>使用 <code>astype()</code> 函数</h2><p>将 Pandas 数据列转换为不同类型的最简单方法就是用 <code>astype()</code>。例如，要将 <code>Customer Number</code> 转换为整数，我们可以这样调用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Customer Number'</span>].astype(<span class="string">'int'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>     <span class="number">10002</span></div><div class="line"><span class="number">1</span>    <span class="number">552278</span></div><div class="line"><span class="number">2</span>     <span class="number">23477</span></div><div class="line"><span class="number">3</span>     <span class="number">24900</span></div><div class="line"><span class="number">4</span>    <span class="number">651029</span></div><div class="line">Name: Customer Number, dtype: int64</div></pre></td></tr></table></figure>
<p>为了真正修改原始 dataframe 中的客户编号（Customer Number），记得把 <code>astype()</code> 函数的返回值重新赋值给 dataframe，因为 <code>astype()</code> 仅返回数据的副本而不原地修改。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">"Customer Number"</span>] = df[<span class="string">'Customer Number'</span>].astype(<span class="string">'int'</span>)</div><div class="line">df.dtypes</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number     int64</div><div class="line">Customer Name      object</div><div class="line"><span class="number">2016</span>               object</div><div class="line"><span class="number">2017</span>               object</div><div class="line">Percent Growth     object</div><div class="line">Jan Units          object</div><div class="line">Month               int64</div><div class="line">Day                 int64</div><div class="line">Year                int64</div><div class="line">Active             object</div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<p>以下是客户编号（Customer Number）为整数的新 dataframe：</p>
<table>
<thead>
<tr>
<th></th>
<th>Customer Number</th>
<th>Customer Name</th>
<th>2016</th>
<th>2017</th>
<th>Percent Growth</th>
<th>Jan Units</th>
<th>Month</th>
<th>Day</th>
<th>Year</th>
<th>Active</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10002</td>
<td>Quest Industries</td>
<td>$125,000.00</td>
<td>$162500.00</td>
<td>30.00%</td>
<td>500</td>
<td>1</td>
<td>10</td>
<td>2015</td>
<td>Y</td>
</tr>
<tr>
<td>1</td>
<td>552278</td>
<td>Smith Plumbing</td>
<td>$920,000.00</td>
<td>$101,2000.00</td>
<td>10.00%</td>
<td>700</td>
<td>6</td>
<td>15</td>
<td>2014</td>
<td>Y</td>
</tr>
<tr>
<td>2</td>
<td>23477</td>
<td>ACME Industrial</td>
<td>$50,000.00</td>
<td>$62500.00</td>
<td>25.00%</td>
<td>125</td>
<td>3</td>
<td>29</td>
<td>2016</td>
<td>Y</td>
</tr>
<tr>
<td>3</td>
<td>24900</td>
<td>Brekke LTD</td>
<td>$350,000.00</td>
<td>$490000.00</td>
<td>4.00%</td>
<td>75</td>
<td>10</td>
<td>27</td>
<td>2015</td>
<td>Y</td>
</tr>
<tr>
<td>4</td>
<td>651029</td>
<td>Harbor Co</td>
<td>$15,000.00</td>
<td>$12750.00</td>
<td>-15.00%</td>
<td>Closed</td>
<td>2</td>
<td>2</td>
<td>2014</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>这一切看起来不错，并且似乎很简单。让我们尝试对 <code>2016</code> 列做同样的事情并将其转换为浮点数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>].astype(<span class="string">'float'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ValueError       Traceback (most recent call last)</div><div class="line">&lt;ipython-input<span class="number">-45</span><span class="number">-999869</span>d577b0&gt; <span class="keyword">in</span> &lt;module&gt;()</div><div class="line">----&gt; 1 df['2016'].astype('float')</div><div class="line"></div><div class="line">[一些错误信息]</div><div class="line"></div><div class="line">ValueError: could <span class="keyword">not</span> convert string to float: <span class="string">'$15,000.00'</span></div></pre></td></tr></table></figure>
<p>以类似的方式，我们可以尝试将 <code>Jan Units</code> 列转换为整数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Jan Units'</span>].astype(<span class="string">'int'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ValueError         Traceback (most recent call last)</div><div class="line"></div><div class="line">&lt;ipython-input<span class="number">-44</span><span class="number">-31333711e4</span>a4&gt; <span class="keyword">in</span> &lt;module&gt;()</div><div class="line">----&gt; 1 df['Jan Units'].astype('int')</div><div class="line"></div><div class="line">[一些错误信息]</div><div class="line"></div><div class="line"></div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'Closed'</span></div></pre></td></tr></table></figure>
<p>这两个都返回 <code>ValueError</code> 异常，这意味着转换不起作用。</p>
<p>在这两个例子中，数据都包含不能被解释为数字的值。在销售额（2016）列中，数据包括货币符号以及每个值中的逗号。在 <code>Jan Units</code> 列中，最后一个值是 “Closed”，它不是一个数字；所以我们得到了异常。</p>
<p>到目前为止，<code>astype()</code> 作为工具看起来并不怎么好。我们在 <code>Active</code> 列中再试一次。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Active'</span>].astype(<span class="string">'bool'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="keyword">True</span></div><div class="line"><span class="number">1</span>    <span class="keyword">True</span></div><div class="line"><span class="number">2</span>    <span class="keyword">True</span></div><div class="line"><span class="number">3</span>    <span class="keyword">True</span></div><div class="line"><span class="number">4</span>    <span class="keyword">True</span></div><div class="line">Name: Active, dtype: bool</div></pre></td></tr></table></figure>
<p>第一眼，这看起来不错，但经过仔细检查，存在一个大问题。所有的值都被解释为 <code>True</code>，但最后一个客户有一个 <code>N</code> 的活动（Active）标志，所以这并不正确。</p>
<p>这一节的重点是 <code>astype()</code> 只有在下列情况下才能工作：</p>
<ul>
<li>数据是干净的，可以简单地解释为一个数字</li>
<li>你想要将一个数值转换为一个字符串对象</li>
</ul>
<p>如果数据具有非数字字符或它们间不同质（homogeneous），那么 <code>astype()</code> 并不是类型转换的好选择。你需要进行额外的变换才能完成正确的类型转换。</p>
<h2 id="自定义转换函数"><a href="#自定义转换函数" class="headerlink" title="自定义转换函数"></a>自定义转换函数</h2><p>由于该数据转换稍微复杂一些，因此我们可以构建一个自定义函数，将其应用于每个值并转换为适当的数据类型。</p>
<p>对于货币转换（这个特定的数据集），下面是一个我们可以使用的简单函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_currency</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Convert the string number value to a float</span></div><div class="line"><span class="string">     - Remove $</span></div><div class="line"><span class="string">     - Remove commas</span></div><div class="line"><span class="string">     - Convert to float type</span></div><div class="line"><span class="string">    """</span></div><div class="line">    new_val = val.replace(<span class="string">','</span>,<span class="string">''</span>).replace(<span class="string">'$'</span>, <span class="string">''</span>)</div><div class="line">    <span class="keyword">return</span> float(new_val)</div></pre></td></tr></table></figure>
<p>该代码使用python的字符串函数去掉 <code>$</code> 和 <code>,</code>，然后将该值转换为浮点数。在这个特定情况下，我们可以将值转换为整数，但我选择在这种情况下使用浮点数。</p>
<p>我也怀疑有人会建议我们对货币使用 <code>Decimal</code> 类型。这不是 Pandas 的本地数据类型，所以我故意坚持使用 float 方式。</p>
<p>另外值得注意的是，该函数将数字转换为 python 的 <code>float</code>，但 Pandas 内部将其转换为 <code>float64</code>。正如前面提到的，我建议你允许 Pandas 在确定合适的时候将其转换为特定的大小 <code>float</code> 或 <code>int</code>。你不需要尝试将其转换为更小或更大的字节大小，除非你真的知道为什么需要那样做。</p>
<p>现在，我们可以使用 Pandas 的 <code>apply</code> 函数将其应用于 2016 列中的所有值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>].apply(convert_currency)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">125000.0</span></div><div class="line"><span class="number">1</span>    <span class="number">920000.0</span></div><div class="line"><span class="number">2</span>     <span class="number">50000.0</span></div><div class="line"><span class="number">3</span>    <span class="number">350000.0</span></div><div class="line"><span class="number">4</span>     <span class="number">15000.0</span></div><div class="line">Name: <span class="number">2016</span>, dtype: float64</div></pre></td></tr></table></figure>
<p>成功！所有的值都显示为 <code>float64</code>，我们可以完成所需要的所有数学计算了。</p>
<p>我确信有经验的读者会问为什么我不使用 lambda 函数？在回答之前，先看下我们可以在一行中使用 <code>lambda</code> 函数完成的操作：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>].apply(<span class="keyword">lambda</span> x: x.replace(<span class="string">'$'</span>, <span class="string">''</span>).replace(<span class="string">','</span>, <span class="string">''</span>)).astype(<span class="string">'float'</span>)</div></pre></td></tr></table></figure>
<p>使用 <code>lambda</code>，我们可以将代码简化为一行，这是非常有效的方法。但我对这种方法有三个主要的意见：</p>
<ul>
<li>如果你只是在学习 Python / Pandas，或者如果将来会有 Python 新人来维护代码，我认为更长的函数的可读性更好。主要原因是它可以包含注释，也可以分解为若干步骤。lambda 函数对于新手来说更难以掌握。</li>
<li>其次，如果你打算在多个列上重复使用这个函数，复制长长的 lambda 函数并不方便。</li>
<li>最后，使用函数可以在使用 <code>read_csv()</code> 时轻松清洗数据。我将在文章结尾处介绍具体的使用方法。</li>
</ul>
<p>有些人也可能会争辩说，其他基于 lambda 的方法比自定义函数的性能有所提高。但为了教导新手，我认为函数方法更好。</p>
<p>以下是使用 <code>convert_currency</code> 函数转换两个销售（2016 / 2017）列中数据的完整示例。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'2016'</span>] = df[<span class="string">'2016'</span>].apply(convert_currency)</div><div class="line">df[<span class="string">'2017'</span>] = df[<span class="string">'2017'</span>].apply(convert_currency)</div><div class="line"></div><div class="line">df.dtypes</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number      int64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>               float64</div><div class="line"><span class="number">2017</span>               float64</div><div class="line">Percent Growth      object</div><div class="line">Jan Units           object</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active              object</div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<p>有关使用 <code>lambda</code> 和函数的另一个例子，我们可以看看修复 <code>Percent Growth</code> 列的过程。</p>
<p>使用 <code>lambda</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Percent Growth'</span>].apply(<span class="keyword">lambda</span> x: x.replace(<span class="string">'%'</span>, <span class="string">''</span>)).astype(<span class="string">'float'</span>) / <span class="number">100</span></div></pre></td></tr></table></figure>
<p>用自定义函数做同样的事情：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_percent</span><span class="params">(val)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Convert the percentage string to an actual floating point percent</span></div><div class="line"><span class="string">    - Remove %</span></div><div class="line"><span class="string">    - Divide by 100 to make decimal</span></div><div class="line"><span class="string">    """</span></div><div class="line">    new_val = val.replace(<span class="string">'%'</span>, <span class="string">''</span>)</div><div class="line">    <span class="keyword">return</span> float(new_val) / <span class="number">100</span></div><div class="line"></div><div class="line">df[<span class="string">'Percent Growth'</span>].apply(convert_percent)</div></pre></td></tr></table></figure>
<p>两者返回的值相同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">0.30</span></div><div class="line"><span class="number">1</span>    <span class="number">0.10</span></div><div class="line"><span class="number">2</span>    <span class="number">0.25</span></div><div class="line"><span class="number">3</span>    <span class="number">0.04</span></div><div class="line"><span class="number">4</span>   <span class="number">-0.15</span></div><div class="line">Name: Percent Growth, dtype: float64</div></pre></td></tr></table></figure>
<p>我将介绍的最后一个自定义函数是使用 <code>np.where()</code> 将活动（Active）列转换为布尔值。有很多方法来解决这个特定的问题。<code>np.where()</code> 方法对于很多类型的问题都很有用，所以我选择在这里介绍它。</p>
<p>其基本思想是使用 <code>np.where()</code> 函数将所有 <code>Y</code> 值转换为 <code>True</code>，其他所有值为 <code>False</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">"Active"</span>] = np.where(df[<span class="string">"Active"</span>] == <span class="string">"Y"</span>, <span class="keyword">True</span>, <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>其结果如下 dataframe：</p>
<table>
<thead>
<tr>
<th></th>
<th>Customer Number</th>
<th>Customer Name</th>
<th>2016</th>
<th>2017</th>
<th>Percent Growth</th>
<th>Jan Units</th>
<th>Month</th>
<th>Day</th>
<th>Year</th>
<th>Active</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10002.0</td>
<td>Quest Industries</td>
<td>$125,000.00</td>
<td>$162500.00</td>
<td>30.00%</td>
<td>500</td>
<td>1</td>
<td>10</td>
<td>2015</td>
<td>True</td>
</tr>
<tr>
<td>1</td>
<td>552278.0</td>
<td>Smith Plumbing</td>
<td>$920,000.00</td>
<td>$101,2000.00</td>
<td>10.00%</td>
<td>700</td>
<td>6</td>
<td>15</td>
<td>2014</td>
<td>True</td>
</tr>
<tr>
<td>2</td>
<td>23477.0</td>
<td>ACME Industrial</td>
<td>$50,000.00</td>
<td>$62500.00</td>
<td>25.00%</td>
<td>125</td>
<td>3</td>
<td>29</td>
<td>2016</td>
<td>True</td>
</tr>
<tr>
<td>3</td>
<td>24900.0</td>
<td>Brekke LTD</td>
<td>$350,000.00</td>
<td>$490000.00</td>
<td>4.00%</td>
<td>75</td>
<td>10</td>
<td>27</td>
<td>2015</td>
<td>True</td>
</tr>
<tr>
<td>4</td>
<td>651029.0</td>
<td>Harbor Co</td>
<td>$15,000.00</td>
<td>$12750.00</td>
<td>-15.00%</td>
<td>Closed</td>
<td>2</td>
<td>2</td>
<td>2014</td>
<td>False</td>
</tr>
</tbody>
</table>
<p>dtype 被正确地设置为了 <code>bool</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number    float64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>                object</div><div class="line"><span class="number">2017</span>                object</div><div class="line">Percent Growth      object</div><div class="line">Jan Units           object</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active                bool</div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<p>无论你选择使用 <code>lambda</code> 函数，还是创建一个更标准的 Python 函数，或者是使用其他方法（如 <code>np.where</code>），这些方法都非常灵活，并且可以根据你自己独特的数据需求进行定制。</p>
<h2 id="Pandas-辅助函数"><a href="#Pandas-辅助函数" class="headerlink" title="Pandas 辅助函数"></a>Pandas 辅助函数</h2><p>Pandas 在直白的 <code>astype()</code> 函数和复杂的自定义函数之间有一个中间地带。这些辅助函数对于某些数据类型转换非常有用。</p>
<p>如果你顺序读下来，你会注意到我没有对日期列或 <code>Jan Units</code> 列做任何事情。这两种列都可以使用 Pandas 的内置函数（如 <code>pd.to_numeric()</code> 和 <code>pd.to_datetime()</code>）进行转换。</p>
<p><code>Jan Units</code> 转换出现问题的原因是列中包含一个非数字值。如果我们尝试使用 <code>astype()</code>，我们会得到一个错误（如前所述）。<code>pd.to_numeric()</code> 函数可以更优雅地处理这些值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.to_numeric(df[<span class="string">'Jan Units'</span>], errors=<span class="string">'coerce'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">500.0</span></div><div class="line"><span class="number">1</span>    <span class="number">700.0</span></div><div class="line"><span class="number">2</span>    <span class="number">125.0</span></div><div class="line"><span class="number">3</span>     <span class="number">75.0</span></div><div class="line"><span class="number">4</span>      NaN</div><div class="line">Name: Jan Units, dtype: float64</div></pre></td></tr></table></figure>
<p>这里有几个值得注意的地方。首先，该函数轻松地处理了数据并创建了一个 <code>float64</code> 列。 此外，它会用 <code>NaN</code> 值替换无效的 <code>Closed</code> 值，因为我们配置了 <code>errors=coerce</code>。我们可以将 <code>Nan</code> 留在那里，也可以使用 <code>fillna（0）</code> 来用 0 填充：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.to_numeric(df[<span class="string">'Jan Units'</span>], errors=<span class="string">'coerce'</span>).fillna(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">500.0</span></div><div class="line"><span class="number">1</span>    <span class="number">700.0</span></div><div class="line"><span class="number">2</span>    <span class="number">125.0</span></div><div class="line"><span class="number">3</span>     <span class="number">75.0</span></div><div class="line"><span class="number">4</span>      <span class="number">0.0</span></div><div class="line">Name: Jan Units, dtype: float64</div></pre></td></tr></table></figure>
<p>我最终介绍的转换是将单独的月份、日期和年份列转换为到一个 <code>datetime</code> 类型的列。Pandas 的 <code>pd.to_datetime()</code> 函数 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html" target="_blank" rel="external">可定制性很好</a>，但默认情况下也十分明智。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.to_datetime(df[[<span class="string">'Month'</span>, <span class="string">'Day'</span>, <span class="string">'Year'</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>   <span class="number">2015</span><span class="number">-01</span><span class="number">-10</span></div><div class="line"><span class="number">1</span>   <span class="number">2014</span><span class="number">-06</span><span class="number">-15</span></div><div class="line"><span class="number">2</span>   <span class="number">2016</span><span class="number">-03</span><span class="number">-29</span></div><div class="line"><span class="number">3</span>   <span class="number">2015</span><span class="number">-10</span><span class="number">-27</span></div><div class="line"><span class="number">4</span>   <span class="number">2014</span><span class="number">-02</span><span class="number">-02</span></div><div class="line">dtype: datetime64[ns]</div></pre></td></tr></table></figure>
<p>在这种情况下，函数将这些列组合成适当 <code>datateime64</code> dtype 的新列。</p>
<p>我们需要确保将这些值赋值回 dataframe：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[&quot;Start_Date&quot;] = pd.to_datetime(df[[&apos;Month&apos;, &apos;Day&apos;, &apos;Year&apos;]])</div><div class="line">df[&quot;Jan Units&quot;] = pd.to_numeric(df[&apos;Jan Units&apos;], errors=&apos;coerce&apos;).fillna(0)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>Customer Number</th>
<th>Customer Name</th>
<th>2016</th>
<th>2017</th>
<th>Percent Growth</th>
<th>Jan Units</th>
<th>Month</th>
<th>Day</th>
<th>Year</th>
<th>Active</th>
<th>Start_Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10002</td>
<td>Quest Industries</td>
<td>125000.0</td>
<td>162500.0</td>
<td>0.30</td>
<td>500.0</td>
<td>1</td>
<td>10</td>
<td>2015</td>
<td>True</td>
<td>2015-01-10</td>
</tr>
<tr>
<td>1</td>
<td>552278</td>
<td>Smith Plumbing</td>
<td>920000.0</td>
<td>1012000.0</td>
<td>0.10</td>
<td>700.0</td>
<td>6</td>
<td>15</td>
<td>2014</td>
<td>True</td>
<td>2014-06-15</td>
</tr>
<tr>
<td>2</td>
<td>23477</td>
<td>ACME Industrial</td>
<td>50000.0</td>
<td>62500.0</td>
<td>0.25</td>
<td>125.0</td>
<td>3</td>
<td>29</td>
<td>2016</td>
<td>True</td>
<td>2016-03-29</td>
</tr>
<tr>
<td>3</td>
<td>24900</td>
<td>Brekke LTD</td>
<td>350000.0</td>
<td>490000.0</td>
<td>0.04</td>
<td>75.0</td>
<td>10</td>
<td>27</td>
<td>2015</td>
<td>True</td>
<td>2015-10-27</td>
</tr>
<tr>
<td>4</td>
<td>651029</td>
<td>Harbor Co</td>
<td>15000.0</td>
<td>12750.0</td>
<td>-0.15</td>
<td>NaN</td>
<td>2</td>
<td>2</td>
<td>2014</td>
<td>False</td>
<td>2014-02-02</td>
</tr>
</tbody>
</table>
<p>现在数据已正确转换为我们需要的所有类型：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number             int64</div><div class="line">Customer Name              object</div><div class="line"><span class="number">2016</span>                      float64</div><div class="line"><span class="number">2017</span>                      float64</div><div class="line">Percent Growth            float64</div><div class="line">Jan Units                 float64</div><div class="line">Month                       int64</div><div class="line">Day                         int64</div><div class="line">Year                        int64</div><div class="line">Active                       bool</div><div class="line">Start_Date         datetime64[ns]</div></pre></td></tr></table></figure>
<p>Dataframe 已准备好进行分析！</p>
<h2 id="把它们放在一起"><a href="#把它们放在一起" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h2><p>在数据采集过程中应该尽早地使用 <code>astype()</code> 和自定义转换函数。如果你有一个打算重复处理的数据文件，并且它总是以相同的格式存储，你可以定义在读取数据时需要应用的 <code>dtype</code> 和 <code>converters</code>。将 <code>dtype</code> 视为对数据执行 <code>astype()</code> 很有帮助。<code>converters</code> 参数允许你将函数应用到各种输入列，类似于上面介绍的方法。</p>
<p>需要注意的是，只能使用 <code>dtype</code> 或 <code>converter</code> 函数中的一种来应用于指定的列。如果你尝试将两者应用于同一列，则会跳过 <code>dtype</code>。</p>
<p>下面是一个简化的例子，它在数据读入 dataframe 时完成几乎所有的转换：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">df_2 = pd.read_csv(<span class="string">"sales_data_types.csv"</span>,</div><div class="line">                   dtype=&#123;<span class="string">'Customer Number'</span>: <span class="string">'int'</span>&#125;,</div><div class="line">                   converters=&#123;<span class="string">'2016'</span>: convert_currency,</div><div class="line">                               <span class="string">'2017'</span>: convert_currency,</div><div class="line">                               <span class="string">'Percent Growth'</span>: convert_percent,</div><div class="line">                               <span class="string">'Jan Units'</span>: <span class="keyword">lambda</span> x: pd.to_numeric(x, errors=<span class="string">'coerce'</span>),</div><div class="line">                               <span class="string">'Active'</span>: <span class="keyword">lambda</span> x: np.where(x == <span class="string">"Y"</span>, <span class="keyword">True</span>, <span class="keyword">False</span>)</div><div class="line">                              &#125;)</div><div class="line"></div><div class="line">df_2.dtypes</div></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Customer Number      int64</div><div class="line">Customer Name       object</div><div class="line"><span class="number">2016</span>               float64</div><div class="line"><span class="number">2017</span>               float64</div><div class="line">Percent Growth     float64</div><div class="line">Jan Units          float64</div><div class="line">Month                int64</div><div class="line">Day                  int64</div><div class="line">Year                 int64</div><div class="line">Active              object</div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<p>正如前面提到的，我选择了包含用于转换数据的 <code>lambda</code> 示例和函数示例。唯一无法被应用在这里的函数就是那个用来将 <code>Month</code>、<code>Day</code> 和 <code>Year</code> 三列转换到 <code>datetime</code> 列的函数。不过，这仍是一个强大的可以帮助改进数据处理流程的约定。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>探索新数据集的第一步是确保数据类型设置正确。大部分时间 Pandas 都会做出合理推论，但数据集中有很多细微差别，因此知道如何使用 Pandas 中的各种数据转换选项非常重要。如果你有任何其他建议，或者有兴趣探索 <code>category</code> 数据类型，请随时在下面发表评论。</p>
</div></article></div></main><footer><div class="paginator"><a href="/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance/" class="prev">PREV</a><a href="/open-sourcing-a-10x-reduction-in-apache-cassandra-tail-latency/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'pandas-dtypes/';
var disqus_title = 'Pandas 数据类型概览';
var disqus_url = 'http://stormluke.me/pandas-dtypes/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>