<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 响应式编程笔记 02 · Preferences</title><meta name="description" content="响应式编程笔记 02 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">响应式编程笔记 02</h1><div class="post-info">May 17, 2014</div><div class="post-content"><h3 id="回顾：Case-类"><a href="#回顾：Case-类" class="headerlink" title="回顾：Case 类"></a>回顾：Case 类</h3><p>Case 类是 Scala 处理复杂数据的理想方式。</p>
<p>比如表示 JSON 类型的数据，可以这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JSeq</span>(<span class="params">elems: <span class="type">List</span>[<span class="type">JSON</span>]</span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JObj</span>(<span class="params">bindings: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">JSON</span>]</span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JNum</span>(<span class="params">num: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JStr</span>(<span class="params">str: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JBool</span>(<span class="params">b: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">JNull</span> <span class="keyword">extends</span> <span class="title">JSON</span></span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>这是将 JSON 数据转换成字符串的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(json: <span class="type">JSON</span>): <span class="type">String</span> = json <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">JSeq</span>(elems) =&gt;</div><div class="line">    <span class="string">"["</span> + (elems map show mkString <span class="string">", "</span>) + <span class="string">"]"</span></div><div class="line">  <span class="keyword">case</span> <span class="type">JObj</span>(bindings) =&gt;</div><div class="line">    <span class="keyword">val</span> assocs = bindings map &#123;</div><div class="line">      <span class="keyword">case</span> (key, value) =&gt; <span class="string">"\""</span> + key + <span class="string">"\": "</span> + show(value)</div><div class="line">    &#125;</div><div class="line">    <span class="string">"&#123;"</span> + (assocs mkString <span class="string">", "</span>) + <span class="string">"&#125;"</span></div><div class="line">  <span class="keyword">case</span> <span class="type">JNum</span>(num) =&gt; num.toString</div><div class="line">  <span class="keyword">case</span> <span class="type">JStr</span>(str) =&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span></div><div class="line">  <span class="keyword">case</span> <span class="type">JBool</span>(b) =&gt; b.toString</div><div class="line">  <span class="keyword">case</span> <span class="type">JNull</span> =&gt; <span class="string">"null"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h3><p>问题：下面表达式的类型是什么？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">case</span> (key, value) =&gt; key + <span class="string">": "</span> + value &#125;</div></pre></td></tr></table></figure>
<p>当它单独出现时，它是没有类型的，需要给它规定一个期望的类型。</p>
<p>上面代码中 <code>map</code> 方法期望的类型是 <code>JBinding =&gt; String</code>，其中 <code>JBinding</code> 为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">JBinding</span> </span>= (<span class="type">String</span>, <span class="type">JSON</span>)</div></pre></td></tr></table></figure>
<p>在 Scala 中，所有实体类型都是某个类或 trait，函数也不例外。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">JBinding</span> =&gt; <span class="type">String</span></div></pre></td></tr></table></figure>
<p>其实是</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala.<span class="type">Function1</span>[<span class="type">JBinding</span>, <span class="type">String</span>]</div></pre></td></tr></table></figure>
<p>的缩写形式，<code>scala.Function1</code>是一个 trait，<code>JBinding</code> 和 <code>String</code> 则是它的类型参数。</p>
<h3 id="Function1-Trait"><a href="#Function1-Trait" class="headerlink" title="Function1 Trait"></a>Function1 Trait</h3><p>这是<code>trait Function1</code>的大概样子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">A</span>, +<span class="type">R</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">R</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的模式匹配块会被扩展为<code>Function1</code>的一个实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">JBinding</span>, <span class="type">String</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Binding</span>) = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> (key, value) =&gt; key + <span class="string">": "</span> + show(value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Function-的子类"><a href="#Function-的子类" class="headerlink" title="Function 的子类"></a>Function 的子类</h3><p>函数是 trait 的一个好处是可以用子类来扩展它。</p>
<p>比如 map 是从键到值的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Map</span>[<span class="type">Key</span>, <span class="type">Value</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">Key</span> =&gt; <span class="type">Value</span></span>)</span></div></pre></td></tr></table></figure>
<p>序列是从 <code>Int</code> 到值的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Seq</span>[<span class="type">Elem</span>] <span class="keyword">extends</span> <span class="title">Int</span> <span class="title">=&gt;</span> <span class="title">Elem</span></span></div></pre></td></tr></table></figure>
<p>这就是 <code>elems(i)</code> 可以这样写的原因。</p>
<h3 id="不完全函数-Partial-Function"><a href="#不完全函数-Partial-Function" class="headerlink" title="不完全函数 (Partial Function)"></a>不完全函数 (Partial Function)</h3><p>有如下定义的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> f: <span class="type">String</span> =&gt; <span class="type">String</span> = &#123; <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span> &#125;</div></pre></td></tr></table></figure>
<p>它的类型为 <code>String =&gt; String</code>，但是这个函数没有在整个域（所有字符串）上定义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(<span class="string">"pong"</span>) <span class="comment">// 会抛出 MatchError 异常</span></div></pre></td></tr></table></figure>
<p>有在运行一个函数之前就能测试它能接受哪些参数的方法吗？确实有：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> f: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span> &#125;</div><div class="line">f.isDefinedAt(<span class="string">"ping"</span>) <span class="comment">// true</span></div><div class="line">f.isDefinedAt(<span class="string">"pong"</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>不完全函数是这样定义的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PartialFunction</span>[-<span class="type">A</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">Function1</span>[-<span class="type">A</span>, +<span class="type">R</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">R</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">A</span>): <span class="type">Boolean</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果期望类型是 <code>PartialFunction</code>，Scala 编译器会将</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span> &#125;</div></pre></td></tr></table></figure>
<p>扩展为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="literal">true</span></div><div class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>这个函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> f: <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">String</span>] = &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">"one"</span></div><div class="line">  <span class="keyword">case</span> x :: rest =&gt;</div><div class="line">    rest <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">"two"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>g.isDefinedAt(List(1, 2, 3))</code> 的返回值是？</p>
<p>答案为 <code>true</code>。但应注意尽管测试为 <code>true</code>，但当以 <code>List(1, 2, 3)</code> 为参数调用 <code>f</code> 时会发生错误。也就是说 <code>isDefinedAt</code> 只保证最外层的模式匹配正确。</p>
<h3 id="回顾：集合"><a href="#回顾：集合" class="headerlink" title="回顾：集合"></a>回顾：集合</h3><p>Scala 包含丰富的集合类层次。所有集合类型共享一些通用方法。</p>
<p>核心方法：</p>
<ul>
<li><code>map</code></li>
<li><code>flatMap</code></li>
<li><code>filter</code></li>
</ul>
<p>另外还有：</p>
<ul>
<li><code>foldLeft</code></li>
<li><code>foldRight</code></li>
</ul>
<p>各方法在列表 (List) 上的理想化实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> x :: xs =&gt; f(x) :: xs.map(f)</div><div class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">List</span>[<span class="type">U</span>]): <span class="type">List</span>[<span class="type">U</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> x :: xs =&gt; f(x) ++ xs.flatMap(f)</div><div class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">T</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    x :: xs =&gt;</div><div class="line">      <span class="keyword">if</span> (p(x)) x :: xs.filter(p) <span class="keyword">else</span> xs.filter(p)</div><div class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实践中，这些方法的具体实现和类型并不和上面相同，这样做是想:</p>
<ul>
<li>让它们可以应用在不同的集合上面，不仅是列表</li>
<li>让它们在列表上是尾递归的</li>
</ul>
<h3 id="For-表达式"><a href="#For-表达式" class="headerlink" title="For 表达式"></a>For 表达式</h3><p>For 表达式可以简化 <code>map</code>、<code>flatMap</code>、<code>filter</code> 的组合。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> until n) flatMap (i =&gt;</div><div class="line">  (<span class="number">1</span> until i) filter (j =&gt; isPrime(i + j)) map</div><div class="line">    (j =&gt; (i, j)))</div></pre></td></tr></table></figure>
<p>可以写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  i &lt;- <span class="number">1</span> until n</div><div class="line">  j &lt;- <span class="number">1</span> until i</div><div class="line">  <span class="keyword">if</span> isPrime(i + j)</div><div class="line">&#125; <span class="keyword">yield</span> (i, j)</div></pre></td></tr></table></figure>
<h3 id="For-的翻译"><a href="#For-的翻译" class="headerlink" title="For 的翻译"></a>For 的翻译</h3><p>Scala 编译器会把 for 表达式翻译成 <code>map</code>、<code>flatMap</code> 和 <code>filter</code> 的一种懒求值变体的组合。</p>
<ul>
<li>简单的 for 表达式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1) <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>会被翻译为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.map(x =&gt; e2)</div></pre></td></tr></table></figure>
<ul>
<li>包含过滤器的 for 表达式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1 <span class="keyword">if</span> f; s) <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>其中 <code>f</code> 是过滤器，<code>s</code> 是（可能为空）一系列的生成器和过滤器。它会被翻译为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1.withFilter(x =&gt; f); s) <span class="keyword">yield</span> e2</div></pre></td></tr></table></figure>
<p>可以认为 <code>withFilter</code> 是 <code>filter</code> 的一种变体，它不产生临时列表，而是直接过滤 <code>map</code> 或 <code>flatMap</code>中剩余的元素。</p>
<ul>
<li>包含多个生成器的 for 表达式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (x &lt;- e1; y &lt;- e2; s) <span class="keyword">yield</span> e3</div></pre></td></tr></table></figure>
<p>会被翻译为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e1.flatMap(x =&gt; <span class="keyword">for</span> (y &lt;- e2; s) <span class="keyword">yield</span> e3)</div></pre></td></tr></table></figure>
<p>然后继续递归翻译。</p>
<h3 id="For-表达式和模式匹配"><a href="#For-表达式和模式匹配" class="headerlink" title="For 表达式和模式匹配"></a>For 表达式和模式匹配</h3><p>生成器的左侧也可以是模式。</p>
<p>比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> data: <span class="type">List</span>[<span class="type">JSON</span>] = ...</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  <span class="type">JObj</span>(bindings) &lt;- data</div><div class="line">  <span class="type">JSeq</span>(phones) = bindings(<span class="string">"phoneNumbers"</span>)</div><div class="line">  <span class="type">JObj</span>(phone) &lt;- phones</div><div class="line">  <span class="type">JStr</span>(digits) = phone(<span class="string">"number"</span>)</div><div class="line">  <span class="keyword">if</span> (digits) startsWith <span class="string">"212"</span></div><div class="line">&#125; <span class="keyword">yield</span> (bindings(<span class="string">"firstName"</span>), bindings(<span class="string">"lastName"</span>))</div></pre></td></tr></table></figure>
<p>如果 <code>pat</code> 是有一个变量 <code>x</code> 的模式，将会把</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pat &lt;- expr</div></pre></td></tr></table></figure>
<p>翻译为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x &lt;- expr withFilter &#123;</div><div class="line">       <span class="keyword">case</span> pat =&gt; <span class="literal">true</span></div><div class="line">       caes _ =&gt; <span class="literal">false</span></div><div class="line">     &#125; map &#123;</div><div class="line">       <span class="keyword">case</span> pat =&gt; x</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- <span class="number">2</span> to <span class="type">N</span></div><div class="line">  y &lt;- <span class="number">2</span> to x</div><div class="line">  <span class="keyword">if</span> (x % y == <span class="number">0</span>)</div><div class="line">&#125; <span class="keyword">yield</span> (x, y)</div></pre></td></tr></table></figure>
<p>会被翻译为？</p>
<p>答案：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="number">2</span> to <span class="type">N</span>) flatMap (x =&gt;</div><div class="line">  (<span class="number">2</span> to x) withFilter (y =&gt;</div><div class="line">    x % y == <span class="number">0</span>) map (y =&gt; (x, y)))</div></pre></td></tr></table></figure>
<h3 id="For-表达式的其他用法：函数式随机生成器"><a href="#For-表达式的其他用法：函数式随机生成器" class="headerlink" title="For 表达式的其他用法：函数式随机生成器"></a>For 表达式的其他用法：函数式随机生成器</h3><p>For 可以应用在任何实现了 <code>map</code>、<code>flatMap</code>、<code>withFilter</code> 的对象上。</p>
<p>现在以一个能生成任意类型的随机生成器为例。</p>
<p>首先定义 trait：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Generator</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span></span>: <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一些实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> integers = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">Int</span>] &#123;</div><div class="line">  <span class="keyword">val</span> rand = <span class="keyword">new</span> java.util.<span class="type">Random</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= rand.nextInt()</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> booleans = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">Boolean</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= integers.generate &gt; <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> pairs = <span class="keyword">new</span> <span class="type">Generator</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= (integers.generate, integers.generate)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会发现有许多 <code>new Generator</code> 重复，能避免吗？理想中的写法是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> booleans = <span class="keyword">for</span> (x &lt;- integers) <span class="keyword">yield</span> x &gt; <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairs</span></span>[<span class="type">T</span>, <span class="type">U</span>](t: <span class="type">Generator</span>[<span class="type">T</span>], u: <span class="type">Generator</span>[<span class="type">U</span>]) = <span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- t</div><div class="line">  y &lt;- u</div><div class="line">&#125; <span class="keyword">yield</span> (x, y)</div></pre></td></tr></table></figure>
<p>这其实会生成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> booleans = integers map (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairs</span></span>[<span class="type">T</span>, <span class="type">U</span>](t: <span class="type">Generator</span>[<span class="type">T</span>], u: <span class="type">Generator</span>[<span class="type">U</span>]) =</div><div class="line">  t flatMap (x =&gt; u map (y =&gt; (x, y)))</div></pre></td></tr></table></figure>
<p>所以说要定义 <code>map</code> 和 <code>flatMap</code>。下面是一个更便捷的 <code>Generator</code> 版本：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Generator</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">  self =&gt;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span></span>: <span class="type">T</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>): <span class="type">Generator</span>[<span class="type">S</span>] = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">S</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= f(self.generate)</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">Generator</span>[<span class="type">S</span>]): <span class="type">Generator</span>[<span class="type">S</span>] = <span class="keyword">new</span> <span class="type">Generaotr</span>[<span class="type">S</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= f(self.generate).generate</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么上面的 <code>booleans</code> 和 <code>pairs</code> 展开过程为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> booleans = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">Boolean</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= (x: <span class="type">Int</span> =&gt; x &gt; <span class="number">0</span>)(integers.generate)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> booleans = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">Boolean</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= integers.generate &gt; <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairs</span></span>[<span class="type">T</span>, <span class="type">U</span>](t: <span class="type">Generator</span>[<span class="type">T</span>], u: <span class="type">Generator</span>[<span class="type">U</span>]) = t flatMap &#123;</div><div class="line">  x =&gt; <span class="keyword">new</span> <span class="type">Generator</span>[(<span class="type">T</span>, <span class="type">U</span>)] &#123; <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= (x, u.generate) &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairs</span></span>[<span class="type">T</span>, <span class="type">U</span>](t: <span class="type">Generator</span>[<span class="type">T</span>], u: <span class="type">Generator</span>[<span class="type">U</span>]) = <span class="keyword">new</span> <span class="type">Generator</span>[(<span class="type">T</span>, <span class="type">U</span>)] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= (<span class="keyword">new</span> <span class="type">Generator</span>[(<span class="type">T</span>, <span class="type">U</span>)] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= (t.generate, u.generate)</div><div class="line">  &#125;).generate</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairs</span></span>[<span class="type">T</span>, <span class="type">U</span>](t: <span class="type">Generator</span>[<span class="type">T</span>], u: <span class="type">Generator</span>[<span class="type">U</span>]) = <span class="keyword">new</span> <span class="type">Generator</span>[(<span class="type">T</span>, <span class="type">U</span>)] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= (t.generate, u.generate)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后可以定义一些实用方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">single</span></span>[<span class="type">T</span>](x: <span class="type">T</span>): <span class="type">Generator</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">T</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span> </span>= x</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span></span>(lo: <span class="type">Int</span>, hi: <span class="type">Int</span>): <span class="type">Generator</span>[<span class="type">Int</span>] =</div><div class="line">  <span class="keyword">for</span> (x &lt;- integers) <span class="keyword">yield</span> lo + x % (hi - lo)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">oneOf</span></span>[<span class="type">T</span>](xs: <span class="type">T</span>*): <span class="type">Generator</span>[<span class="type">T</span>] =</div><div class="line">  <span class="keyword">for</span> (idx &lt;- choose(<span class="number">0</span>, xs.length)) <span class="keyword">yield</span> xs(idx)</div></pre></td></tr></table></figure>
<p>现在就可以定义一个生成列表的随机生成器了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lists</span></span>: <span class="type">Generator</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="keyword">for</span> &#123;</div><div class="line">  isEmpty &lt;- booleans</div><div class="line">  list &lt;- <span class="keyword">if</span> (isEmpty) emptyLists <span class="keyword">else</span> nonEmptyLists</div><div class="line">&#125; <span class="keyword">yield</span> list</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">emptyLists</span> </span>= single(<span class="type">Nil</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nonEmptyLists</span> </span>= <span class="keyword">for</span> &#123;</div><div class="line">  head &lt;- integers</div><div class="line">  tail &lt;- lists</div><div class="line">&#125; <span class="keyword">yield</span> head :: tail</div></pre></td></tr></table></figure>
<p>也可以定义一个生成二叉树的随机生成器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Tree</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Inner</span>(<span class="params">left: <span class="type">Tree</span>, right: <span class="type">Tree</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Leaf</span>(<span class="params">x: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></div><div class="line"><span class="class"><span class="title">def</span> <span class="title">leafs</span></span>: <span class="type">Generator</span>[<span class="type">Leaf</span>] = <span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- integers</div><div class="line">&#125; <span class="keyword">yield</span> <span class="type">Leaf</span>(x)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inners</span></span>: <span class="type">Generator</span>[<span class="type">Inner</span>] = <span class="keyword">for</span> &#123;</div><div class="line">  l &lt;- trees</div><div class="line">  r &lt;- trees</div><div class="line">&#125; <span class="keyword">yield</span> <span class="type">Inner</span>(l, r)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">trees</span></span>: <span class="type">Generator</span>[<span class="type">Tree</span>] = <span class="keyword">for</span> &#123;</div><div class="line">  isLeaf &lt;- booleans</div><div class="line">  tree &lt;- <span class="keyword">if</span> (isLeaf) leafs <span class="keyword">else</span> inners</div><div class="line">&#125; <span class="keyword">yield</span> tree</div></pre></td></tr></table></figure>
<h3 id="随机生成器的一个应用：随机测试-Random-Testing"><a href="#随机生成器的一个应用：随机测试-Random-Testing" class="headerlink" title="随机生成器的一个应用：随机测试 (Random Testing)"></a>随机生成器的一个应用：随机测试 (Random Testing)</h3><p>关于单元测试：</p>
<ul>
<li>包含一些测试输入和一个后置条件 (postcondition)</li>
<li>后置条件是期望结果的一个属性</li>
<li>验证此程序是否满足后置条件</li>
</ul>
<p>若将测试输入替换为随机生成的输入，就是随机测试。</p>
<p>用随机生成器可以写一个测试函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>[<span class="type">T</span>](g: <span class="type">Generator</span>[<span class="type">T</span>], numTimes: <span class="type">Int</span> = <span class="number">100</span>)(test: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numTimes) &#123;</div><div class="line">    <span class="keyword">val</span> value = g.generate</div><div class="line">    assert(test(value), <span class="string">"test failed for "</span> + value)</div><div class="line">  &#125;</div><div class="line">  println(<span class="string">"passed "</span> + numTimes + <span class="string">" tests"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有下面的一个使用例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test(pairs(lists, lists)) &#123;</div><div class="line">  <span class="keyword">case</span> (xs, ys) =&gt; (xs ++ ys).length &gt; xs.length</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会始终通过测试吗？</p>
<p>答案是不会。因为 <code>lists</code> 随机生成器会生成空列表。</p>
<p>关于 ScalaCheck：一个测试工具，使用它写测试时只用写待测属性而不用写具体测试过程。比如这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">forAll &#123; (l1: <span class="type">List</span>[<span class="type">Int</span>], l2: <span class="type">List</span>[<span class="type">Int</span>]) =&gt;</div><div class="line">  l1.size + l2.size == (l1 ++ l2).size</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="单子-Monad"><a href="#单子-Monad" class="headerlink" title="单子 (Monad)"></a>单子 (Monad)</h3><p>可以看出包含 <code>map</code> 和 <code>flatMap</code> 的数据结构很普遍。实际上有个专门的名称来表述这些满足一定代数条件的数据结构类别，这就是<em>单子</em>。</p>
<p>一个单子 <code>M</code> 是一个拥有 <code>flatMap</code> 和 <code>unit</code> 这两种操作的参数化类型 <code>M[T]</code>，它必须满足一些条件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">M</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">M</span>[<span class="type">U</span>]): <span class="type">M</span>[<span class="type">U</span>]</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">T</span>](x: <span class="type">T</span>): <span class="type">M</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure>
<p>在其他文献中，<code>flatMap</code> 也常被称为 <code>bind</code>。</p>
<ul>
<li><code>List</code> 是单子，其中 <code>unit(x) = List(x)</code></li>
<li><code>Set</code> 是单子，其中 <code>unit(x) = Set(x)</code></li>
<li><code>Option</code> 是单子，其中 <code>unit(x) = Some(x)</code></li>
<li><code>Generator</code> 是单子，其中 <code>unit(x) = single(x)</code></li>
</ul>
<p>在 Scala 中，<code>flatMap</code> 是这些类型上的一个操作，而 <code>unit</code> 对于每个单子都不相同。</p>
<p>对每个单子， <code>map</code> 可以被定义为 <code>flatMap</code> 和 <code>unit</code> 的组合：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m map f == m flatMap (x =&gt; unit(f(x)))</div><div class="line">        == m flatMap (f andThen unit)</div></pre></td></tr></table></figure>
<h3 id="单子的条件"><a href="#单子的条件" class="headerlink" title="单子的条件"></a>单子的条件</h3><p>一种类型若为合格的单子需要满足三个条件：</p>
<ul>
<li>结合律（associativity）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m flatMap f flatMap g == m flatMap (x =&gt; f(x) flatMap g)</div></pre></td></tr></table></figure>
<ul>
<li>左单位元（left unit）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unit(x) flatMap f == f(x)</div></pre></td></tr></table></figure>
<ul>
<li>右单位元（right unit）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m flatMap unit == m</div></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a href="http://stormluke.me/reactive-programming-note-02/%23%E4%BE%8B%E5%AD%90" title="例子"></a>例子</h3><p>现在以 <code>Option</code> 为例来检验这三个条件。<code>Option</code> 的 <code>flatMap</code> 为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Option</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">Option</span>[<span class="type">U</span>]): <span class="type">Option</span>[<span class="type">U</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; f(x)</div><div class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来验证 <code>Some(x) flatMap f == f(x)</code> (左单位元)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="type">Some</span>(x) flatMap f</div><div class="line">==  <span class="type">Some</span>(x) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; f(x)</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></div><div class="line">    &#125;</div><div class="line">==  f(x)</div></pre></td></tr></table></figure>
<p>再来验证 <code>opt flatMap Some == opt</code> (右单位元)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    opt flatMap <span class="type">Some</span></div><div class="line">==  opt <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; <span class="type">Some</span>(x)</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></div><div class="line">    &#125;</div><div class="line">==  opt</div></pre></td></tr></table></figure>
<p>最后验证 <code>opt flatMap f flatMap g == opt flatMap (x =&gt; f(x) flatMap g)</code> (结合律)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    opt flatMap f flatMap g</div><div class="line">==  opt <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; f(x) <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span> &#125;</div><div class="line">        <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Some</span>(y) =&gt; g(y) <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span> &#125;</div><div class="line">==  opt <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt;</div><div class="line">        f(x) <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Some</span>(y) =&gt; g(y) <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span> &#125;</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">        <span class="type">None</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Some</span>(y) =&gt; g(y) <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span> &#125;</div><div class="line">    &#125;</div><div class="line">==  opt <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt;</div><div class="line">        f(x) <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Some</span>(y) =&gt; g(y) <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span> &#125;</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></div><div class="line">    &#125;</div><div class="line">==  opt <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; f(x) flatMap g</div><div class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></div><div class="line">    &#125;</div><div class="line">==  opt flatMap (x =&gt; f(x) flatMap g)</div></pre></td></tr></table></figure>
<h3 id="三条件对-for-表达式的意义"><a href="#三条件对-for-表达式的意义" class="headerlink" title="三条件对 for 表达式的意义"></a>三条件对 for 表达式的意义</h3><p>可以看到单子类型的表达式一贯被写为 for 表达式，那么对它来说这三个条件的意义是什么呢？</p>
<ul>
<li>结合律本质上是说可以“内联 (inline)”嵌套 for 表达式：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">for</span> (y &lt;- <span class="keyword">for</span> (x &lt;- m; y &lt;- f(x)) <span class="keyword">yield</span> y</div><div class="line">         z &lt;- g(y)) <span class="keyword">yield</span> z</div><div class="line">==  <span class="keyword">for</span> (x &lt;- m;</div><div class="line">         y &lt;- f(x)</div><div class="line">         z &lt;- g(y)) <span class="keyword">yield</span> z</div></pre></td></tr></table></figure>
<ul>
<li>右单位元是指：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">for</span> (x &lt;- m) <span class="keyword">yield</span> x</div><div class="line">==  m</div></pre></td></tr></table></figure>
<ul>
<li>左单位元在 for 表达式中没有对应</li>
</ul>
<h3 id="另一个类型：Try"><a href="#另一个类型：Try" class="headerlink" title="另一个类型：Try"></a>另一个类型：Try</h3><p><code>Try</code> 类似于 <code>Option</code>，不同之处是将 <code>Some</code> / <code>None</code> 替换成了包含一个值的 <code>Success</code> 和包含一个异常的<code>Failure</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Try</span>[+<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Success</span>[<span class="type">T</span>](<span class="params">x: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Failure</span>(<span class="params">ex: <span class="type">Exception</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">Nothing</span>]</span></div></pre></td></tr></table></figure>
<p><code>Try</code> 被用来在线程或计算机间传递计算结果，这些计算可能失败并包含异常。</p>
<p><code>Try</code> 可以包裹任意的计算：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Try</span>(expr) <span class="comment">// 返回 Success(someValue) 或 Failure(someException)</span></div></pre></td></tr></table></figure>
<p>下面是 <code>Try</code> 的一个实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Try</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>): <span class="type">Try</span>[<span class="type">T</span>] =</div><div class="line">    <span class="keyword">try</span> <span class="type">Success</span>(expr)</div><div class="line">    <span class="keyword">catch</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(ex) =&gt; <span class="type">Failure</span>(ex)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像 <code>Option</code> 一样，<code>Try</code> 类型的计算可以由 for 表达式构成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- computeX</div><div class="line">  y &lt;- computeY</div><div class="line">&#125; <span class="keyword">yield</span> f(x, y)</div></pre></td></tr></table></figure>
<p>如果 <code>computeX</code> 和 <code>computeY</code> 均成功且结果是 <code>Success(x)</code> 和 <code>Success(y)</code>，那么会返回 <code>Success(f(x, y))</code>。如果其中一个失败并有一个异常 <code>ex</code>，则会返回 <code>Failure(ex)</code>。</p>
<p>下面是 <code>Try</code> 中 <code>flatMap</code> 和 <code>map</code> 的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Try</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">Try</span>[<span class="type">U</span>]): <span class="type">Try</span>[<span class="type">U</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt; <span class="keyword">try</span> f(x) <span class="keyword">catch</span> &#123; <span class="keyword">case</span> <span class="type">NonFatal</span>(ex) =&gt; <span class="type">Failure</span>(ex) &#125;</div><div class="line">    <span class="keyword">case</span> fail: <span class="type">Failure</span> =&gt; fail</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">Try</span>[<span class="type">U</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt; <span class="type">Try</span>(f(x))</div><div class="line">    <span class="keyword">case</span> fail: <span class="type">Failure</span> =&gt; fail</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以对一个 <code>Try</code> 类型值 <code>t</code> 有：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">t map f == t flatMap (x =&gt; <span class="type">Try</span>(f(x)))</div><div class="line">        == t flatMap (f andThen <span class="type">Try</span>)</div></pre></td></tr></table></figure>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>看起来 <code>Try</code> 像是一个单子，其中 <code>unit = Try</code>，对吗？</p>
<p>其实它不满足左单位元：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Try</span>(expr) flatMap f != f(expr)</div></pre></td></tr></table></figure>
<p>实际上左侧永远不会产生非致命异常，但右侧会产生由 <code>expr</code> 或 <code>f</code> 抛出的任何异常。</p>
<p>因此，<code>Try</code> 以一个单子条件的代价换来了另外一个特性，这在下面的情景中更有用：</p>
<blockquote>
<p>由 <code>Try</code>、<code>map</code>、<code>flatMap</code> 构成的表达式永远不会抛出非致命异常</p>
</blockquote>
<p>称这个为“防弹”原则 (“bullet-proof” principle)。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从上面可以看出 for 表达式不仅仅对于集合有用。很多其他类型也定义了 <code>map</code>、<code>flatMap</code>、<code>withFilter</code> 操作和由此而来的 for 表达式。</p>
<p>很多定义了 <code>flatMap</code> 的类型都是单子。如果它们也定义了 <code>withFilter</code>，则可以称为“包含0的单子” (monads with zero)。</p>
<p>单子的三个条件给库的API设计提供了有用的指导。</p>
</div></article></div></main><footer><div class="paginator"><a href="/reactive-programming-note-03/" class="prev">PREV</a><a href="/reactive-programming-note-01/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'reactive-programming-note-02/';
var disqus_title = '响应式编程笔记 02';
var disqus_url = 'http://stormluke.me/reactive-programming-note-02/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>