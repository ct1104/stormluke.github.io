<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> WWDC16 笔记——协议和值在 UIKit 中的应用 · Preferences</title><meta name="description" content="WWDC16 笔记——协议和值在 UIKit 中的应用 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">WWDC16 笔记——协议和值在 UIKit 中的应用</h1><div class="post-info">Jul 6, 2016</div><div class="post-content"><p>这个 <a href="http://asciiwwdc.com/2016/sessions/419" target="_blank" rel="external">Session</a> 通过一个 App 实例讲解了协议和值类型在 UIKit 中的应用。</p>
<h3 id="Local-Reasoning"><a href="#Local-Reasoning" class="headerlink" title="Local Reasoning"></a>Local Reasoning</h3><p>Local reasoning 是指，当看到面前的代码时，不必考虑其他代码是如何和它交互的。这让代码更容易维护，更容易编写，更容易测试。</p>
<p>下面通过一个实际的 App 来说明。这个 App 叫做 <a href="https://developer.apple.com/go/?id=lucid-dreams" target="_blank" rel="external">Lucid Dreams</a>，它用来记录程序员做过的白日梦。</p>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5ja7n5g1nj20qe0ssn03.jpg" alt=""></p>
<h3 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h3><p>一个梦的模型可能是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dream</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> description: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> creature: <span class="type">Creature</span></div><div class="line">  <span class="keyword">var</span> effects: <span class="type">SetEffect</span>&gt;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但 <code>class</code> 型是引用语义，这会带来一个问题：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dream1 = <span class="type">Dream</span>(...)</div><div class="line"><span class="keyword">var</span> dream2 = dream1</div><div class="line">dream2.description = <span class="string">"Unicorns all over"</span></div></pre></td></tr></table></figure>
<p>改变 <code>dream2</code> 会导致 <code>dream1</code> 一起变化：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jaj4vetoj20so0lwmyq.jpg" alt=""></p>
<p>不同的对象间关系复杂，<code>class</code> 的引用语义在这里会造成不小麻烦：</p>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbjw1f5jaiuk123j219q0saads.jpg" alt=""></p>
<p>这不符合 local reasoning，可以用 <code>struct</code> 型来改进：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dream</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> description: <span class="type">String</span></div><div class="line">  <span class="keyword">var</span> creature: <span class="type">Creature</span></div><div class="line">  <span class="keyword">var</span> effects: <span class="type">SetEffect</span>&gt;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> dream1 = <span class="type">Dream</span>(...)</div><div class="line"><span class="keyword">var</span> dream2 = dream1</div></pre></td></tr></table></figure>
<p>此时两个 <code>dream</code> 是不同的：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jal1fignj20ju0r6myw.jpg" alt=""></p>
<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p>这个 App 里有一个列表来显示做过的梦，它的 <code>UITableViewCell</code> 是这样的继承结构：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5japsvp5lj21ag0ne0vv.jpg" alt=""></p>
<p>这样做层次分明，但问题来了，在梦的详情页面里有个几乎一模一样的界面来展示梦的缩略图和标题，但它是个直接继承 <code>UIView</code> 的视图：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbjw1f5jase7k6bj21kw0kz42q.jpg" alt=""></p>
<p>仅仅是因为子类类型的区别，相同的视图代码重复写了两次。更严重的是，之后还想用 <code>SKNode</code> 来展示同样的界面，只是缩略图是动态的，难道还要再复制粘贴一份代码吗？当然不是，这些界面有相似之处，即布局相同，可以把它们的布局逻辑抽象成同一个对象来减少重复：</p>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbjw1f5jaymru9gj21kw0ivta6.jpg" alt=""></p>
<p>把布局代码单独抽取出来作为 <code>DecoratingLayout</code>，它有一个只关心如何布局的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">UIView</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">UIView</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="comment">// Perform layout...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来布局逻辑和 <code>UITableViewCell</code> 解耦，可以用在 <code>UIView</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamCell</span> : <span class="title">UITableViewCell</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line">    decoratingLayout.layout(<span class="keyword">in</span>: bounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamDetailView</span> : <span class="title">UIView</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line">    decoratingLayout.layout(<span class="keyword">in</span>: bounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做还有一个好处，就是测试代码更容易写，不需要创建 <code>UITableView</code> 就可以测试布局：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> child1 = <span class="type">UIView</span>()</div><div class="line">  <span class="keyword">let</span> child2 = <span class="type">UIView</span>()</div><div class="line">  <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)</div><div class="line">  layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(child1.frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UIView</code> 和 <code>UITableViewCell</code> 的问题解决了，<code>SKNode</code> 的问题还没有。这主要是因为在 <code>DecoratingLayout</code> 里强制限定了 <code>UIView</code> 类型，把它换成一个 <code>protocol Layout</code> 即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span>: <span class="title">Layout</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Child</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="comment">// Perform layout...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> frame: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>现在又有一个新的视图，它和之前的布局相似，只是缩略图变成了层叠的：</p>
<p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5jbsrbw8sj21580eq0u5.jpg" alt=""></p>
<p>可以用组合 <code>UIView</code> 的方式解决这个问题，把视图分为两个部分，一个负责层叠的缩略图部分，一个负责整体的横向布局：</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5jbtwihisj21340im3zc.jpg" alt=""></p>
<p>但是注意：</p>
<ul>
<li><code>class</code> 实例开销很大！</li>
<li><code>struct</code> 开销却很小</li>
<li>组合和值类型配合得更好</li>
</ul>
<p>所以说可以用组合 <code>struct</code> 来改进：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayoutChild</span> : <span class="title">Layout</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">var</span> children: [<span class="type">Child</span>]</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来不错，但 <code>CascadingLayout</code> 和 <code>DecoratingLayout</code> 都有 <code>layout</code> 方法，而且布局并不需要读写 <code>frame</code> 这么大的权限，因此可以用 <code>protocol Layout</code> 来泛化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>, ...&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayoutChild</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> decoration = <span class="type">CascadingLayout</span>(children: accessories)</div><div class="line"><span class="keyword">var</span> composedLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)</div><div class="line"></div><div class="line">composedLayout.layout(<span class="keyword">in</span>: rect)</div></pre></td></tr></table></figure>
<p>还有个问题，层叠视图中的子视图具有先后的顺序关系，需要在 <code>protocol</code> 中体现它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Layout</span>] &#123; <span class="keyword">get</span> &#125; <span class="comment">// UIView and SKNode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这样一来 <code>content</code> 的类型限制就没了。怎么办？用 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md" target="_blank" rel="external"><code>associatedtype</code></a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  associatedtype <span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Child</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>问题又来了，<code>content</code> 和 <code>decoration</code> 类型一致（<code>Child</code>），两个都是 <code>UIView</code> 时固然没错，但如果想如下布局该怎么办？</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbjw1f5jcyc5n7nj20p60egmyb.jpg" alt=""></p>
<p>改类型，用约束：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayoutChild</span> : <span class="title">Layout</span>, <span class="title">Decoration</span> : <span class="title">Layout</span></span></div><div class="line"><span class="class">                        <span class="title">where</span> <span class="title">Child</span>.<span class="title">Content</span> == <span class="title">Decoration</span>.<span class="title">Content</span>&gt; : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> content: <span class="type">Child</span></div><div class="line">  <span class="keyword">var</span> decoration: <span class="type">Decoration</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></div><div class="line">  <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span></div><div class="line">  <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>终于结束了。好处也是有的，测试时不必使用真正的 <code>UIView</code> 类型，随便换个遵循 <code>protocol Layout</code>的就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> child1 = <span class="type">TestLayout</span>()</div><div class="line">  <span class="keyword">let</span> child2 = <span class="type">TestLayout</span>()</div><div class="line">  <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)</div><div class="line">  layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">0</span>].frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))</div><div class="line">  <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">1</span>].frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestLayout</span> : <span class="title">Layout</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> frame: <span class="type">CGRect</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="控制器层"><a href="#控制器层" class="headerlink" title="控制器层"></a>控制器层</h3><p>这个 App 还有一个功能：摇晃撤销上次修改。相关的代码是这样写的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]</div><div class="line">  <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dreams</code> 和 <code>favoriteCreature</code> 都要支持撤销操作，它们均被撤销管理器管理：</p>
<p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5k0jbwx61j218a0lcq4q.jpg" alt=""></p>
<p>这就有问题了，每个属性都要写一份自己的撤销操作代码，如果之后有更多的属性，那就得写更多的重复代码。怎么办？可以把这些属性封装成一个整体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> model: <span class="type">Model</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span> : <span class="title">Equatable</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]</div><div class="line">  <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来每次撤销操作都操作一个整体模型，避免了把琐碎的撤销操作分散到不同的地方：</p>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1f5k0pprxm1j21iw10q796.jpg" alt=""></p>
<p>整体容易撤销操作了，但具体的界面更新怎么办？根据模型变化部分更新：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">modelDidChange</span><span class="params">(old: Model, new: Model)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> old.favoriteCreature != new.favoriteCreature &#123;</div><div class="line">      <span class="comment">// Reload table view section for favorite creature.</span></div><div class="line">      tableView.reloadSections(...)</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    undoManager?.registerUndo(withTarget: <span class="keyword">self</span>, handler: &#123; target <span class="keyword">in</span></div><div class="line">      target.model = old</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 App 还有三种不同的状态，浏览、选择、分享。这些状态的相关代码分成了好几个属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> isInViewingMode: <span class="type">Bool</span></div><div class="line">  <span class="keyword">var</span> sharingDreams: [<span class="type">Dream</span>]?</div><div class="line">  <span class="keyword">var</span> selectedRows: <span class="type">IndexSet</span>?</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这不好，因为改变其中一个属性的同时还要记得改变相关的属性。用一个 <code>struct</code> 模型来改进：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> state: <span class="type">State</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> viewing</div><div class="line">  <span class="keyword">case</span> sharing(dreams: [<span class="type">Dream</span>])</div><div class="line">  <span class="keyword">case</span> selecting(selectedRows: <span class="type">IndexSet</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最终整体的 MVC 结构如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/6ad06ebbjw1f5k5mxg7elj21kw0tmaea.jpg" alt=""></p>
<ul>
<li>通过组合来自定义</li>
<li>使用 <code>protocol</code> 来编写通用的、可重用的代码</li>
<li>多利用值语义的优点</li>
<li>Local reasoning</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/about-java-01/" class="prev">PREV</a><a href="/things-2016/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'wwdc-2016-session-419-note/';
var disqus_title = 'WWDC16 笔记——协议和值在 UIKit 中的应用';
var disqus_url = 'http://stormluke.me/wwdc-2016-session-419-note/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>