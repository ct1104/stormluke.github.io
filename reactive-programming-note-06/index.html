<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 响应式编程笔记 06 · Preferences</title><meta name="description" content="响应式编程笔记 06 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">响应式编程笔记 06</h1><div class="post-info">Jun 20, 2014</div><div class="post-content"><h3 id="单子和副作用（Effects）"><a href="#单子和副作用（Effects）" class="headerlink" title="单子和副作用（Effects）"></a>单子和副作用（Effects）</h3><p>编程中四种基本的副作用为：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>一个</th>
<th>多个</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步</td>
<td><code>T / Try[T]</code></td>
<td><code>Iterable[T]</code></td>
</tr>
<tr>
<td>异步</td>
<td><code>Future[T]</code></td>
<td><code>Observable[T]</code></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="异常作为副作用（Exception-as-an-Effect）"><a href="#异常作为副作用（Exception-as-an-Effect）" class="headerlink" title="异常作为副作用（Exception as an Effect）"></a>异常作为副作用（Exception as an Effect）</h4><p>以一个游戏为例，在这个游戏中玩家收集金币然后买东西：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Adventure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collectCoins</span></span>(): <span class="type">List</span>[<span class="type">Coin</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyTreasure</span></span>(coins: <span class="type">List</span>[<span class="type">Coin</span>]): <span class="type">Treasure</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收集金币和买东西的过程中都可能产生异常，比如被怪物吃掉或者钱不够：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectCoins</span></span>(): <span class="type">List</span>[<span class="type">Coin</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (eatenByMonster(<span class="keyword">this</span>))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">GameOverException</span>(<span class="string">"Ooops"</span>)</div><div class="line">  <span class="type">List</span>(<span class="type">Gold</span>, <span class="type">Gold</span>, <span class="type">Silver</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buyTreasure</span></span>(coins: <span class="type">List</span>[<span class="type">Coin</span>]): <span class="type">Treasure</span> = &#123;</div><div class="line">  <span class="keyword">if</span> (coins.sumBy(_.value) </div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">GameOverException</span>(<span class="string">"Nice try!"</span>)</div><div class="line">  <span class="type">Diamond</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>游戏执行的过程中可能因为一个异常没有被处理而不能继续：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> adventure = <span class="type">Adventure</span>()</div><div class="line"><span class="keyword">val</span> coins = adventure.collectCoins()</div><div class="line"><span class="comment">// 只有无异常才会继续执行</span></div><div class="line"><span class="keyword">val</span> treasure = adventure.buyTreasure(coins)</div><div class="line"><span class="comment">// 只有无异常才会继续执行</span></div></pre></td></tr></table></figure>
<p>通过引入 <code>Try</code> 这个类可以让异常由隐式的变为显式的（materialize），从而更加好处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Success</span>[<span class="type">T</span>](<span class="params">elem: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">T</span>]</span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Failure</span>(<span class="params">t: <span class="type">Throwable</span></span>) <span class="keyword">extends</span> <span class="title">Try</span>[<span class="type">Nothing</span>]</span></div><div class="line"><span class="class"><span class="title">trait</span> <span class="title">Adventure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collectCoins</span></span>(): <span class="type">Try</span>[<span class="type">List</span>[<span class="type">Coin</span>]]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyTreasure</span></span>(coins: <span class="type">List</span>[<span class="type">Coin</span>]): <span class="type">Try</span>[<span class="type">Treasure</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> adventure = <span class="type">Adventure</span>()</div><div class="line"><span class="keyword">val</span> coins: <span class="type">Try</span>[<span class="type">List</span>[<span class="type">Coin</span>]] = adventure.collectCoins()</div><div class="line"><span class="keyword">val</span> treasure: <span class="type">Try</span>[<span class="type">Treasure</span>] = coins <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(cs) =&gt; adventure.buyTreasure(cs)</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实 <code>Try</code> 是单子，被设计用来处理异常，其上定义好了许多函数式编程的基础方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">U</span> <span class="type">Try</span>[<span class="type">T</span>]]: <span class="type">Try</span>[<span class="type">U</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">S</span>): <span class="type">Try</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span>=&gt;<span class="type">Boolean</span>): <span class="type">Try</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverWith</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>, <span class="type">Try</span>[<span class="type">T</span>]]): <span class="type">Try</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure>
<p>因此上面的程序也可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> treasure: <span class="type">Try</span>[<span class="type">Treasure</span>] = adventure.collectCoins().flatMap(coins =&gt; &#123;</div><div class="line">  adventure.buyTreasure(coins)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果用 <code>for</code> 表达式就更简洁了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> treasure: <span class="type">Try</span>[<span class="type">Treasure</span>] = <span class="keyword">for</span> &#123;</div><div class="line">  coins </div><div class="line">  treasure </div><div class="line">&#125; <span class="keyword">yield</span> treasure</div></pre></td></tr></table></figure>
<p><code>Try</code> 是单子，它的 <code>map</code> 和 <code>apply</code> 方法大概实现如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">S</span>): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(value) =&gt; <span class="type">Try</span>(f(value))</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Try</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](r: =&gt;<span class="type">T</span>): <span class="type">Try</span>[<span class="type">T</span>] = &#123;</div><div class="line">    <span class="keyword">try</span> &#123; <span class="type">Success</span>(r) &#125;</div><div class="line">    <span class="keyword">catch</span> &#123; <span class="keyword">case</span> t =&gt; <span class="type">Failure</span>(t) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习：下面哪个函数是正确的 <code>Try</code> 的 <code>flatMap</code> 实现？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Success</span>(values) =&gt; f(value)</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// b</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Success</span>(value) =&gt; <span class="type">Try</span>(f(value))</div><div class="line">  <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// c</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span>=&gt;<span class="type">Try</span>[<span class="type">S</span>]): <span class="type">Try</span>[<span class="type">S</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123; <span class="keyword">case</span> <span class="type">Success</span>(value) =&gt;</div><div class="line">  <span class="keyword">try</span> &#123; f(value) &#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> t =&gt; <span class="type">Failure</span>(t) &#125; <span class="keyword">case</span> failure @ <span class="type">Failure</span>(t) =&gt; failure</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是 c。a 中调用 <code>f</code> 时没有处理异常，b 中返回值类型为 <code>Try[Try[T]]</code>。</p>
<h4 id="延迟作为副作用（Latency-as-an-Effect）"><a href="#延迟作为副作用（Latency-as-an-Effect）" class="headerlink" title="延迟作为副作用（Latency as an Effect）"></a>延迟作为副作用（Latency as an Effect）</h4><p>以套接字为例，从内存读取和通过网络发送数据都会产生延迟：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Socket</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">readFromMemory</span></span>(): <span class="type">Array</span>[<span class="type">Byte</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendToEurope</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Array</span>[<span class="type">Byte</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> packet = socket.readFromMemory()</div><div class="line"><span class="comment">// 阻塞 50000 ns，不产生异常时才会继续执行</span></div><div class="line"><span class="keyword">val</span> confirmation = socket.sendToEurope(packet)</div><div class="line"><span class="comment">// 阻塞 150000000 ns，不产生异常时才会继续执行</span></div></pre></td></tr></table></figure>
<p><code>Future</code> 这个单子用来处理延迟和异常：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.concurrent._</div><div class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(callback: <span class="type">Try</span>[<span class="type">T</span>] =&gt; <span class="type">Unit</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Unit</span></div><div class="line">  <span class="comment">// alternative designs</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(success: <span class="type">T</span> =&gt; <span class="type">Unit</span>, failed: <span class="type">Throwable</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(callback: <span class="type">Observer</span>[<span class="type">T</span>]): <span class="type">Unit</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// alternative designs</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Observer</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onNext</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onError</span></span>(error: <span class="type">Throwable</span>): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>implicit</code> 表示隐式参数。<code>Future</code> 一般在另外的线程中运行，因此回调函数 <code>onComplete</code> 会提供一个运行环境参数 <code>executor</code> 来指示运行时所使用的线程环境。</p>
<p><code>Future</code> 在使用形式上可能会遇到些问题，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> packet: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.readFromMemory()</div><div class="line"><span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = packet onComplete &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(p) =&gt; socket.sendToEurope(p)</div><div class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序是错的，<code>confirmation</code> 的类型并不是 <code>Future[Array[Byte]]</code>。但如果这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">packet onComplete &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Success</span>(p) =&gt; &#123;</div><div class="line">    <span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.sendToEurope(p)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当延迟任务变多时程序结构会变得很混乱。</p>
<p>暂时先不管 <code>Future</code> 的使用形式问题，来看看如何创建一个 <code>Future</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(body: =&gt;<span class="type">T</span>)(<span class="keyword">implicit</span> context: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习：假设有以下代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</div><div class="line"><span class="keyword">import</span> akka.serializer._</div><div class="line"><span class="keyword">val</span> memory = <span class="type">Queue</span>[<span class="type">EMailMessage</span>](</div><div class="line">  <span class="type">EMailMessage</span>(from = <span class="string">"Erik"</span>, to = <span class="string">"Roland"</span>),</div><div class="line">  <span class="type">EMailMessage</span>(from = <span class="string">"Martin"</span>, to = <span class="string">"Erik"</span>),</div><div class="line">  <span class="type">EMailMessage</span>(from = <span class="string">"Roland"</span>, to = <span class="string">"Martin"</span>))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readFromMemory</span></span>(): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = <span class="type">Future</span> &#123;</div><div class="line">  <span class="keyword">val</span> email = queue.dequeue()</div><div class="line">  <span class="keyword">val</span> serializer = serialization.findSerializerFor(email)</div><div class="line">  serializer.toBinary(email)</div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> packet: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.readFromMemory()</div><div class="line">packet onSuccess &#123;</div><div class="line">  <span class="keyword">case</span> bs =&gt; socket.sendToEurope(p)</div><div class="line">&#125;</div><div class="line">packet onSuccess &#123;</div><div class="line">  <span class="keyword">case</span> bs =&gt; socket.sendToEurope(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当其执行完时 <code>email</code> 队列中还剩几封邮件？</p>
<p>答案是 2 封。尽管调用了两次 <code>onSuccess</code>，但是 <code>Future</code> 对象会缓存执行完的结果，两个 <code>onSuccess</code>都使用了同一封邮件。</p>
<h4 id="Future-上的组合子"><a href="#Future-上的组合子" class="headerlink" title="Future 上的组合子"></a>Future 上的组合子</h4><p>Scala 中的 <code>Future</code> 大概是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Awaitable</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123;</div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">ready</span></span>(atMost: <span class="type">Duration</span>): <span class="type">Unit</span></div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>(atMost: <span class="type">Duration</span>): <span class="type">T</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Awaitable</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">Future</span>[<span class="type">S</span>]): <span class="type">Future</span>[<span class="type">U</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">S</span>): <span class="type">Future</span>[<span class="type">S</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">recoverWith</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>, <span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Future</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt; <span class="type">T</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有一个 <code>Http</code> 对象用来发送网络请求，现在想向欧洲和美国均发一封邮件，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Http</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(url: <span class="type">URL</span>, req: <span class="type">Request</span>): <span class="type">Future</span>[<span class="type">Response</span>] =</div><div class="line">    &#123;... runs the http request asynchronously ...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendTo</span></span>(url: <span class="type">URL</span>, packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] =</div><div class="line">  <span class="type">Http</span>(url, <span class="type">Request</span>(packet)).filter(response =&gt; response.isOK).map(response =&gt; response.toByteArray)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToAndBackup</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[(<span class="type">Array</span>[<span class="type">Byte</span>], <span class="type">Array</span>[<span class="type">Byte</span>])] = &#123;</div><div class="line">  <span class="keyword">val</span> europeConfirm = sendTo(mailServer.europe, packet)</div><div class="line">  <span class="keyword">val</span> usaConfirm = sendTo(mailServer.usa, packet)</div><div class="line">  europeConfirm.zip(usaConfirm)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这些方法依旧可能产生异常，程序并没有处理好这些潜在的错误。</p>
<p>实际上 <code>Future</code> 提供了两个用来从错误中恢复的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>,<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverWith</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Throwable</span>,<span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">T</span>]</div></pre></td></tr></table></figure>
<p><code>recover</code> 用一个同步的过程来恢复，而 <code>recoverWith</code> 则可以使用一个异步的过程。</p>
<p>现在将程序改为先向欧洲发送，若失败再向美国发送：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToSafe</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] =</div><div class="line">  sendTo(mailServer.europe, packet) recoverWith &#123;</div><div class="line">    <span class="keyword">case</span> europeError =&gt; sendTo(mailServer.usa, packet) recover &#123;</div><div class="line">      <span class="keyword">case</span> usaError =&gt; usaError.getMessage.toByteArray</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>虽然过程上正确，但当两个网络请求都失败时返回的异常是 <code>usaError</code>，并不是想要的 <code>europeError</code>。因此想增加一个 <code>fallbackTo</code> 函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToSafe</span></span>(packet: <span class="type">Array</span>[<span class="type">Byte</span>]): <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] =</div><div class="line">  sendTo(mailServer.europe, packet) fallbackTo &#123;</div><div class="line">    sendTo(mailServer.usa, packet)</div><div class="line">  &#125; recover &#123;</div><div class="line">    <span class="keyword">case</span> europeError =&gt; europeError.getMessage.toByteArray</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fallbackTo</span></span>(that: =&gt; <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">this</span> recoverWith &#123;</div><div class="line">    <span class="keyword">case</span> _ =&gt; that recoverWith &#123; <span class="keyword">case</span> _ =&gt; <span class="keyword">this</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时程序就是正确并鲁棒的了，而且 <code>fallbackTo</code> 的加入让程序变得更加直观。</p>
<p>练习：现在想定义一个支持 <code>Future</code> 的 <code>Try</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Try</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">Try</span>[<span class="type">T</span>]] = &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的 <code>apply</code> 方法该如何实现？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a</span></div><div class="line">f onComplete &#123; x =&gt; x &#125;</div><div class="line"></div><div class="line"><span class="comment">// b</span></div><div class="line">f recoverWith &#123; <span class="keyword">case</span> t =&gt; <span class="type">Future</span>.failed(t) &#125;</div><div class="line"></div><div class="line"><span class="comment">// c</span></div><div class="line">f.map(x =&gt; <span class="type">Try</span>(x))</div><div class="line"></div><div class="line"><span class="comment">// d</span></div><div class="line">f.map(s =&gt; <span class="type">Success</span>(s)) recover &#123; <span class="keyword">case</span> t =&gt; <span class="type">Failure</span>(t) &#125;</div></pre></td></tr></table></figure>
<p>答案为 d。a 中返回值为 <code>Unit</code>，b 和 c 都只考虑了 <code>Try</code> 的一个 case。</p>
<p>之前看到 <code>Future</code> 继承了 <code>Awaitable</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Awaitable</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123;</div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">ready</span></span>(atMost: <span class="type">Duration</span>): <span class="type">Unit</span></div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>(atMost: <span class="type">Duration</span>): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>应当注意这两个函数都是同步阻塞的，用来延迟执行或等待结果：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> packet: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = socket.readFromMemory()</div><div class="line"><span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = packet.flatMap(socket.sendToSafe(_))</div><div class="line"><span class="keyword">val</span> c = <span class="type">Await</span>.result(confirmation, <span class="number">2</span> seconds)</div><div class="line">println(c.toText)</div></pre></td></tr></table></figure>
<h4 id="Future-的应用"><a href="#Future-的应用" class="headerlink" title="Future 的应用"></a>Future 的应用</h4><p>因为 <code>Future</code> 是单子，所以可以使用 <code>for</code> 表达式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> socket = <span class="type">Socket</span>()</div><div class="line"><span class="keyword">val</span> confirmation: <span class="type">Future</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = <span class="keyword">for</span> &#123;</div><div class="line">  packet       </div><div class="line">  confirmation </div><div class="line">&#125; <span class="keyword">yield</span> confirmation</div></pre></td></tr></table></figure>
<p>现在想定义一个不断尝试执行 <code>Future</code> 最多 n 次直至成功的函数，一个可行的实现是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt; <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (noTimes == <span class="number">0</span>) &#123;</div><div class="line">    <span class="type">Future</span>.failed(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"Sorry"</span>))</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    block fallbackTo &#123;</div><div class="line">      retry(noTimes–<span class="number">1</span>) &#123; block &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是一个人曾说过：</p>
<blockquote>
<p>Recursion is the GOTO of Functional Programming - ErikMeijer</p>
</blockquote>
<p>这个人其实就是本课的老师……另外一个方法就是使用 <code>foldRight</code> 或 <code>foldLeft</code> 来实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foldLeft</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt;<span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> ns: <span class="type">Iterator</span>[<span class="type">Int</span>] = (<span class="number">1</span> to noTimes).iterator</div><div class="line">  <span class="keyword">val</span> attempts: <span class="type">Iterator</span>[<span class="type">Future</span>[<span class="type">T</span>]] = ns.map(_=&gt; ()=&gt;block)</div><div class="line">  <span class="keyword">val</span> failed = <span class="type">Future</span>.failed(<span class="keyword">new</span> <span class="type">Exception</span>)</div><div class="line">  attempts.foldLeft(failed)((a,block) =&gt; a recoverWith &#123; block() &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// foldRight</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt;<span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> ns: <span class="type">Iterator</span>[<span class="type">Int</span>] = (<span class="number">1</span> to noTimes).iterator</div><div class="line">  <span class="keyword">val</span> attempts: <span class="type">Iterator</span>[<span class="type">Future</span>[<span class="type">T</span>]] = ns.map(_=&gt; ()=&gt;block) <span class="keyword">val</span> failed = <span class="type">Future</span>.failed(<span class="keyword">new</span> <span class="type">Exception</span>)</div><div class="line">  attempts.foldRight(() =&gt; failed)</div><div class="line">  ((block, a) =&gt; () =&gt; &#123; block() fallbackTo &#123; a() &#125; &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在觉得显式的副作用并不方便，能不能将其变成隐式的呢？比如 <code>Future</code>，能否将 <code>T =&gt; Future[S]</code>变为 <code>T =&gt; S</code>？答案是可以的，Scala 提供了 <code>async { ... await{ ... } ... }</code> 这种语法结构：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.async.<span class="type">Async</span>._</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">async</span></span>[<span class="type">T</span>](body: =&gt;<span class="type">T</span>)(<span class="keyword">implicit</span> context: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">await</span></span>[<span class="type">T</span>](future: <span class="type">Future</span>[<span class="type">T</span>]): <span class="type">T</span></div></pre></td></tr></table></figure>
<p><code>await</code> 会将异步非阻塞的代码变成同步阻塞的，外部的 <code>async</code> 依旧返回异步非阻塞的 <code>Future</code>。</p>
<p><code>await</code> 需要编译器的支持，因此需要注意以下几个方面：</p>
<ul>
<li><code>await</code> 外部的 <code>async</code> 必须是直接包裹的</li>
<li><code>await</code> 不能用在 by-name 参数中</li>
<li><code>await</code> 不能用在短路布尔表达式中</li>
<li><code>async</code> 不能包含 <code>return</code> 表达式</li>
<li><code>await</code> 不能包含在 <code>try-catch</code> 中</li>
</ul>
<p>使用了 <code>await</code> 后，代码会简洁很多：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retry</span></span>(noTimes: <span class="type">Int</span>)(block: =&gt;<span class="type">Future</span>[<span class="type">T</span>]): <span class="type">Future</span>[<span class="type">T</span>] = async &#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> result: <span class="type">Try</span>[<span class="type">T</span>] = <span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"sorry man!"</span>))</div><div class="line">  <span class="keyword">while</span> (i </div><div class="line">    result = await &#123; <span class="type">Try</span>(block) &#125;</div><div class="line">    i += <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  result.get</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>await</code> 重写 <code>filter</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">T</span>] = async &#123;</div><div class="line">  <span class="keyword">val</span> x = await &#123; <span class="keyword">this</span> &#125;</div><div class="line">  <span class="keyword">if</span> (!p(x)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>()</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    x</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习：如何用 <code>await</code> 实现 <code>flatMap</code>？答案如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">S</span>](f: <span class="type">T</span> =&gt; <span class="type">Future</span>[<span class="type">S</span>]): <span class="type">Future</span>[<span class="type">S</span>] =</div><div class="line">  async &#123; await &#123; f( await &#123; <span class="keyword">this</span> &#125; ) &#125; &#125;</div></pre></td></tr></table></figure>
<p>如果不用 <code>await</code>，可以使用 <code>Promise</code> 实现 <code>filter</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(pred: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">T</span>]()</div><div class="line">  <span class="keyword">this</span> onComplete &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt;</div><div class="line">      p.failure(e)</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</div><div class="line">      <span class="keyword">if</span> (!pred(x)) p.failure(<span class="keyword">new</span> <span class="type">NoSuchElementException</span>)</div><div class="line">      <span class="keyword">else</span> p.success(x)</div><div class="line">  &#125;</div><div class="line">  p.future</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code> 包含一个 <code>Future</code>，当调用 <code>Promise</code> 的 <code>complete</code> 方法时 <code>Promise</code> 会调用自身 <code>Future</code> 上的回调函数。<code>tryComplete</code> 和 <code>complete</code> 方法类似，只是当该 <code>Promise</code> 已经完成后 <code>tryComplete</code> 会返回 <code>false</code>。<code>success</code> 和 <code>failure</code> 是两个简化方法，用来表示成功执行或发生异常。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Promise</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">future</span></span>: <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">complete</span></span>(result: <span class="type">Try</span>[<span class="type">T</span>]): <span class="type">Unit</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tryComplete</span></span>(result: <span class="type">Try</span>[<span class="type">T</span>]): <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">success</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span> = <span class="keyword">this</span>.complete(<span class="type">Success</span>(value))</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">failure</span></span>(t: <span class="type">Throwable</span>): <span class="type">Unit</span> = <span class="keyword">this</span>.complete(<span class="type">Failure</span>(t))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的 <code>zip</code> 方法可以这样实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">S</span>, <span class="type">R</span>](that: <span class="type">Future</span>[<span class="type">S</span>], f: (<span class="type">T</span>, <span class="type">S</span>) =&gt; <span class="type">R</span>): <span class="type">Future</span>[<span class="type">R</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">R</span>]()</div><div class="line">  <span class="keyword">this</span> onComplete &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; p.failure(e)</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt; that onComplete &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; p.failure(e)</div><div class="line">      <span class="keyword">case</span> <span class="type">Success</span>(y) =&gt; p.success(f(x, y))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  p.future</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 <code>await</code> 来实现的话会特别简洁：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">S</span>, <span class="type">R</span>](p: <span class="type">Future</span>[<span class="type">S</span>], f: (<span class="type">T</span>, <span class="type">S</span>) =&gt; <span class="type">R</span>): <span class="type">Future</span>[<span class="type">R</span>] = async &#123;</div><div class="line">  f(await &#123; <span class="keyword">this</span> &#125;, await &#123; that &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在用 <code>await</code> 定义一个队列函数，它会依次执行队列中的 <code>Future</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence</span></span>[<span class="type">T</span>](fs: <span class="type">List</span>[<span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">List</span>[<span class="type">T</span>]] = async &#123;</div><div class="line">  <span class="keyword">var</span> _fs = fs</div><div class="line">  <span class="keyword">val</span> r = <span class="type">ListBuffer</span>[<span class="type">T</span>]()</div><div class="line">  <span class="keyword">while</span> (_fs != <span class="type">Nil</span>) &#123;</div><div class="line">    r += await &#123; _fs.head &#125;</div><div class="line">    _fs = _fs.tail</div><div class="line">  &#125;</div><div class="line">  f.result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 <code>Promise</code> 来定义的话是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence</span></span>[<span class="type">T</span>](fs: <span class="type">List</span>[<span class="type">Future</span>[<span class="type">T</span>]]): <span class="type">Future</span>[<span class="type">List</span>[<span class="type">T</span>]] = &#123;</div><div class="line">  <span class="keyword">val</span> successful = <span class="type">Promise</span>[<span class="type">List</span>[<span class="type">T</span>]]()</div><div class="line">  successful.success(<span class="type">Nil</span>)</div><div class="line">  fs.foldRight(successful.future) &#123;</div><div class="line">    (f, acc) =&gt; <span class="keyword">for</span> &#123; x <span class="keyword">yield</span> x :: xs</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/a-plan-for-spam/" class="prev">PREV</a><a href="/wwdc-2014-note-swift/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>