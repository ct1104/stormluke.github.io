<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ReactiveCocoa README 笔记 · Preferences</title><meta name="description" content="ReactiveCocoa README 笔记 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ReactiveCocoa README 笔记</h1><div class="post-info">May 3, 2016</div><div class="post-content"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md" target="_blank" rel="external">ReactiveCocoa/README.md</a></p>
<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">FRP</a></p>
<blockquote>
<p>事件流</p>
</blockquote>
<ul>
<li><code>Signal</code></li>
<li><code>SignalProducer</code></li>
</ul>
<a id="more"></a>
<p>用来统一这些模式：</p>
<ul>
<li>Delegate methods</li>
<li>Callback blocks</li>
<li><code>NSNotification</code>s</li>
<li>Control actions and responder chain events</li>
<li>Futures and promises</li>
<li>Key-value observing (KVO)</li>
</ul>
<h3 id="例子-在线搜索"><a href="#例子-在线搜索" class="headerlink" title="例子: 在线搜索"></a>例子: 在线搜索</h3><h4 id="观察文本的编辑"><a href="#观察文本的编辑" class="headerlink" title="观察文本的编辑"></a>观察文本的编辑</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchStrings = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div></pre></td></tr></table></figure>
<p>这样获取到一个发送 <code>String</code> 类型的 <code>SignalProducer</code>。为了支持 Objective-C 的 extension 方法，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2182" target="_blank" rel="external">目前 <code>as!</code> 是必须的</a>。</p>
<h4 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchResults = searchStrings</div><div class="line">    .flatMap(.<span class="type">Latest</span>) &#123; (query: <span class="type">String</span>) -&gt; <span class="type">SignalProducerNSData</span>, <span class="type">NSURLResponse</span>), <span class="type">NSError</span>&gt; <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> <span class="type">URLRequest</span> = <span class="keyword">self</span>.searchRequestWithEscapedQuery(query)</div><div class="line">        <span class="keyword">return</span> <span class="type">NSURLSession</span>.sharedSession().rac_dataWithRequest(<span class="type">URLRequest</span>)</div><div class="line">    &#125;</div><div class="line">    .<span class="built_in">map</span> &#123; (data, <span class="type">URLResponse</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> string = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)!</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.parseJSONResultsFromString(string)</div><div class="line">    &#125;</div><div class="line">    .observeOn(<span class="type">UIScheduler</span>())</div></pre></td></tr></table></figure>
<ul>
<li><code>observeOn(UIScheduler())</code> 在主线程上推送结果</li>
<li><code>flatMap(.Latest)</code> 保证只有最后一个网络请求是活动的</li>
</ul>
<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>上面的代码并没有开始“运行”。直到下面这句话：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">searchResults.startWithNext &#123; results <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"Search results: \(results)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察 <code>Next</code> 事件并处理。</p>
<h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>在这个例子里，任何网络错误会生成 <code>Failed</code> 事件，并且会终止事件流。但上面的代码并没有处理。修复一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.flatMap(.<span class="type">Latest</span>) &#123; (query: <span class="type">String</span>) -&gt; <span class="type">SignalProducerNSData</span>, <span class="type">NSURLResponse</span>), <span class="type">NSError</span>&gt; <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> <span class="type">URLRequest</span> = <span class="keyword">self</span>.searchRequestWithEscapedQuery(query)</div><div class="line">    <span class="keyword">return</span> <span class="type">NSURLSession</span>.sharedSession()</div><div class="line">        .rac_dataWithRequest(<span class="type">URLRequest</span>)</div><div class="line">        .flatMapError &#123; error <span class="keyword">in</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"Network error occurred: \(error)"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">SignalProducer</span>.empty</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>记录错误日志并且忽略错误。把错误换成了 <code>empty</code> 事件流。</p>
<p>如果出错则重试似乎更好，巧的是，确实有个 <code>retry</code> 算子。</p>
<h4 id="限流请求"><a href="#限流请求" class="headerlink" title="限流请求"></a>限流请求</h4><p>只想在用户停止输入后执行搜索以减少流量。ReactiveCocoa 有个 <code>throttle</code> 算子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchStrings = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div></pre></td></tr></table></figure>
<h4 id="调试事件流"><a href="#调试事件流" class="headerlink" title="调试事件流"></a>调试事件流</h4><p>事件的栈轨迹会是一大坨，让调试很恶心。一种 navie 的调试方法是给流注入副作用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchString = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div><div class="line">    .on(event: &#123; <span class="built_in">print</span> ($<span class="number">0</span>) &#125;) <span class="comment">// the side effect</span></div></pre></td></tr></table></figure>
<p><code>SignalProducer</code> 和 <code>Signal</code> 提供 <code>logEvents</code> 算子来自动做这件事：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> searchString = textField.rac_textSignal()</div><div class="line">    .toSignalProducer()</div><div class="line">    .<span class="built_in">map</span> &#123; text <span class="keyword">in</span> text <span class="keyword">as</span>! <span class="type">String</span> &#125;</div><div class="line">    .throttle(<span class="number">0.5</span>, onScheduler: <span class="type">QueueScheduler</span>.mainQueueScheduler)</div><div class="line">    .logEvents()</div></pre></td></tr></table></figure>
<h3 id="Objective-C-和-Swift"><a href="#Objective-C-和-Swift" class="headerlink" title="Objective-C 和 Swift"></a>Objective-C 和 Swift</h3><p>3.0 版本后所有的重要特性开发都集中在 Swfit API。</p>
<p>Objective-C API 和 Swift API 完全是分离的，但有<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/ObjectiveCBridging.md" target="_blank" rel="external">桥接方法</a>。</p>
<h3 id="ReactiveCocoa-和-Rx-的关系？"><a href="#ReactiveCocoa-和-Rx-的关系？" class="headerlink" title="ReactiveCocoa 和 Rx 的关系？"></a>ReactiveCocoa 和 Rx 的关系？</h3><p>ReactiveCocoa <em>故意</em>不是 Rx 的直接移植版。</p>
<p>RAC 相比于 Rx 主要用于：</p>
<ul>
<li>建立更简单的 API</li>
<li>Address common sources of confusion</li>
<li>更符合 Cocoa 习惯</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>在 Rx 的绝大多数版本里，流被叫做 <code>Observable</code>，是 .NET <code>Enumerable</code> 类型的并行版。另外，Rx.NET 的许多操作的名字来源于 LINQ，主要用于影射关系型数据库，比如 <code>Select</code>、<code>Where</code>。</p>
<p>RAC 则主要遵循 Swift 命名，比如 <code>map</code>、<code>filter</code>。其他命名的差异一般是来自 Haskell 或 Elm 中明显更好的名字。</p>
<h4 id="Singles-和-Signal-Producers-“hot”-和-“cold”-observables"><a href="#Singles-和-Signal-Producers-“hot”-和-“cold”-observables" class="headerlink" title="Singles 和 Signal Producers (“hot” 和 “cold” observables)"></a>Singles 和 Signal Producers (“hot” 和 “cold” observables)</h4><p>Rx 里难理解的部分中的一个就是 <a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html" target="_blank" rel="external">“hot”, “cold”, and “warm” observables</a>。</p>
<p>简单来说，只给出如下的函数声明</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">IObservable</span>&lt;string&gt; <span class="type">Search</span>(string query)</div></pre></td></tr></table></figure>
<p><strong>不可能</strong>看出订阅这个 <code>IObservable</code> 会不会引入副作用，如果它<em>确实</em>有副作用，也不能看出是否<em>每个订阅</em>会有副作用还是仅仅第一个订阅会有副作用。</p>
<p>这个例子展示了让 Rx（和 3.0 版前的 ReactiveCocoa）代码难一眼看懂的<strong>真实普遍的问题</strong>。</p>
<p>ReacitveCocoa 3.0 用 <code>Signal</code> 和 <code>SignalProducer</code> 来区分副作用。</p>
<p>换句话说，ReactiveCocoa 的改变<a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="external">简约不简单</a>。</p>
<h4 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h4><p>RAC 允许使用 <code>NoError</code> 来<em>静态保证</em>一个事件流不允许发出异常。<strong>这消除了许多由意外异常事件引发的 bug</strong>。</p>
<p>在 Rx 里没有错误类型。</p>
<h4 id="UI-编程"><a href="#UI-编程" class="headerlink" title="UI 编程"></a>UI 编程</h4><p>Rx 一般不知道它如何被使用，尽管用 Rx 来 UI 编程很常见。</p>
<p>RAC 受到很多来自 ReactiveUI 的启发，比如 <code>Action</code>。</p>
<p>和 ReactiveUI 不能直接改造 Rx 不同，RAC 为 UI 编程改进了很多次，即使这样会和 Rx 变得越来越不同。</p>
</div></article></div></main><footer><div class="paginator"><a href="/learning-to-hash-intro/" class="prev">PREV</a><a href="/book-list-2016/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'reactive-cocoa-readme/';
var disqus_title = 'ReactiveCocoa README 笔记';
var disqus_url = 'http://stormluke.me/reactive-cocoa-readme/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>