<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 响应式编程笔记 04 · Preferences</title><meta name="description" content="响应式编程笔记 04 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">响应式编程笔记 04</h1><div class="post-info">Jun 12, 2014</div><div class="post-content"><h3 id="同一性和变化"><a href="#同一性和变化" class="headerlink" title="同一性和变化"></a>同一性和变化</h3><p>赋值给辨别两个表达式是否<em>相同</em>带了新问题。当不考虑赋值时，可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="type">E</span>; <span class="keyword">val</span> y = <span class="type">E</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>其中 <code>E</code> 为任意的表达式，可以合理假定 <code>x</code> 和 <code>y</code> 是一样的，就是说也可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="type">E</span>; <span class="keyword">val</span> y = x</div></pre></td></tr></table></figure>
<p>这个特性一般称为<a href="http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29" target="_blank" rel="external"><em>引用透明（referential transparency）</em></a>。</p>
<p>但当引入赋值后，这两个式子就不同了，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line"><span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">BankAccount</span></div></pre></td></tr></table></figure>
<p>“相同”这个词的准确意义由<a href="https://en.wikipedia.org/wiki/Operational_equivalence" target="_blank" rel="external"><em>运作相等（operational equivalence）</em></a>这个特性定义，非形式化来说就是假设有两个定义 <code>x</code> 和 <code>y</code>，若没有一个<em>可行的测试</em>能区分它们，则称 <code>x</code> 和 <code>y</code> 是运作相等的。</p>
<p>要测试 <code>x</code> 和 <code>y</code> 是否相同，应该：</p>
<ul>
<li>对其执行涉及 <code>x</code> 和 <code>y</code> 的任意操作序列 <code>S</code>，观察可能的结果</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line"><span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line">f(x, y)</div></pre></td></tr></table></figure>
<ul>
<li>然后执行另外一个操作序列 <code>S&#39;</code>，<code>S&#39;</code> 是将 <code>S</code> 中的 <code>y</code> 全部换成 <code>x</code> 后得到的序列</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line"><span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line">f(x, x)</div></pre></td></tr></table></figure>
<ul>
<li>如果这两个结果不同，则 <code>x</code> 和 <code>y</code> 肯定不同</li>
<li>如果所有可能的序对 <code>(S, S&#39;)</code> 的结果都相同，则 <code>x</code> 和 <code>y</code> 相同</li>
</ul>
<p>基于这个定义，来看看下面的表达式是否相同：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line"><span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">BankAccount</span></div></pre></td></tr></table></figure>
<p>用这个测试序列来执行：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x deposit <span class="number">30</span>    <span class="comment">// val res1: Int = 30</span></div><div class="line">y withdraw <span class="number">20</span>   <span class="comment">// java.lang.Error:insufficient funds</span></div></pre></td></tr></table></figure>
<p>现在将序列中的 <code>y</code> 全部换为 <code>x</code>，得到：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x deposit <span class="number">30</span>    <span class="comment">// val res1: Int = 30</span></div><div class="line">x withdraw <span class="number">20</span>   <span class="comment">// val res2: Int = 10</span></div></pre></td></tr></table></figure>
<p>可以看到两个结果不一致，所以 <code>x</code> 和 <code>y</code> 是不同的。</p>
<p>另一方面，若定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">BankAccount</span></div><div class="line"><span class="keyword">val</span> y = x</div></pre></td></tr></table></figure>
<p>没有任何操作序列可以区分它们，所以 <code>x</code> 和 <code>y</code> 在这个例子中是相同的。</p>
<p>上面的例子展示了在引入赋值时替换模型变得不正确。可以通过引入一个 <em>store</em> 来继续适应替换模型，但这会变得相当复杂。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>命题：变量足以建模所有命令式程序。</p>
<p>但是像循环之类的控制语句怎么办？其实可以用函数来实现它们。</p>
<p>比如说，<code>while</code> 循环语句可以用函数 <code>WHILE</code> 来定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">WHILE</span></span>(condition: =&gt; <span class="type">Boolean</span>)(command: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> =</div><div class="line">  <span class="keyword">if</span> (condition) &#123;</div><div class="line">    command</div><div class="line">    <span class="type">WHILE</span>(condition)(command)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> ()</div></pre></td></tr></table></figure>
<p>有两点值得注意：一是 <code>condition</code> 和 <code>command</code> 必须使用名传递（passed by name），这样它们才会在每个迭代中被重新求值；二是 <code>WHILE</code> 是尾递归的，所以它可以在常量栈空间内执行。</p>
<p>练习：写一个实现 <code>repeat</code> 循环的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">REPEAT</span> &#123;</div><div class="line">  command</div><div class="line">&#125; (condition)</div></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">REPEAT</span></span>(command: =&gt; <span class="type">Unit</span>)(condition: =&gt; <span class="type">Boolean</span>) = &#123;</div><div class="line">  command</div><div class="line">  <span class="keyword">if</span> (condition) ()</div><div class="line">  <span class="keyword">else</span> <span class="type">REPEAT</span>(command)(condition)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习：用函数实现 <code>repeat-until</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">REPEAT</span> &#123;</div><div class="line">  command</div><div class="line">&#125; <span class="type">UNTIL</span> (condition)</div></pre></td></tr></table></figure>
<p>一个可行的方法是（来自<a href="https://class.coursera.org/reactive-001/forum/thread?thread_id=355#post-1545" target="_blank" rel="external">Ilya Golberg</a>，混合了 <code>repeat-until</code> 和 <code>repeat</code>）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">REPEAT</span></span>(command: =&gt; <span class="type">Until</span>) = <span class="keyword">new</span> &#123;</div><div class="line">  <span class="comment">/* REPEAT &#123;command&#125; UNTIL (condition) */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">UNTIL</span></span>(condition: =&gt; <span class="type">Boolean</span>) &#123;</div><div class="line">    command</div><div class="line">    <span class="keyword">if</span> (!condition) <span class="type">UNTIL</span>(condition)</div><div class="line">    <span class="keyword">else</span> ()</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* REPEAT &#123;command&#125; (condition) */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(condition: =&gt; <span class="type">Boolean</span>) = <span class="type">UNTIL</span>(condition)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 中的典型 <code>for</code> 循环是不能由高阶函数建模的，比如下面这个 Java 程序：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i <span class="number">3</span>; i = i + <span class="number">1</span>) &#123; <span class="type">System</span>.out.print(i + <span class="string">" "</span>); &#125;</div></pre></td></tr></table></figure>
<p>原因是 <code>for</code> 的参数中包含了变量 <code>i</code> 的<em>声明</em>，这个变量在其他参数和循环体中都是可见的。</p>
<p>但其实在 Scala 中有一个和 Java 扩展 <code>for</code> 循环类似的 <code>for</code> 循环：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="number">1</span> until <span class="number">3</span>) &#123; <span class="type">System</span>.out.print(i + <span class="string">" "</span>) &#125;</div></pre></td></tr></table></figure>
<p><code>for</code> 循环和 <code>for</code> 表达式的翻译过程类似，不过用 <code>foreach</code> 组合子（combinator）替换了 <code>map</code> 和 <code>flatMap</code>。<code>foreach</code> 在包含元素类型 <code>T</code> 的集合中如下定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> =</div><div class="line">  <span class="comment">// apply f to each element of the collection</span></div></pre></td></tr></table></figure>
<p>比如，下面的式子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="number">1</span> until <span class="number">3</span>; j <span class="string">"abc"</span>) println(i + <span class="string">" "</span> + j)</div></pre></td></tr></table></figure>
<p>会被翻译为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> until <span class="number">3</span>) foreach (i =&gt; <span class="string">"abc"</span> foreach (j =&gt; println(i + <span class="string">" "</span> + j)))</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/reactive-programming-note-05/" class="prev">PREV</a><a href="/reactive-programming-note-03/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>