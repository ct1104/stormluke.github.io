<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 函数式编程笔记 02 · Preferences</title><meta name="description" content="函数式编程笔记 02 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">函数式编程笔记 02</h1><div class="post-info">Jun 26, 2013</div><div class="post-content"><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><p>非基础表达式这样求值：</p>
<ol>
<li>取最左边的运算符</li>
<li>从左向右对运算数求值</li>
<li>对运算数施加运算符</li>
</ol>
<p>变量名替换为定义右边的东西</p>
<a id="more"></a>
<h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><p>定义可以有参数和返回值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Double</span>) = x * x</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOfSquares</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) = square(x) + square(y)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span></span>(x: <span class="type">Double</span>, y: <span class="type">Int</span>): <span class="type">Double</span> = ...</div></pre></td></tr></table></figure>
<h3 id="函数的求值"><a href="#函数的求值" class="headerlink" title="函数的求值"></a>函数的求值</h3><ol>
<li>从左向右对所有函数参数求值</li>
<li>把函数替换为右边的东西，同时</li>
<li>把之前的参数替换为真正的值</li>
</ol>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sumOfSquares(<span class="number">3</span>, <span class="number">2</span>+<span class="number">2</span>)</div><div class="line">sumOfSquares(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">squares(<span class="number">3</span>) +　squares(<span class="number">4</span>)</div><div class="line"><span class="number">3</span> * <span class="number">3</span> + squares(<span class="number">4</span>)</div><div class="line"><span class="number">9</span> + squares(<span class="number">4</span>)</div><div class="line"><span class="number">9</span> + <span class="number">4</span> * <span class="number">4</span></div><div class="line"><span class="number">9</span> + <span class="number">16</span></div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<h3 id="代换模型"><a href="#代换模型" class="headerlink" title="代换模型"></a>代换模型</h3><p>上面叫做代换模型，中心思想是<em>把表达式退变成值</em>。</p>
<p>这个代换模型在<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="external">λ演算(lambda-calculus)</a>中被正式提出，是函数式编程的基础。</p>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>每个表达式都可以在有限步内退化成一个值吗？</p>
<p>不是。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>: <span class="type">Int</span> = loop</div></pre></td></tr></table></figure>
<h3 id="改变求值策略"><a href="#改变求值策略" class="headerlink" title="改变求值策略"></a>改变求值策略</h3><p>先重写函数，再对参数求值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sumOfSquares(<span class="number">3</span>, <span class="number">2</span>+<span class="number">2</span>)</div><div class="line">square(<span class="number">3</span>) + square(<span class="number">2</span>+<span class="number">2</span>)</div><div class="line"><span class="number">3</span> * <span class="number">3</span> + square(<span class="number">2</span>+<span class="number">2</span>)</div><div class="line"><span class="number">9</span> + square(<span class="number">2</span>+<span class="number">2</span>)</div><div class="line"><span class="number">9</span> + (<span class="number">2</span>+<span class="number">2</span>) * (<span class="number">2</span>+<span class="number">2</span>)</div><div class="line"><span class="number">9</span> + <span class="number">4</span> * (<span class="number">2</span>+<span class="number">2</span>)</div><div class="line"><span class="number">9</span> + <span class="number">4</span> * <span class="number">4</span></div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<h3 id="Call-by-name和call-by-value"><a href="#Call-by-name和call-by-value" class="headerlink" title="Call-by-name和call-by-value"></a>Call-by-name和call-by-value</h3><p>上面第一种叫做<em>call-by-value</em>，第二种叫做<em>call-by-name</em>。</p>
<p>当</p>
<ul>
<li>退化表达式只包含函数</li>
<li>所有求值都能终止</li>
</ul>
<p>时，两种都会退化成同一个值。</p>
<p>Call-by-value的优势是每个参数只会被求值一次。</p>
<p>Call-by-name的优势是可以不求没用的参数的值。</p>
<h4 id="终止-1"><a href="#终止-1" class="headerlink" title="终止"></a>终止</h4><ul>
<li>如果CBV下表达式<code>e</code>可以终止，则CBN下<code>e</code>也可以终止</li>
<li>但反过来不行</li>
</ul>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x</div></pre></td></tr></table></figure>
<p>Scala默认使用call-by-value。</p>
<p>但是也可以在函数参数前加<code>=&gt;</code>来使用call-by-name。</p>
<p>这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">constOne</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = <span class="number">1</span></div></pre></td></tr></table></figure>
<p><code>constOne(1 + 2, loop)</code>会终止，但<code>constOne(loop, 1 + 2)</code>不会。</p>
<h4 id="值定义"><a href="#值定义" class="headerlink" title="值定义"></a>值定义</h4><p>定义也区分by-name和by-value。<code>def</code>是by-name，<code>val</code>是by-value。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span> </span>= loop</div></pre></td></tr></table></figure>
<p>会终止，而</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = loop</div></pre></td></tr></table></figure>
<p>不会。</p>
<h3 id="例子：用牛顿法求平方根"><a href="#例子：用牛顿法求平方根" class="headerlink" title="例子：用牛顿法求平方根"></a>例子：用牛顿法求平方根</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sqrt</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Double</span>) = <span class="keyword">if</span> (x <span class="number">0</span>) -x <span class="keyword">else</span> x       <span class="comment">//&gt; abs: (x: Double)Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</div><div class="line">    abs(guess * guess - x) / x <span class="number">0.001</span>            <span class="comment">//&gt; isGoodEnough: (guess: Double, x: Double)Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</div><div class="line">    (guess + x / guess) / <span class="number">2</span>                       <span class="comment">//&gt; improve: (guess: Double, x: Double)Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>): <span class="type">Double</span> =</div><div class="line">    <span class="keyword">if</span> (isGoodEnough(guess, x)) guess</div><div class="line">    <span class="keyword">else</span> sqrtIter(improve(guess, x), x)           <span class="comment">//&gt; sqrtIter: (guess: Double, x: Double)Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>) = sqrtIter(<span class="number">1.0</span>, x)          <span class="comment">//&gt; sqrt: (x: Double)Double</span></div><div class="line">  sqrt(<span class="number">2</span>)                                         <span class="comment">//&gt; res0: Double = 1.4142156862745097</span></div><div class="line">  sqrt(<span class="number">1e-6</span>)                                      <span class="comment">//&gt; res1: Double = 0.0010000001533016628</span></div><div class="line">  sqrt(<span class="number">1e60</span>)                                      <span class="comment">//&gt; res2: Double = 1.0000788456669446E30</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这句</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abs(guess * guess - x) / x <span class="number">0.001</span></div></pre></td></tr></table></figure>
<p>解决了数过大或过小问题。</p>
<p>另外Scala中递归函数必须显式指定返回类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>): <span class="type">Double</span> =</div></pre></td></tr></table></figure>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><ul>
<li>包含一系列定义或表达式</li>
<li>最后一个表达式是该区块的值</li>
<li>返回值可以被之前的定义辅助生成</li>
<li>区块也是表达式，区块可以出现在任何表达式可以出现的地方</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>区块内部的定义只内部可见</li>
<li>区块内部的定义会覆盖外部的同名定义</li>
</ul>
<h3 id="用区块重构"><a href="#用区块重构" class="headerlink" title="用区块重构"></a>用区块重构</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sqrt</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Double</span>) = <span class="keyword">if</span> (x <span class="number">0</span>) -x <span class="keyword">else</span> x       <span class="comment">//&gt; abs: (x: Double)Double</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>) = &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>) =</div><div class="line">      abs(guess * guess - x) / x <span class="number">0.001</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>) =</div><div class="line">      (guess + x / guess) / <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>): <span class="type">Double</span> =</div><div class="line">      <span class="keyword">if</span> (isGoodEnough(guess)) guess</div><div class="line">      <span class="keyword">else</span> sqrtIter(improve(guess))</div><div class="line">    sqrtIter(<span class="number">1.0</span>)</div><div class="line">  &#125;                                               <span class="comment">//&gt; sqrt: (x: Double)Double</span></div><div class="line">  sqrt(<span class="number">2</span>)                                         <span class="comment">//&gt; res0: Double = 1.4142156862745097</span></div><div class="line">  sqrt(<span class="number">1e-6</span>)                                      <span class="comment">//&gt; res1: Double = 0.0010000001533016628</span></div><div class="line">  sqrt(<span class="number">1e60</span>)                                      <span class="comment">//&gt; res2: Double = 1.0000788456669446E30</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/functional-programming-note-03/" class="prev">PREV</a><a href="/functional-programming-note-01/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>