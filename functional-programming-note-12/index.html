<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 函数式编程笔记 12 · Preferences</title><meta name="description" content="函数式编程笔记 12 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">函数式编程笔记 12</h1><div class="post-info">Jul 18, 2013</div><div class="post-content"><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><code>Stream</code></h3><p>想要找出从1000到10000间第二个素数，可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="number">1000</span> to <span class="number">10000</span>) filter isPrime)(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>这性能上很不好，只需要第二个素数，但找出了1000到10000的所有素数。</p>
<p>可以用流来改进它，流和列表类似，但是流只在<em>需要时</em>才会被求值。</p>
<a id="more"></a>
<p>流是由一个常量<code>Stream.empty</code>和一个构造器<code>Stream.cons</code>定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> xs = <span class="type">Stream</span>.cons(<span class="number">1</span>, <span class="type">Stream</span>.cons(<span class="number">2</span>, <span class="type">Stream</span>.empty))</div><div class="line"><span class="comment">// 用Steam作工厂也可以</span></div><div class="line"><span class="type">Stream</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// toStream将集合变为流</span></div><div class="line">(<span class="number">1</span> to <span class="number">1000</span>).toStream    <span class="comment">// &gt; res0: Stream[Int] = Stream(1, ?)</span></div></pre></td></tr></table></figure>
<p>来看一个和<code>(lo until hi).toStream</code>类似的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">streamRange</span></span>(lo: <span class="type">Int</span>, hi: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">Int</span>] =</div><div class="line">    <span class="keyword">if</span>(lo &gt;= hi) <span class="type">Stream</span>.empty</div><div class="line">    <span class="keyword">else</span> <span class="type">Stream</span>.cons(lo, streamRange(lo + <span class="number">1</span>, hi))</div></pre></td></tr></table></figure>
<p>和它的<code>List</code>版本比较：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listRange</span></span>(lo: <span class="type">Int</span>, hi: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] =</div><div class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="type">Nil</span></div><div class="line">    <span class="keyword">else</span> lo :: listRange(lo + <span class="number">1</span>, hi)</div></pre></td></tr></table></figure>
<p>它们的区别主要在求值方式：</p>
<ul>
<li><code>listRange(start, end)</code>会生成一个包含从<code>end</code>到<code>start</code>元素的列表</li>
<li><code>streamRange(start, end)</code>会生成一个以<code>start</code>作为头元素的流</li>
<li>剩下的元素仅在需要时才会被求值，需要是指在流上调用<code>tail</code>时</li>
</ul>
<p>流支持大部分列表上的操作，之前找素数的代码可以这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="number">1000</span> to <span class="number">10000</span>).toStream filter isPrime)(<span class="number">1</span>)    <span class="comment">// 只求值了前两个素数</span></div></pre></td></tr></table></figure>
<p>流和列表操作上最大的区别是连接符，<code>x :: xs</code>会生成列表，而<code>x #:: xs</code>会生成流。<code>#::</code>也可以用在模式中。</p>
<p>这是流的trait：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Stream</span>[+<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Seq</span>[<span class="type">A</span>] </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">Stream</span>[<span class="type">A</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是流的简单实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Stream</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons</span></span>[<span class="type">T</span>](hd: <span class="type">T</span>, tl: =&gt; <span class="type">Stream</span>[<span class="type">T</span>]) = <span class="keyword">new</span> <span class="type">Stream</span>[<span class="type">T</span>] &#123;</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">head</span> </span>= hd</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>= tl</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> empty = <span class="keyword">new</span> <span class="type">Stream</span>[<span class="type">Nothing</span>] &#123;</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">true</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">head</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"empty.head"</span>)</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"empty.tail"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到用了call-by-name参数<code>=&gt;</code>，因此不会立刻求值。</p>
<p>这是<code>filter</code>方法的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>[+<span class="type">T</span>] </span>&#123;…</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">Stream</span>[<span class="type">T</span>] =</div><div class="line">    <span class="keyword">if</span> (isEmpty) <span class="keyword">this</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p(head)) cons(head, tail.filter℗)</div><div class="line">    <span class="keyword">else</span> tail.filter℗</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="懒求值-Lazy-Evaluation"><a href="#懒求值-Lazy-Evaluation" class="headerlink" title="懒求值(Lazy Evaluation)"></a>懒求值(Lazy Evaluation)</h3><p>之前的实现有严重的性能问题，如果流的<code>tail</code>方法被调用多次，对应的流也会被多次求值。这个问题可以通过保存已计算出的值来解决，这种解决方法是可靠的，因为在纯函数式编程中无论何时求值表达式的值都是不变的。</p>
<p>这种方法叫做<em>懒求值</em>，相对的是<em>by-name求值</em>（每次都会被重计算）和<em>直接(strict)求值</em>（普通参数和<code>val</code>定义）。</p>
<p>Haskell默认使用懒求值，Scala默认使用直接求值，但也允许通过<code>lazy val</code>来应用懒求值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> x = expr</div></pre></td></tr></table></figure>
<p>练习：下面的代码的结果是什么？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span> </span>= &#123;</div><div class="line">    <span class="keyword">val</span> x = &#123; print(<span class="string">"x"</span>); <span class="number">1</span> &#125;</div><div class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> y = &#123; print(<span class="string">"y"</span>); <span class="number">2</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">z</span> </span>= &#123; print(<span class="string">"z"</span>); <span class="number">3</span> &#125;</div><div class="line">    z + y + x + z + y + x</div><div class="line">&#125;</div><div class="line">expr</div></pre></td></tr></table></figure>
<p>答案是xzyz。</p>
<p>之前的<code>Stream</code>实现可以改成懒求值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span></span>[<span class="type">T</span>](hd: <span class="type">T</span>, tl: =&gt; <span class="type">Stream</span>[<span class="type">T</span>]) = <span class="keyword">new</span> <span class="type">Stream</span>[<span class="type">T</span>] &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span> </span>= hd</div><div class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> tail = tl</div><div class="line">    …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h3><p>例如，从给定整数开始的所有整数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">Int</span>] = n #:: from(n+<span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> nats = from(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>例子：用筛法(The Sieve of Eratosthenes)求素数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">primes</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">Int</span>] = n #:: from(n+<span class="number">1</span>)        <span class="comment">// &gt; from: (n: Int)Stream[Int]</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sieve</span></span>(s: <span class="type">Stream</span>[<span class="type">Int</span>]): <span class="type">Stream</span>[<span class="type">Int</span>] =</div><div class="line">    s.head #:: sieve(s.tail filter (_ % s.head != <span class="number">0</span>))    <span class="comment">// &gt; sieve: (s: Stream[Int])Stream[Int]</span></div><div class="line">  <span class="keyword">val</span> primes = sieve(from(<span class="number">2</span>))                            <span class="comment">// &gt; primes: Stream[Int] = Stream(2, ?)</span></div><div class="line">  (primes take <span class="number">10</span>).toList                                <span class="comment">// &gt; res0: List[Int] = List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回顾之前<a href="http://stormluke.me//post/functional-programming-note-02/">用牛顿法求平方根</a>中的<code>sqrt</code>函数，可以用<code>Stream</code>来重构它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrtStream</span></span>(x: <span class="type">Double</span>): <span class="type">Stream</span>[<span class="type">Double</span>] = &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>) = (guess + x / guess) / <span class="number">2</span></div><div class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> guesses: <span class="type">Stream</span>[<span class="type">Double</span>] = <span class="number">1</span> #:: (guess map improve)</div><div class="line">    guess</div><div class="line">&#125;</div><div class="line">…</div><div class="line">sqrtStream(<span class="number">4</span>) filter (isGoodEnough(_, <span class="number">4</span>))</div></pre></td></tr></table></figure>
<h3 id="总练习：倒水问题"><a href="#总练习：倒水问题" class="headerlink" title="总练习：倒水问题"></a>总练习：倒水问题</h3><p>有一个水槽和若干无刻度只知道容量的杯子，如何操作才能倒出需要的水量？</p>
<p>简单规划一下：</p>
<ul>
<li>杯子Glass：<code>Int</code></li>
<li>状态State：<code>Vector[Int]</code></li>
<li>操作Moves：<ul>
<li>清空<code>Empty(glass)</code></li>
<li>装满<code>Fill(glass)</code></li>
<li>从一个杯子倒到另一个杯子<code>Pour(from, to)</code></li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pouring</span>(<span class="params">capacity: <span class="type">Vector</span>[<span class="type">Int</span>]</span>) </span>&#123;</div><div class="line">  <span class="comment">// States</span></div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">State</span> </span>= <span class="type">Vector</span>[<span class="type">Int</span>]</div><div class="line">  <span class="keyword">val</span> initialState = capacity map (x =&gt; <span class="number">0</span>)</div><div class="line">  <span class="comment">// Moves</span></div><div class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Move</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span></span>(state: <span class="type">State</span>): <span class="type">State</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Empty</span>(<span class="params">glass: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Move</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span></span>(state: <span class="type">State</span>) = state updated(glass, <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill</span>(<span class="params">glass: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Move</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span></span>(state: <span class="type">State</span>) = state updated(glass, capacity(glass))</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Pour</span>(<span class="params">from: <span class="type">Int</span>, to: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Move</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span></span>(state: <span class="type">State</span>) = &#123;</div><div class="line">      <span class="keyword">val</span> amount = state(from) min (capacity(to) - state(to))</div><div class="line">      state updated(from, state(from) - amount) updated(to, state(to) + amount)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> glasses = <span class="number">0</span> until capacity.length</div><div class="line">  <span class="keyword">val</span> moves =</div><div class="line">    (<span class="keyword">for</span> (g &lt;- glasses) <span class="keyword">yield</span> <span class="type">Empty</span>(g)) ++</div><div class="line">      (<span class="keyword">for</span> (g &lt;- glasses) <span class="keyword">yield</span> <span class="type">Fill</span>(g)) ++</div><div class="line">      (<span class="keyword">for</span> (from &lt;- glasses; to &lt;- glasses <span class="keyword">if</span> from != to) <span class="keyword">yield</span> <span class="type">Pour</span>(from, to))</div><div class="line">  <span class="comment">// Paths</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Path</span>(<span class="params">history: <span class="type">List</span>[<span class="type">Move</span>], val endState: <span class="type">State</span></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span></span>(move: <span class="type">Move</span>) = <span class="keyword">new</span> <span class="type">Path</span>(move :: history, move change endState)</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= (history.reverse mkString <span class="string">" "</span>) + <span class="string">"--&gt; "</span> + endState</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> initialPath = <span class="keyword">new</span> <span class="type">Path</span>(<span class="type">Nil</span>, initialState)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(paths: <span class="type">Set</span>[<span class="type">Path</span>], explored: <span class="type">Set</span>[<span class="type">State</span>]): <span class="type">Stream</span>[<span class="type">Set</span>[<span class="type">Path</span>]] =</div><div class="line">    <span class="keyword">if</span>(paths.isEmpty) <span class="type">Stream</span>.empty</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">val</span> more = <span class="keyword">for</span> &#123;</div><div class="line">        path &lt;- paths</div><div class="line">        next &lt;- moves map path.extend</div><div class="line">        <span class="keyword">if</span> !(explored contains next.endState)</div><div class="line">      &#125; <span class="keyword">yield</span> next</div><div class="line">      paths #:: from(more, explored ++ (more map (_.endState)))</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">val</span> pathSets = from(<span class="type">Set</span>(initialPath), <span class="type">Set</span>(initialState))</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">solutions</span></span>(target: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">Path</span>] =</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">      pathSet &lt;- pathSets</div><div class="line">      path &lt;- pathSet</div><div class="line">      <span class="keyword">if</span> path.endState contains target</div><div class="line">    &#125; <span class="keyword">yield</span> path</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> problem = <span class="keyword">new</span> <span class="type">Pouring</span>(<span class="type">Vector</span>(<span class="number">4</span>, <span class="number">9</span>, <span class="number">19</span>))    <span class="comment">// &gt; problem: Pouring = Pouring@1e86486b</span></div><div class="line">  problem.moves                                  <span class="comment">// &gt; res0: scala.collection.immutable.IndexedSeq[Product with Serializable with problem.Move] = Vector(Empty(0), Empty(1), Empty(2), Fill(0), Fill(1), Fill(2), Pour(0,1), Pour(0,2), Pour(1,0), Pour(1,2), Pour(2,0), Pour(2,1))</span></div><div class="line">  problem.solutions(<span class="number">17</span>)                          <span class="comment">// &gt; res1: Stream[problem.Path] = Stream(Fill(0) Pour(0,2) Fill(0) Fill(1) Pour(0,2) Pour(1,2)--&gt; Vector(0, 0, 17), ?)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当代码变长时注意：</p>
<ul>
<li>尽可能地命名</li>
<li>把操作放在自然的作用域里</li>
<li>保持可优化性</li>
</ul>
<h3 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h3><p>请直接参考网站<a href="https://class.coursera.org/progfun-002/class/index" target="_blank" rel="external">Functional Programming Principles in Scala</a>。</p>
<p>-完-</p>
</div></article></div></main><footer><div class="paginator"><a href="/reactive-programming-note-01/" class="prev">PREV</a><a href="/functional-programming-note-11/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'functional-programming-note-12/';
var disqus_title = '函数式编程笔记 12';
var disqus_url = 'http://stormluke.me/functional-programming-note-12/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>