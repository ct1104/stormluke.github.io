<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 响应式编程笔记 05 · Preferences</title><meta name="description" content="响应式编程笔记 05 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">响应式编程笔记 05</h1><div class="post-info">Jun 16, 2014</div><div class="post-content"><h3 id="扩展例子：离散事件模拟"><a href="#扩展例子：离散事件模拟" class="headerlink" title="扩展例子：离散事件模拟"></a>扩展例子：离散事件模拟</h3><p>这个例子用来展示赋值和高阶函数是如何以一种有趣的方式组合起来的。在本例中将会构建一个数字电路模拟器，而这个模拟器基于一个通用的离散事件模拟框架。</p>
<p>数字电路由电线和功能模块组成，电线传递由功能模块转化过的信号。本例中用布尔值 <code>true</code> 和 <code>false</code> 来表示信号，基础的功能模块（门）有：</p>
<ul>
<li>非门，输出为输入的反转</li>
<li>与门，输出为输入的合取</li>
<li>或门，输出为输入的析取</li>
</ul>
<a id="more"></a>
<p>其他的功能模块由这些基础模块组合而成。这些模块都有一个反应时间（或者<em>延迟</em>），就是说它们的输出不会立刻因输入的改变而改变。</p>
<p>在 Scala 中，用类 <code>Wire</code> 表示电线：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Wire</span>; <span class="keyword">val</span> b = <span class="keyword">new</span> <span class="type">Wire</span>; <span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line"><span class="comment">// or, equivalently:</span></div><div class="line"><span class="keyword">val</span> a, b, c = <span class="keyword">new</span> <span class="type">Wire</span></div></pre></td></tr></table></figure>
<p>用下面几个函数来表示门电路。每个函数都有副作用以创建门电路：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverter</span></span>(input: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">andGate</span></span>(a1: <span class="type">Wire</span>, a2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">orGate</span></span>(o1: <span class="type">Wire</span>, o2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>更复杂的模块可以由它们组成：</p>
<p><img src="http://ww4.sinaimg.cn/large/6ad06ebbgw1ehh2yf1cikj20a405ut8v.jpg" alt="halfAdder"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">halfAdder</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, s: <span class="type">Wire</span>, c:<span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> d = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  <span class="keyword">val</span> e = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  orGate(a, b, d)</div><div class="line">  andGate(a, b, c)</div><div class="line">  inverter(c, e)</div><div class="line">  andGate(d, e, s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/large/6ad06ebbgw1ehh2zsfnf6j20cz071q39.jpg" alt="fullAdder"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullAdder</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, cin: <span class="type">Wire</span>, sum: <span class="type">Wire</span>, cout: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  <span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  <span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  halfAdder(b, cin, s, c1)</div><div class="line">  halfAdder(a, s, sum, c2)</div><div class="line">  orGate(c1, c2, cout)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习：下面的程序描述了什么逻辑功能？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, c: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> d, e, f, g = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  inverter(a, d)</div><div class="line">  inverter(b, e)</div><div class="line">  andGate(a, e, f)</div><div class="line">  andGate(b, d, g)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是 <code>a != b</code>。</p>
<p>下面来给出类 <code>Wire</code> 和这些函数的实现，它们是基于离散事件模拟 API 的。</p>
<p>一个离散事件模拟器执行由用户在给定<em>时刻（moment）</em>提供的<em>动作（actions）</em>。一个动作如下定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Action</span> </span>= () =&gt; <span class="type">Unit</span></div></pre></td></tr></table></figure>
<p>另外模拟器中的<em>时间（time）</em>是模拟的，和实际时间无关。</p>
<p>模拟器的 trait 具有以下签名：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Simulation</span> </span>&#123;</div><div class="line">  <span class="comment">/** 当前模拟时间 */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">currentTime</span></span>: <span class="type">Int</span> = ???</div><div class="line">  <span class="comment">/** 在给定时间延迟后执行一段动作 */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">afterDelay</span></span>(delay: <span class="type">Int</span>)(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = ???</div><div class="line">  <span class="comment">/** 开始模拟直到没有在等待的动作 */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = ???</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个电线必须支持三种基本操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getSignal: <span class="type">Boolean</span>            <span class="comment">// 返回当前线路上的信号</span></div><div class="line">setSignal(sig: <span class="type">Boolean</span>): <span class="type">Unit</span> <span class="comment">// 修改线路上的信号</span></div><div class="line">addAction(a: <span class="type">Action</span>): <span class="type">Unit</span>    <span class="comment">// 在线路上附加指定的动作，在线路信号改变时这些动作都会被执行</span></div></pre></td></tr></table></figure>
<p>类 <code>Wire</code> 的实现如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wire</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sigVal = <span class="literal">false</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> actions = <span class="type">List</span>[<span class="type">Action</span>] = <span class="type">Nil</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSignal</span></span>: <span class="type">Boolean</span> = sigVal</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setSignal</span></span>(s: <span class="type">Boolean</span>): <span class="type">Unit</span> =</div><div class="line">    <span class="keyword">if</span> (s != sigVal) &#123;</div><div class="line">      sigVal = s</div><div class="line">      actions foreach (_())</div><div class="line">    &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addAction</span></span>(a: <span class="type">Action</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    actions = a :: actions</div><div class="line">    a()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个电线的状态有两个私有变量来表示，<code>sigVal</code> 表示当前信号值，<code>actions</code> 表示电线上附加的动作。</p>
<p>那三个门电路可以用以下方法实现，注意每个变化都在一定延迟之后才生效：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverter</span></span>(input: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">invertAction</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> inputSig = input.getSignal</div><div class="line">    afterDelay(<span class="type">InverterDelay</span>) &#123; output setSignal !inputSig &#125;</div><div class="line">  &#125;</div><div class="line">  input addAction invertAction</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">andGate</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">andAction</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> in1Sig = in1.getSignal</div><div class="line">    <span class="keyword">val</span> in2Sig = in2.getSignal</div><div class="line">    afterDelay(<span class="type">AndGateDelay</span>) &#123; output setSignal (in1Sig &amp; in2Sig) &#125;</div><div class="line">  &#125;</div><div class="line">  in1 addAction andAction</div><div class="line">  in2 addAction andAction</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">orGate</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">orAction</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> in1Sig = in1.getSignal</div><div class="line">    <span class="keyword">val</span> in2Sig = in2.getSignal</div><div class="line">    afterDelay(<span class="type">OrGateDelay</span>) &#123; output setSignal (in1Sig | in2Sig) &#125;</div><div class="line">  &#125;</div><div class="line">  in1 addAction orAction</div><div class="line">  in2 addAction orAction</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>练习：如果在 <code>afterDelay</code> 中直接计算 <code>in1Sig</code> 和 <code>in2Sig</code>，那么功能还相同吗？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">orGate2</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">orAction</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    afterDelay(<span class="type">OrGateDelay</span>) &#123; output setSignal (in1.getSignal | in2.getSignal) &#125;</div><div class="line">  &#125;</div><div class="line">  in1 addAction orAction</div><div class="line">  in2 addAction orAction</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>肯定不同啦，因为这个代码块在一段延迟后才调用，计算的信号值是延迟之后的。</p>
<p>接下来实现 <code>Simulation</code>，方法是用一个<em>日程表（agenda）</em>来保存所有的<em>事件（events）</em>，每个事件保存着动作的内容和开始时间。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Simulation</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Action</span> </span>= () =&gt; <span class="type">Unit</span></div><div class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span>(<span class="params">time: <span class="type">Int</span>, action: <span class="type">Action</span></span>)</span></div><div class="line"><span class="class">  <span class="title">private</span> <span class="title">type</span> <span class="title">Agenda</span> </span>= <span class="type">List</span>[<span class="type">Event</span>]</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> agenda: <span class="type">Agenda</span> = <span class="type">List</span>()</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> curtime = <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">currentTime</span></span>: <span class="type">Int</span> = curtime</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">afterDelay</span></span>(delay: <span class="type">Int</span>)(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> item = <span class="type">Event</span>(currentTime + delay, () =&gt; block)</div><div class="line">    agenda = insert(agenda, item)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(ag: <span class="type">List</span>[<span class="type">Event</span>], item: <span class="type">Event</span>): <span class="type">List</span>[<span class="type">Event</span>] = ag <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> first :: rest <span class="keyword">if</span> first.time </div><div class="line">      first :: insert(rest, item)</div><div class="line">    <span class="keyword">case</span> _ =&gt;</div><div class="line">      item :: ag</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(): <span class="type">Unit</span> = agenda <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> first :: rest =&gt;</div><div class="line">      agenda = rest</div><div class="line">      curtime = first.time</div><div class="line">      first.action()</div><div class="line">      loop()</div><div class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    afterDelay(<span class="number">0</span>) &#123;</div><div class="line">      println(<span class="string">"*** simulation started, time = "</span> + currentTime + <span class="string">" ***"</span>)</div><div class="line">    &#125;</div><div class="line">    loop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在开始模拟之前，需要有一种办法来查看线路上的信号，因此定义函数 <code>probe</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">probe</span></span>(name: <span class="type">String</span>, wire: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">probeAction</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    println(<span class="string">s"<span class="subst">$name</span> <span class="subst">$currentTime</span> value = <span class="subst">$&#123;wire.getSignal&#125;</span>"</span>)</div><div class="line">  &#125;</div><div class="line">  wire addAction probeAction</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将延迟常量封装在自己的 trait 里会更方便些：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Parameters</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">InverterDelay</span> </span>= <span class="number">2</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">AndGateDelay</span> </span>= <span class="number">3</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">OrGateDelay</span> </span>= <span class="number">5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此模拟器全部实现完成了。</p>
<p>练习：若用以下方法定义或门（使用与门和非门），在包含了这个或门的电路中模拟结果会有变化吗？</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1ehh31cbgvaj208v02ma9y.jpg" alt="orGateAlt"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">orGateAlt</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> notIn1, notIn2, notOut = <span class="keyword">new</span> <span class="type">Wire</span></div><div class="line">  inverter(in1, notIn1); inverter(in2, notIn2)</div><div class="line">  andGate(notIn1, notIn2, notOut)</div><div class="line">  inverter(notOut, output)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是时间会变化，另外可能会产生多余的事件。原因是当这个或门的输入发生变化时，变化会依次传递到其内的各个门电路中，最终导致多余事件产生。如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/6ad06ebbgw1ehh31sq7y2j20a004874d.jpg" alt="orGateAlt-effect"></p>
<p>由本例可以看出，状态和赋值的引入使得计算模型更复杂了，尤其是失去了引用透明特性。但另一方面，赋值可以更优美地构建一些特定程序，比如本例中的离散事件模拟。</p>
</div></article></div></main><footer><div class="paginator"><a href="/wwdc-2014-note-swift/" class="prev">PREV</a><a href="/reactive-programming-note-04/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'reactive-programming-note-05/';
var disqus_title = '响应式编程笔记 05';
var disqus_url = 'http://stormluke.me/reactive-programming-note-05/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>