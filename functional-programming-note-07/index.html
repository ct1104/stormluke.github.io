<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 函数式编程笔记 07 · Preferences</title><meta name="description" content="函数式编程笔记 07 - stormluke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://stormluke.me/atom.xml" title="Preferences"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/stormluke" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">函数式编程笔记 07</h1><div class="post-info">Jul 2, 2013</div><div class="post-content"><h3 id="变化-variance"><a href="#变化-variance" class="headerlink" title="变化(variance)"></a>变化(variance)</h3><p>大体上说，允许自身元素变化的类型不应该是协变的。</p>
<p>设<code>C[T]</code>是一个参数化的类型，<code>A</code>、<code>B</code>类型满足<code>A &lt;: B</code>。总体上，<code>C[A]</code>和<code>C[B]</code>间有三种可能的关系：</p>
<ul>
<li><code>C[A] &lt;: C[B]</code>：<code>C</code>是<em>协变</em>的</li>
<li><code>C[A] &gt;: C[B]</code>：<code>C</code>是<em>逆变(contravariant)</em>的</li>
<li><code>C[A]</code>和<code>C[B]</code>互不是对方的子类型：<code>C</code>是<em>不变(nonvariant)</em>的</li>
</ul>
<a id="more"></a>
<p>Scala允许通过注解类型参数来声明类型的变化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>[+<span class="type">A</span>] </span>&#123; … &#125;    <span class="comment">// C is covariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>[-<span class="type">A</span>] </span>&#123; … &#125;    <span class="comment">// C is contravariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>[<span class="type">A</span>] </span>&#123; … &#125;     <span class="comment">// C is nonvariant</span></div></pre></td></tr></table></figure>
<p>练习：假设有两个函数类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">A</span> </span>= <span class="type">IntSet</span> =&gt; <span class="type">NonEmpty</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">B</span> </span>= <span class="type">NonEmpty</span> =&gt; <span class="type">IntSet</span></div></pre></td></tr></table></figure>
<p>那么依据里氏替换原则，它们的关系应该是什么？</p>
<p>答案是<code>A &lt;: B</code>。</p>
<h3 id="函数的类型规则"><a href="#函数的类型规则" class="headerlink" title="函数的类型规则"></a>函数的类型规则</h3><p>通常，函数有下面的子类型规则：</p>
<blockquote>
<p>如果<code>A2 &lt;: A1</code>且<code>B1 &lt;: B2</code>，则<code>A1 =&gt; B1 &lt;: A2 =&gt; B2</code></p>
</blockquote>
<p>所以说函数的参数类型是<em>逆变</em>的，而返回值类型是<em>协变</em>的。于是<code>Function1</code>这个trait可以修改成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> scala</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">T</span>): <span class="type">U</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="变化检查"><a href="#变化检查" class="headerlink" title="变化检查"></a>变化检查</h3><p>如果把<code>Array</code>变成一个类，<code>update</code>变成一个方法，则大概会是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(x: <span class="type">T</span>) …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scala大体上会依据下面的内容检查变化注解是否满足：</p>
<ul>
<li><em>协变</em>类型参数只能出现在方法的返回值中</li>
<li><em>逆变</em>类型参数只能出现在方法的参数中</li>
<li><em>不变</em>类型参数可以在任何地方出现</li>
</ul>
<p>可以看到<code>Function1</code>是满足上面这些限制的。</p>
<p>练习：下面的代码有什么问题？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepend</span></span>(elem: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(elem, <span class="keyword">this</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>问题是`prepend不能通过变化检查。（参数不能是<em>协变</em>的）</p>
<p>解决方法可以是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepend</span></span>[<span class="type">U</span> &gt;: <span class="type">T</span>](elem: <span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(elem, <span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>练习：下面函数的返回值类型是什么？（已知<code>Empty &lt;: IntSet</code>、<code>NonEmpty &lt;: IntSet</code>）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(xs: <span class="type">List</span>[<span class="type">NonEmpty</span>], x: <span class="type">Empty</span>) = xs prepend x</div></pre></td></tr></table></figure>
<p>答案是<code>List[IntSet]</code>。</p>
<h3 id="分解-Decomposition"><a href="#分解-Decomposition" class="headerlink" title="分解(Decomposition)"></a>分解(Decomposition)</h3><p>假设现在要写一个算术表达式解释器，为了简单它只能处理数和它们的和。表达式可以用类的层次结构来表示，一个基trait <code>Expr</code>和两个子类<code>Number</code>、<code>Sum</code>。</p>
<p>可以用下面的方法来实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span> = n</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Number.leftOp"</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Number.rightOp"</span>)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(”<span class="type">Sum</span>.numValue”)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span> = e1</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span> = e2</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = &#123;</div><div class="line">  <span class="keyword">if</span>(e.isNumber) e.numValue</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (e.isSum) eval(e.leftOp) + eval(e.rightOp)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Unknown expression "</span> + e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这有个问题，如果想新加一些表达式，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span>    <span class="title">//</span> <span class="title">e1</span> <span class="title">*</span> <span class="title">e2</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Var</span>(<span class="params">x: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span>              <span class="title">//</span> <span class="title">Variable</span> '<span class="title">x</span>'</span></div></pre></td></tr></table></figure>
<p>就需要在从基trait开始的所有类中添加区分方法(<code>isXXX</code>)和访问方法(<code>numValue</code>, <code>leftOp</code>, etc)。实际上方法的数量是平方级增长的。</p>
<h3 id="类型测试和类型转换"><a href="#类型测试和类型转换" class="headerlink" title="类型测试和类型转换"></a>类型测试和类型转换</h3><p>要解决上面的问题，有一个不是办法的办法：使用类型测试和类型转换。</p>
<p>Scala允许使用类<code>Any</code>中的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isInstanceOf</span></span>[<span class="type">T</span>]: <span class="type">Boolean</span>    <span class="comment">// 检查此对象是否符合`T`类型</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">asInstanceOf</span></span>[<span class="type">T</span>]: <span class="type">T</span>          <span class="comment">// 把此对象当做`T`类型，如果失败则抛出ClassCastException</span></div></pre></td></tr></table></figure>
<p>这和Java的类似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">Scala</span>                <span class="type">Java</span></div><div class="line">x.isInstanceOf[<span class="type">T</span>]    x intanceof <span class="type">T</span></div><div class="line">x.asInstanceOf[<span class="type">T</span>]    (<span class="type">T</span>) x</div></pre></td></tr></table></figure>
<p>使用类型测试和转换的<code>eval</code>方法这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> =</div><div class="line">    <span class="keyword">if</span> (e.isInstanceOf[<span class="type">Number</span>])</div><div class="line">        e.asInstanceOf[<span class="type">Number</span>].numValue</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.isInstanceOf[<span class="type">Sum</span>])</div><div class="line">        eval(e.asInstanceOf[<span class="type">Sum</span>].leftOp) +</div><div class="line">        eval(e.asInstanceOf[<span class="type">Sum</span>].rightOp)</div><div class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Unknown expression "</span> + e)</div></pre></td></tr></table></figure>
<p>这种方法的优点是不再需要区别方法，缺点是代码抽象级别低且有潜在的不安全因素。</p>
<h3 id="面向对象分解"><a href="#面向对象分解" class="headerlink" title="面向对象分解"></a>面向对象分解</h3><p>也可以面向相对象的方法，这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = n</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = e1.eval + e2.eval</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果现在想显示表达式的值，就要在每个子类中定义相应的新方法。并且如果想化简表达式，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a * b + a * c -&gt; a * (b + c)</div></pre></td></tr></table></figure>
<p>上面的方法是做不到的。因为这不是一个局部化简，不能被概括在单个对象的方法里。</p>
<h3 id="模式匹配-pattern-matching"><a href="#模式匹配-pattern-matching" class="headerlink" title="模式匹配(pattern matching)"></a>模式匹配(pattern matching)</h3><p>注意到：测试和访问方法的唯一目的是<em>逆向</em>类的构造过程：</p>
<ul>
<li>用了哪一个子类？</li>
<li>构造器的参数是什么？</li>
</ul>
<p>这种情况在函数式语言中很常见，包括Scala。Scala自动化了这个过程。</p>
<h3 id="Case-Class"><a href="#Case-Class" class="headerlink" title="Case Class"></a>Case Class</h3><p>一个<em>case class</em>的定义和普通的类定义类似，除了前面有一个修饰符<code>case</code>。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div></pre></td></tr></table></figure>
<p>这也隐式上定义了含有<code>apply</code>方法的同伴对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Number</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Number</span>(n)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sum</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>) = <span class="keyword">new</span> <span class="type">Sum</span>(e1, e2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以可以用<code>Number(1)</code>替代<code>new Number(1)</code>。</p>
<p>模式匹配是C/Java中的<code>switch</code>在类层次上的推广。在Scala中用<code>match</code>关键字。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = e <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="匹配语法"><a href="#匹配语法" class="headerlink" title="匹配语法"></a>匹配语法</h3><ul>
<li><code>match</code>后跟一系列的<code>case</code>，<code>pat =&gt; expr</code></li>
<li>每个<code>case</code>有一个表达式<code>expr</code>和一个模式<code>pat</code></li>
<li>如果所有模式均不匹配选择器的值，则会抛出<code>MatchError</code>异常</li>
</ul>
<h3 id="模式的格式"><a href="#模式的格式" class="headerlink" title="模式的格式"></a>模式的格式</h3><p>模式由下面的构成：</p>
<ul>
<li>构造器，比如<code>Number</code>、<code>Sum</code></li>
<li>变量，比如<code>e1</code>、<code>e2</code></li>
<li>通配符，<code>_</code></li>
<li>常量，比如<code>1</code>、<code>true</code></li>
</ul>
<p>变量始终由小写字母开头，同名变量只能在模式中出现一次。</p>
<p>常量由大写字母开头，除了<code>null</code>、<code>true</code>、<code>false</code>是小写。</p>
<h3 id="求值匹配表达式"><a href="#求值匹配表达式" class="headerlink" title="求值匹配表达式"></a>求值匹配表达式</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e <span class="keyword">match</span> &#123; <span class="keyword">case</span> p1 =&gt; e1 … <span class="keyword">case</span> pn =&gt; en &#125;</div></pre></td></tr></table></figure>
<p><code>e</code>会匹配第一个符合的模式<code>p</code>，整个匹配表达式会被重写成右边的形式，模式中的变量也会被替换为相应的部分。</p>
<ul>
<li>一个构造器模式<code>C(p1, …, pn)</code>匹配所有由<code>p1, …, pn</code>参数构造的<code>C</code>类型的值</li>
<li>一个变量模式<code>x</code>匹配任何值，并且绑定到那个值</li>
<li>一个常量模式<code>c</code>匹配和<code>c</code>相等的值（<code>==</code>）</li>
</ul>
<p>例子：</p>
<p>假设<code>eval</code>函数为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e) = e <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt;</div><div class="line">        eval(e1) + eval(e2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则匹配过程是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">eval(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">1</span>), <span class="type">Number</span>(<span class="number">2</span>)))</div><div class="line">-&gt;</div><div class="line"><span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">1</span>), <span class="type">Number</span>(<span class="number">2</span>)) <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">eval(<span class="type">Number</span>(<span class="number">1</span>)) + eval(<span class="type">Number</span>(<span class="number">2</span>))</div><div class="line">-&gt;</div><div class="line"><span class="type">Number</span>(<span class="number">1</span>) <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</div><div class="line">&#125; + eval(<span class="type">Number</span>(<span class="number">2</span>))</div><div class="line">-&gt;</div><div class="line"><span class="number">1</span> + eval(<span class="type">Number</span>(<span class="number">2</span>))</div><div class="line">-&gt;&gt;</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>把<code>eval</code>写成方法也是可以的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">        <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; e1.eval + e2.eval</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>面向对象分解和模式匹配都是不错的方法，在使用时应根据具体情境选择。如果扩展上更多的是创建新子类，则面向对象分解更适合；如果扩展上更多的是创建新方法，那么模式匹配更有优势。</p>
</div></article></div></main><footer><div class="paginator"><a href="/functional-programming-note-08/" class="prev">PREV</a><a href="/functional-programming-note-06/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stormluke-preferences';
var disqus_identifier = 'functional-programming-note-07/';
var disqus_title = '函数式编程笔记 07';
var disqus_url = 'http://stormluke.me/functional-programming-note-07/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stormluke-preferences.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2018 <a href="http://stormluke.me">stormluke</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-60486509-1",'auto');ga('send','pageview');</script></body></html>